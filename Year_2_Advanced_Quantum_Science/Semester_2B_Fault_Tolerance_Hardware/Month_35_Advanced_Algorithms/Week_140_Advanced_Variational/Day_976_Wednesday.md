# Day 976: Hardware-Efficient Ansatze

## Schedule Overview

| Block | Time | Duration | Activity |
|-------|------|----------|----------|
| Morning | 9:00 AM - 12:30 PM | 3.5 hours | Theory: Hardware-Efficient Circuit Design |
| Afternoon | 2:00 PM - 4:30 PM | 2.5 hours | Problem Solving |
| Evening | 7:00 PM - 8:00 PM | 1 hour | Computational Lab |

**Total Study Time:** 7 hours

---

## Learning Objectives

By the end of Day 976, you will be able to:

1. Design hardware-efficient ansatze matched to device constraints
2. Analyze trade-offs between expressibility and trainability
3. Implement ansatze for different hardware topologies (linear, heavy-hex, all-to-all)
4. Compare hardware-efficient vs chemically-inspired circuit designs
5. Quantify circuit expressibility using statistical measures
6. Optimize ansatz structure for given hardware specifications

---

## Core Content

### 1. The Hardware-Efficient Philosophy

The core idea: Design circuits that work well on actual quantum hardware, not idealized abstract machines.

**Key Constraints:**

1. **Native gate set:** Use only gates the device implements directly
2. **Connectivity:** Respect which qubits can interact
3. **Gate fidelity:** Minimize total gate count
4. **Coherence time:** Keep circuits shallow

**The Trade-off:**

> High expressibility (able to represent many states) often comes at the cost of low trainability (hard to optimize).

This is the central tension in hardware-efficient ansatz design.

---

### 2. Native Gate Sets

Different quantum computers have different native gates:

**Superconducting (IBM, Google):**
- Single-qubit: $R_X(\theta)$, $R_Z(\theta)$, $\sqrt{X}$
- Two-qubit: CNOT (ECR), CZ

**Trapped Ions (IonQ, Quantinuum):**
- Single-qubit: Any $R_\phi(\theta)$
- Two-qubit: XX (Molmer-Sorensen), ZZ

**Neutral Atoms (QuEra):**
- Native Rydberg gates
- CZ via blockade

**Photonics:**
- Beam splitters, phase shifters
- Measurement-based

**Compilation Overhead:**

Non-native gates require decomposition:
$$\text{SWAP} = \text{CNOT}_{01} \cdot \text{CNOT}_{10} \cdot \text{CNOT}_{01} \quad (3 \text{ CNOTs})$$

$$\text{Toffoli} = 6 \text{ CNOTs} + \text{single-qubit gates}$$

---

### 3. Hardware Topologies

**Linear Chain:**
```
0 -- 1 -- 2 -- 3 -- 4
```
Only nearest-neighbor interactions. Common in ion traps.

**Heavy-Hex (IBM):**
```
    0       3
   / \     / \
  1   2   4   5
   \ /     \ /
    6       9
```
Mixed connectivity for error correction.

**Square Grid (Google Sycamore):**
```
0 -- 1 -- 2
|    |    |
3 -- 4 -- 5
|    |    |
6 -- 7 -- 8
```

**All-to-All (Trapped Ions):**
Any qubit can interact with any other. Most flexible but harder to scale.

---

### 4. Hardware-Efficient Ansatz Structure

The canonical form (Kandala et al., 2017):

$$|\psi(\boldsymbol{\theta})\rangle = \prod_{l=1}^{L} U_{\text{ent}} \cdot \prod_i R(\theta_{l,i}) |0\rangle^{\otimes n}$$

**Components:**

1. **Rotation layer:** Single-qubit rotations on all qubits
   $$R(\theta, \phi, \lambda) = R_Z(\lambda) R_Y(\phi) R_Z(\theta)$$

2. **Entangling layer:** Two-qubit gates following hardware connectivity

**Standard Patterns:**

*Linear entanglement:*
```
q0: ─●──────
     │
q1: ─X──●───
        │
q2: ────X──●
           │
q3: ───────X
```

*Circular entanglement:*
```
q0: ─●─────────X
     │         │
q1: ─X──●──────│
        │      │
q2: ────X──●───│
           │   │
q3: ───────X──●─
```

*All-to-all entanglement:*
```
q0: ─●──●──●─
     │  │  │
q1: ─X──│──│─●──●─
        │  │ │  │
q2: ────X──│─X──│─●─
           │    │ │
q3: ───────X────X─X─
```

---

### 5. Expressibility

How well can an ansatz represent arbitrary states?

**Definition (Expressibility):**

$$\mathcal{E} = D_{KL}(\hat{P}_{U} \| P_{\text{Haar}})$$

where $\hat{P}_U$ is the distribution of states generated by the ansatz and $P_{\text{Haar}}$ is the uniform (Haar) distribution on the state space.

**Practical Measure (Fidelity-based):**

Sample pairs of parameter vectors $(\theta, \phi)$ and compute:
$$F = |\langle \psi(\theta) | \psi(\phi) \rangle|^2$$

Compare the distribution of $F$ to the expected Porter-Thomas distribution for Haar-random states:
$$P_{\text{Haar}}(F) = (d-1)(1-F)^{d-2}$$

where $d = 2^n$ is the Hilbert space dimension.

**Expressibility vs Depth:**

| Layers | Expressibility | Trainability |
|--------|----------------|--------------|
| 1 | Low | High |
| 2-3 | Moderate | Moderate |
| 5+ | High | Low (barren) |
| $O(n)$ | Near-Haar | Very low |

---

### 6. The Expressibility-Trainability Trade-off

**McClean et al. (2018) showed:**

For highly expressive (Haar-random-like) ansatze:
$$\boxed{\text{Var}[\partial_\theta C] \leq O(2^{-n})}$$

The gradient variance vanishes exponentially with system size!

**Implications:**
- Cannot distinguish good from bad parameters
- Optimization becomes random walk
- Requires exponential precision to measure gradients

**The Goldilocks Zone:**

We need ansatze that are:
- Expressive enough to represent the target state
- Structured enough to avoid barren plateaus

This is the central challenge of variational quantum algorithms.

---

### 7. Problem-Inspired vs Hardware-Efficient

**Hardware-Efficient Ansatz (HEA):**

*Pros:*
- Minimal compilation overhead
- Short circuit depth
- Easy to implement

*Cons:*
- No physical meaning
- Barren plateau prone
- May be over-parameterized

**Chemically-Inspired Ansatz (UCCSD, ADAPT):**

*Pros:*
- Physical meaning
- Often better trainability
- Systematic improvability

*Cons:*
- Long circuits after compilation
- Hardware-agnostic design
- Many non-native gates

**Comparison Table:**

| Aspect | HEA | UCCSD | ADAPT-VQE |
|--------|-----|-------|-----------|
| Circuit depth | O(L) | O(N^4) | O(adaptive) |
| Parameters | O(nL) | O(N^4) | O(minimal) |
| Native gates | Yes | No | Partial |
| Physical meaning | No | Yes | Yes |
| Barren plateaus | Yes (deep) | Less common | Rare |
| Expressibility | Tunable | Constrained | Adaptive |

---

## Practical Applications

### Designing for IBM Quantum Hardware

**Target:** IBM Eagle (127 qubits, heavy-hex topology)

**Considerations:**
1. Use ECR (echoed cross-resonance) as native two-qubit gate
2. Respect heavy-hex connectivity
3. Limit circuit depth to coherence time / gate time

**Example Ansatz for 4 Qubits (linear subset):**

```python
def ibm_hea_layer(params, wires):
    # Single-qubit rotations
    for i, w in enumerate(wires):
        qml.RZ(params[3*i], wires=w)
        qml.RX(params[3*i + 1], wires=w)
        qml.RZ(params[3*i + 2], wires=w)

    # ECR gates (decomposed as CNOT for simulation)
    for i in range(len(wires) - 1):
        qml.CNOT(wires=[wires[i], wires[i+1]])
```

---

## Worked Examples

### Example 1: Parameter Count Analysis

**Problem:** Compare parameter counts for a 10-qubit system with 3 layers.

**Solution:**

**Hardware-Efficient (RY-RZ rotation + linear CNOT):**
- Rotations per layer: $2 \times 10 = 20$ parameters
- Total: $3 \times 20 = 60$ parameters
- CNOTs per layer: 9 (no parameters)
- Total gates: 60 rotations + 27 CNOTs = 87 gates

**UCCSD (10 spin-orbitals, 4 electrons):**
- Singles: $\binom{4}{1} \times \binom{6}{1} = 24$
- Doubles: $\binom{4}{2} \times \binom{6}{2} = 90$
- Total parameters: ~114
- Gates per excitation: ~10-20 (after Trotter)
- Total gates: ~1500+ gates

**Ratio:** HEA uses ~5% of the gates of UCCSD!

---

### Example 2: Expressibility Calculation

**Problem:** Estimate expressibility for a single-layer RY ansatz on 2 qubits.

**Solution:**

The ansatz: $|\psi(\theta_1, \theta_2)\rangle = R_Y(\theta_1) \otimes R_Y(\theta_2) |00\rangle$

This produces states:
$$|\psi\rangle = \cos(\theta_1/2)\cos(\theta_2/2)|00\rangle + \cos(\theta_1/2)\sin(\theta_2/2)|01\rangle$$
$$+ \sin(\theta_1/2)\cos(\theta_2/2)|10\rangle + \sin(\theta_1/2)\sin(\theta_2/2)|11\rangle$$

This is a product state (no entanglement). The expressibility is low because:

1. Cannot reach entangled states like $\frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$
2. Fidelity distribution is far from Porter-Thomas

**Quantification:**

For Haar-random 2-qubit states, $\langle F \rangle = 1/d = 1/4$.

For our ansatz, fidelity between random parameter choices:
$$F = |\langle \psi(\theta) | \psi(\phi) \rangle|^2 = \cos^2\left(\frac{\theta_1 - \phi_1}{2}\right) \cos^2\left(\frac{\theta_2 - \phi_2}{2}\right)$$

This averages to $\langle F \rangle = (1/2)^2 = 1/4$ but with different distribution shape (not Porter-Thomas).

Adding entangling gates increases expressibility toward Haar-random.

---

### Example 3: Topology-Adapted Design

**Problem:** Design an ansatz for a 6-qubit star topology (qubit 0 connected to all others).

**Solution:**

Topology:
```
    1
    |
5 - 0 - 2
    |
    4
    |
    3
```

**Entangling pattern:** Use qubit 0 as hub

```
Layer structure:
1. Rotations on all qubits
2. CNOTs: 0→1, 0→2, 0→4, 0→5
3. CNOT: 4→3 (only way to entangle qubit 3)
4. Rotations on all qubits
5. Repeat
```

**Circuit depth per layer:**
- Rotations: depth 1 (parallel)
- CNOTs 0→{1,2,4,5}: depth 4 (sequential through qubit 0)
- CNOT 4→3: depth 1

Total: ~6 layers of gates per ansatz layer

**Alternative:** Parallelize CNOTs from qubit 0
- 0→1 and 0→2 can be parallel (different targets)
- Actually: 0→1, 0→5 parallel; then 0→2, 0→4 parallel
- Depth: 2 + 1 = 3 for entangling

---

## Practice Problems

### Level 1: Direct Application

1. For a 4-qubit linear topology, draw the circuit for one layer of a hardware-efficient ansatz with RY-RZ rotations and nearest-neighbor CNOTs.

2. Calculate the total number of parameters for a 6-qubit HEA with 2 layers, using only RY rotations.

3. List the native two-qubit gates for: (a) IBM superconducting, (b) IonQ trapped ions, (c) Google Sycamore.

### Level 2: Intermediate

4. Derive the number of CNOT gates needed to implement a SWAP gate. Then calculate how many SWAPs are needed to connect qubit 0 to qubit 5 on a linear chain.

5. For the ansatz $U(\theta) = e^{-i\theta(X_0X_1 + Y_0Y_1)}$, show that it can be implemented with 2 CNOTs and single-qubit rotations.

6. Design a hardware-efficient ansatz for the heavy-hex topology that maximizes parallelism in the entangling layer.

### Level 3: Challenging

7. Prove that an $n$-qubit ansatz with $L$ layers of alternating single-qubit rotations and nearest-neighbor CNOTs has at most $O(L)$ entangling depth, and argue why this limits its expressibility.

8. Analyze the expressibility of a "reverse causal cone" ansatz where each layer only entangles qubits that haven't been entangled before. What is the minimum depth to reach full expressibility?

9. **Research:** How does the choice of entangling gate (CNOT vs CZ vs iSWAP) affect the expressibility and trainability of hardware-efficient ansatze?

---

## Computational Lab

### Objective
Implement and analyze hardware-efficient ansatze with different structures.

```python
"""
Day 976 Computational Lab: Hardware-Efficient Ansatze
Advanced Variational Methods - Week 140
"""

import numpy as np
import pennylane as qml
from pennylane import numpy as pnp
import matplotlib.pyplot as plt
from scipy.optimize import minimize

# =============================================================================
# Part 1: Different Ansatz Structures
# =============================================================================

print("=" * 70)
print("Part 1: Hardware-Efficient Ansatz Structures")
print("=" * 70)

n_qubits = 4

def linear_entanglement(wires):
    """Linear chain CNOT pattern."""
    for i in range(len(wires) - 1):
        qml.CNOT(wires=[wires[i], wires[i+1]])

def circular_entanglement(wires):
    """Circular CNOT pattern."""
    for i in range(len(wires) - 1):
        qml.CNOT(wires=[wires[i], wires[i+1]])
    qml.CNOT(wires=[wires[-1], wires[0]])

def full_entanglement(wires):
    """All-to-all CNOT pattern."""
    for i in range(len(wires)):
        for j in range(i+1, len(wires)):
            qml.CNOT(wires=[wires[i], wires[j]])

def rotation_layer(params, wires, start_idx=0):
    """Apply RY-RZ rotations to all qubits."""
    for i, w in enumerate(wires):
        qml.RY(params[start_idx + 2*i], wires=w)
        qml.RZ(params[start_idx + 2*i + 1], wires=w)
    return start_idx + 2 * len(wires)

def build_hea(n_layers, entanglement='linear'):
    """Build hardware-efficient ansatz."""
    entangle_funcs = {
        'linear': linear_entanglement,
        'circular': circular_entanglement,
        'full': full_entanglement
    }

    n_params = n_layers * 2 * n_qubits + 2 * n_qubits  # Final rotation layer

    def ansatz(params, wires):
        idx = 0
        for layer in range(n_layers):
            idx = rotation_layer(params, wires, idx)
            entangle_funcs[entanglement](wires)
        idx = rotation_layer(params, wires, idx)

    return ansatz, n_params

# Print ansatz structures
print("\nAnsatz configurations for 4 qubits, 2 layers:")
for ent_type in ['linear', 'circular', 'full']:
    _, n_params = build_hea(2, ent_type)
    print(f"  {ent_type.capitalize()} entanglement: {n_params} parameters")

# =============================================================================
# Part 2: Expressibility Analysis
# =============================================================================

print("\n" + "=" * 70)
print("Part 2: Expressibility Analysis")
print("=" * 70)

dev = qml.device('default.qubit', wires=n_qubits)

def compute_expressibility(ansatz_func, n_params, n_samples=500):
    """
    Compute expressibility by comparing fidelity distribution
    to Haar-random expectation.
    """
    @qml.qnode(dev)
    def circuit(params):
        ansatz_func(params, wires=range(n_qubits))
        return qml.state()

    # Sample random parameter pairs
    fidelities = []
    for _ in range(n_samples):
        params1 = np.random.uniform(0, 2*np.pi, n_params)
        params2 = np.random.uniform(0, 2*np.pi, n_params)

        state1 = circuit(params1)
        state2 = circuit(params2)

        fidelity = np.abs(np.vdot(state1, state2))**2
        fidelities.append(fidelity)

    return np.array(fidelities)

# Compute for different depths and entanglement types
print("\nComputing expressibility (this may take a moment)...")

results = {}
for n_layers in [1, 2, 4]:
    for ent_type in ['linear', 'circular', 'full']:
        ansatz, n_params = build_hea(n_layers, ent_type)
        fidelities = compute_expressibility(ansatz, n_params, n_samples=300)
        results[(n_layers, ent_type)] = fidelities
        print(f"  Layers={n_layers}, {ent_type}: mean F = {fidelities.mean():.4f}")

# Haar-random expectation for comparison
d = 2**n_qubits
haar_mean = 1/d
print(f"\nHaar-random mean fidelity: {haar_mean:.4f}")

# =============================================================================
# Part 3: Visualization of Expressibility
# =============================================================================

print("\n" + "=" * 70)
print("Part 3: Expressibility Visualization")
print("=" * 70)

fig, axes = plt.subplots(1, 3, figsize=(14, 4))

for idx, n_layers in enumerate([1, 2, 4]):
    ax = axes[idx]

    for ent_type, color in [('linear', 'blue'), ('circular', 'green'), ('full', 'red')]:
        fidelities = results[(n_layers, ent_type)]
        ax.hist(fidelities, bins=30, alpha=0.5, density=True,
               label=ent_type, color=color)

    # Porter-Thomas distribution (Haar-random)
    x = np.linspace(0, 1, 100)
    porter_thomas = (d - 1) * (1 - x)**(d - 2)
    ax.plot(x, porter_thomas, 'k--', linewidth=2, label='Haar-random')

    ax.set_xlabel('Fidelity')
    ax.set_ylabel('Probability Density')
    ax.set_title(f'{n_layers} Layer(s)')
    ax.legend(fontsize=8)
    ax.set_xlim(0, 1)

plt.suptitle('Expressibility: Fidelity Distribution vs Haar-Random', fontsize=12)
plt.tight_layout()
plt.savefig('day_976_expressibility.png', dpi=150, bbox_inches='tight')
plt.show()
print("\nFigure saved as 'day_976_expressibility.png'")

# =============================================================================
# Part 4: VQE Performance Comparison
# =============================================================================

print("\n" + "=" * 70)
print("Part 4: VQE Performance with Different Ansatze")
print("=" * 70)

# Create a Hamiltonian (transverse-field Ising model)
def create_tfim_hamiltonian(n_qubits, J=1.0, h=0.5):
    """Transverse-field Ising model."""
    coeffs = []
    ops = []

    # ZZ interactions
    for i in range(n_qubits - 1):
        coeffs.append(-J)
        ops.append(qml.PauliZ(i) @ qml.PauliZ(i+1))

    # Transverse field
    for i in range(n_qubits):
        coeffs.append(-h)
        ops.append(qml.PauliX(i))

    return qml.Hamiltonian(coeffs, ops)

H = create_tfim_hamiltonian(n_qubits)

# Exact ground state energy
H_matrix = qml.matrix(H)
eigenvalues = np.linalg.eigvalsh(H_matrix)
exact_energy = eigenvalues[0]
print(f"Exact ground state energy: {exact_energy:.6f}")

# VQE for each ansatz
vqe_results = {}

for n_layers in [1, 2, 3]:
    for ent_type in ['linear', 'circular', 'full']:
        ansatz, n_params = build_hea(n_layers, ent_type)

        @qml.qnode(dev)
        def cost_circuit(params):
            ansatz(params, wires=range(n_qubits))
            return qml.expval(H)

        def cost(params):
            return float(cost_circuit(pnp.array(params)))

        # Multiple random initializations
        best_energy = float('inf')
        for trial in range(3):
            x0 = np.random.uniform(-0.1, 0.1, n_params)
            result = minimize(cost, x0, method='COBYLA',
                            options={'maxiter': 200})
            if result.fun < best_energy:
                best_energy = result.fun

        vqe_results[(n_layers, ent_type)] = best_energy
        error = (best_energy - exact_energy) * 1000  # mHa
        print(f"  Layers={n_layers}, {ent_type}: E = {best_energy:.6f} (error: {error:.2f} mHa)")

# =============================================================================
# Part 5: Depth vs Accuracy Trade-off
# =============================================================================

print("\n" + "=" * 70)
print("Part 5: Depth vs Accuracy Trade-off")
print("=" * 70)

fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Energy vs layers
for ent_type, marker in [('linear', 'o'), ('circular', 's'), ('full', '^')]:
    layers = [1, 2, 3]
    energies = [vqe_results[(l, ent_type)] for l in layers]
    ax1.plot(layers, energies, marker=marker, markersize=8, label=ent_type)

ax1.axhline(y=exact_energy, color='k', linestyle='--', label='Exact')
ax1.set_xlabel('Number of Layers')
ax1.set_ylabel('Energy')
ax1.set_title('VQE Energy vs Ansatz Depth')
ax1.legend()
ax1.grid(True, alpha=0.3)

# Error vs parameters
for ent_type, color in [('linear', 'blue'), ('circular', 'green'), ('full', 'red')]:
    layers = [1, 2, 3]
    params_list = []
    errors = []
    for l in layers:
        _, n_p = build_hea(l, ent_type)
        params_list.append(n_p)
        errors.append(abs(vqe_results[(l, ent_type)] - exact_energy) * 1000)

    ax2.scatter(params_list, errors, c=color, s=100, label=ent_type)
    ax2.plot(params_list, errors, c=color, linestyle='--', alpha=0.5)

ax2.set_xlabel('Number of Parameters')
ax2.set_ylabel('Error (mHa)')
ax2.set_title('Error vs Parameter Count')
ax2.set_yscale('log')
ax2.legend()
ax2.grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('day_976_depth_accuracy.png', dpi=150, bbox_inches='tight')
plt.show()
print("\nFigure saved as 'day_976_depth_accuracy.png'")

# =============================================================================
# Part 6: Hardware Topology Simulation
# =============================================================================

print("\n" + "=" * 70)
print("Part 6: Topology-Constrained Ansatz")
print("=" * 70)

# Simulate a 6-qubit heavy-hex fragment
# Topology: 0-1-2
#             |
#             3
#             |
#           4-5

heavy_hex_edges = [(0, 1), (1, 2), (1, 3), (3, 4), (4, 5)]

def heavy_hex_entanglement(wires):
    """Entanglement following heavy-hex connectivity."""
    for i, j in heavy_hex_edges:
        qml.CNOT(wires=[i, j])

n_qubits_hex = 6
dev_hex = qml.device('default.qubit', wires=n_qubits_hex)

@qml.qnode(dev_hex)
def heavy_hex_circuit(params):
    n_layers = 2
    idx = 0
    for layer in range(n_layers):
        for i in range(n_qubits_hex):
            qml.RY(params[idx], wires=i)
            idx += 1
            qml.RZ(params[idx], wires=i)
            idx += 1
        heavy_hex_entanglement(range(n_qubits_hex))
    # Final rotations
    for i in range(n_qubits_hex):
        qml.RY(params[idx], wires=i)
        idx += 1
    return qml.state()

n_params_hex = 2 * 2 * n_qubits_hex + n_qubits_hex
print(f"Heavy-hex ansatz: {n_qubits_hex} qubits, {n_params_hex} parameters")
print(f"Entangling gates per layer: {len(heavy_hex_edges)}")

# Compute expressibility
fidelities_hex = []
for _ in range(200):
    p1 = np.random.uniform(0, 2*np.pi, n_params_hex)
    p2 = np.random.uniform(0, 2*np.pi, n_params_hex)
    s1 = heavy_hex_circuit(p1)
    s2 = heavy_hex_circuit(p2)
    fidelities_hex.append(np.abs(np.vdot(s1, s2))**2)

print(f"Mean fidelity: {np.mean(fidelities_hex):.4f}")
print(f"Haar-random expectation: {1/2**n_qubits_hex:.4f}")

print("\n" + "=" * 70)
print("Lab Complete!")
print("=" * 70)
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| HEA structure | $\|\psi\rangle = \prod_l U_{\text{ent}} \prod_i R(\theta_{l,i}) \|0\rangle$ |
| Expressibility | $\mathcal{E} = D_{KL}(\hat{P}_U \| P_{\text{Haar}})$ |
| Porter-Thomas | $P(F) = (d-1)(1-F)^{d-2}$ |
| Haar mean fidelity | $\langle F \rangle_{\text{Haar}} = 1/d$ |
| Gradient variance | $\text{Var}[\partial_\theta C] \sim O(2^{-n})$ (barren) |

### Main Takeaways

1. **Hardware-efficient ansatze** prioritize native gates and connectivity
2. **Expressibility** measures how well an ansatz covers the state space
3. **Depth increases expressibility** but decreases trainability
4. **Topology matters:** Match entangling pattern to hardware
5. **Trade-offs are fundamental:** No free lunch in ansatz design
6. **Problem structure** can guide ansatz choice beyond pure HEA

---

## Daily Checklist

- [ ] Understand native gate sets for major platforms
- [ ] Design ansatze for different topologies
- [ ] Work through all three examples
- [ ] Complete Level 1 practice problems
- [ ] Attempt at least one Level 2 problem
- [ ] Run and modify the computational lab
- [ ] Compare expressibility of shallow vs deep circuits

---

## Preview: Day 977

Tomorrow we derive the **parameter shift rule**—the key technique for computing exact gradients on quantum hardware. We'll explore connections to quantum Fisher information and natural gradients.

---

*"The best ansatz is the one you can actually run."*
--- Practical quantum computing wisdom

---

**Next:** [Day_977_Thursday.md](Day_977_Thursday.md) - Parameter Shift Rules & Gradients

# Day 862: Clifford+T Universality

## Week 124: Universal Fault-Tolerant Computation | Month 31: Fault-Tolerant QC I

---

### Schedule Overview (7 hours)

| Block | Time | Focus |
|-------|------|-------|
| Morning | 2.5 hrs | The Clifford group and its limitations |
| Afternoon | 2.5 hrs | T-gate and universality proof |
| Evening | 2.0 hrs | Computational exploration |

---

### Learning Objectives

By the end of today, you will be able to:

1. **Define the Clifford group** and enumerate its generators {H, S, CNOT}
2. **Explain the Gottesman-Knill theorem** and why Clifford circuits are classically simulable
3. **Prove that adding the T-gate** generates a dense subgroup of SU(2)
4. **Apply the density argument** to show universal approximation capability
5. **Connect Clifford+T to magic state injection** for fault-tolerant implementation
6. **Analyze the structure of Clifford+T circuits** and their computational properties

---

### Core Content

#### Part 1: The Clifford Group

The **Clifford group** $\mathcal{C}_n$ on $n$ qubits consists of all unitary operations that map Pauli operators to Pauli operators under conjugation:

$$\boxed{\mathcal{C}_n = \{U \in U(2^n) : U P U^\dagger \in \mathcal{P}_n \text{ for all } P \in \mathcal{P}_n\}}$$

where $\mathcal{P}_n$ is the Pauli group on $n$ qubits.

**Generators of the Clifford Group:**

The single-qubit Clifford group $\mathcal{C}_1$ is generated by:

$$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}, \quad S = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}$$

For multiple qubits, we add:

$$\text{CNOT} = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix}$$

**Theorem (Clifford Group Structure):** The Clifford group $\mathcal{C}_n$ is a finite group of order:

$$|\mathcal{C}_n| = 2^{n^2+2n} \prod_{k=1}^{n}(4^k - 1)$$

For $n=1$: $|\mathcal{C}_1| = 24$ (the symmetry group of the octahedron).

**Clifford Action on Paulis:**

| Gate | X → | Y → | Z → |
|------|-----|-----|-----|
| H | Z | -Y | X |
| S | Y | -X | Z |
| CNOT | X⊗I, I⊗X | Y⊗X, I⊗Y | Z⊗I, Z⊗Z |

---

#### Part 2: The Gottesman-Knill Theorem

**Theorem (Gottesman-Knill):** A quantum circuit consisting of:
1. Preparation of qubits in computational basis states
2. Clifford gates
3. Measurements in the computational basis

can be efficiently simulated on a classical computer in polynomial time.

**Proof Sketch:**

The key insight is the **stabilizer formalism**. Any state $|\psi\rangle$ prepared by Clifford gates from $|0\rangle^{\otimes n}$ is a **stabilizer state**, uniquely specified by $n$ independent Pauli operators $\{g_1, \ldots, g_n\}$ such that:

$$g_i |\psi\rangle = |\psi\rangle \quad \forall i$$

Since Clifford gates map Paulis to Paulis:
- We can track the stabilizer generators (only $O(n^2)$ bits)
- Each gate application is a simple update rule
- Measurement outcomes are determined by stabilizer structure

**Implication:** Clifford circuits alone cannot provide quantum computational advantage. We need non-Clifford gates.

---

#### Part 3: The T-Gate

The **T-gate** (or $\pi/8$ gate) is:

$$\boxed{T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix} = e^{i\pi/8} \begin{pmatrix} e^{-i\pi/8} & 0 \\ 0 & e^{i\pi/8} \end{pmatrix}}$$

Equivalently: $T = R_z(\pi/4)$ up to a global phase.

**Key Properties:**

1. $T^2 = S$ (the phase gate)
2. $T^8 = I$ (T has order 8)
3. $T \notin \mathcal{C}_1$ (T is non-Clifford)
4. $HTH = R_x(\pi/4)$ up to phase

**Why T is Non-Clifford:**

$$TXT^\dagger = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix} \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} \begin{pmatrix} 1 & 0 \\ 0 & e^{-i\pi/4} \end{pmatrix} = \begin{pmatrix} 0 & e^{-i\pi/4} \\ e^{i\pi/4} & 0 \end{pmatrix}$$

This equals $e^{i\pi/4} \cdot \frac{X + Y}{\sqrt{2}}$, which is not a Pauli operator.

---

#### Part 4: Universality Proof

**Theorem (Clifford+T Universality):** The gate set $\{H, S, T, \text{CNOT}\}$ generates a dense subgroup of $SU(2^n)$.

**Proof for Single-Qubit Case (n=1):**

We show that the group $G = \langle H, T \rangle$ generated by $H$ and $T$ is dense in $SU(2)$.

**Step 1: Identify a rotation axis**

Consider the composition $A = HTH$:

$$A = HTH = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix} \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix} \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$

After calculation:
$$A = e^{i\pi/8} R_x(\pi/4)$$

**Step 2: Identify another rotation axis**

The T-gate itself is:
$$T = e^{i\pi/8} R_z(\pi/4)$$

**Step 3: Apply the density argument**

We have rotations around two non-parallel axes (x and z).

**Lemma (Density Criterion):** Let $R_{\hat{n}_1}(\theta_1)$ and $R_{\hat{n}_2}(\theta_2)$ be rotations around non-parallel axes in $SU(2)$ (or $SO(3)$). If $\theta_1/\pi$ and $\theta_2/\pi$ are irrational, or more generally if the group they generate is not finite, then $\langle R_{\hat{n}_1}(\theta_1), R_{\hat{n}_2}(\theta_2) \rangle$ is dense in $SU(2)$.

**Step 4: Verify density condition**

Consider the commutator:
$$[T, HTH] = T(HTH)T^\dagger(HTH)^\dagger$$

This yields a rotation by an angle that is an irrational multiple of $\pi$. Specifically:

$$\boxed{[R_z(\theta), R_x(\theta)] = R_{\hat{n}}(\phi)}$$

where $\hat{n}$ depends on $\theta$, and for $\theta = \pi/4$:

$$\cos(\phi/2) = \cos^2(\theta/2) + \sin^2(\theta/2)\cos(\theta) = \cos^4(\pi/8) + \sin^4(\pi/8)$$

This angle $\phi/\pi$ is irrational, ensuring the generated group is infinite and dense.

**Step 5: Extension to multiple qubits**

For $n > 1$ qubits, we use:
- Single-qubit Clifford+T on each qubit generates dense single-qubit unitaries
- CNOT provides entangling capability
- Any $n$-qubit unitary can be decomposed into single-qubit gates and CNOTs

Therefore, $\{H, S, T, \text{CNOT}\}$ generates a dense subgroup of $SU(2^n)$.

$$\boxed{\overline{\langle H, S, T, \text{CNOT} \rangle} = SU(2^n)}$$

---

#### Part 5: Exact vs. Approximate Universality

**Exact Clifford+T Circuits:**

The set of unitaries exactly representable by Clifford+T circuits forms a discrete, countable set. The single-qubit case yields:

$$\mathcal{U}_{\text{exact}} = \left\{ \frac{1}{\sqrt{2}^k} \begin{pmatrix} a & b \\ -b^* & a^* \end{pmatrix} : a, b \in \mathbb{Z}[i, \omega], |a|^2 + |b|^2 = 2^k \right\}$$

where $\omega = e^{i\pi/4}$ and $\mathbb{Z}[i, \omega]$ is the ring of integers extended by $i$ and $\omega$.

**Approximation Requirement:**

For any target unitary $U \in SU(2)$ and error tolerance $\epsilon > 0$, there exists a Clifford+T circuit $V$ such that:

$$\|U - V\| < \epsilon$$

The **Solovay-Kitaev theorem** (tomorrow) quantifies how efficiently this approximation can be achieved.

---

#### Part 6: Connection to Magic State Injection

**The Problem:** T-gates cannot be implemented transversally in most codes (by the Eastin-Knill theorem).

**The Solution:** Magic state injection.

The **T-state** (or magic state) is:

$$|T\rangle = T|+\rangle = \frac{1}{\sqrt{2}}(|0\rangle + e^{i\pi/4}|1\rangle)$$

**Magic State Injection Protocol:**

To apply $T$ to a data qubit $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$:

```
Input:  |ψ⟩ ─────────●─────────────
                     │
Magic:  |T⟩ ────────⊕────M────S^m──
                          ↓
Output: Depends on measurement m ∈ {0,1}
```

If $m=0$: Output is $T|\psi\rangle$ (success)
If $m=1$: Output is $SX T|\psi\rangle = T^\dagger|\psi\rangle S^{-1}$ (apply correction $S$)

**Circuit Analysis:**

Initial state: $|\psi\rangle \otimes |T\rangle = (\alpha|0\rangle + \beta|1\rangle) \otimes \frac{1}{\sqrt{2}}(|0\rangle + e^{i\pi/4}|1\rangle)$

After CNOT:
$$\frac{1}{\sqrt{2}}[\alpha|0\rangle(|0\rangle + e^{i\pi/4}|1\rangle) + \beta|1\rangle(|1\rangle + e^{i\pi/4}|0\rangle)]$$

Rearranging:
$$\frac{1}{\sqrt{2}}[|0\rangle(\alpha|0\rangle + e^{i\pi/4}\beta|1\rangle) + |1\rangle(e^{i\pi/4}\alpha|0\rangle + \beta|1\rangle)]$$

This equals:
$$\frac{1}{\sqrt{2}}[|0\rangle T|\psi\rangle + |1\rangle XT^\dagger X|\psi\rangle]$$

The correction $S$ when $m=1$ yields $T|\psi\rangle$ (since $SXT^\dagger X = T$ up to global phase).

---

### Algorithm Design Implications

**Why Clifford+T Matters for Algorithms:**

1. **Fault-Tolerant Implementation:** Clifford gates are "free" (transversal), only T-gates need distillation
2. **Resource Metric:** T-count dominates computational cost
3. **Compilation Target:** All quantum algorithms must eventually be expressed in Clifford+T

**Design Principles:**

| Principle | Implementation |
|-----------|----------------|
| Minimize T-count | Use algebraic identities to reduce T gates |
| Maximize parallelism | Group independent T gates for parallel distillation |
| Exploit structure | Use problem symmetries to simplify circuits |
| Trade T for Clifford | Use ancillas to convert some T gates to Cliffords |

---

### Worked Examples

#### Example 1: Verify H and T Generate Dense Subgroup

**Problem:** Show that the sequence $\{(HT)^n\}_{n=1}^{\infty}$ does not repeat.

**Solution:**

The operator $HT$ is:
$$HT = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & e^{i\pi/4} \\ 1 & -e^{i\pi/4} \end{pmatrix}$$

Eigenvalues of $HT$:
$$\det(HT - \lambda I) = \lambda^2 - \text{tr}(HT)\lambda + \det(HT) = 0$$

$$\text{tr}(HT) = \frac{1}{\sqrt{2}}(1 - e^{i\pi/4})$$

The eigenvalues are $\lambda_{\pm} = e^{\pm i\phi}$ where:
$$\cos\phi = \frac{\text{Re}(\text{tr}(HT))}{2} = \frac{1}{2\sqrt{2}}(1 - \cos(\pi/4)) = \frac{1}{2\sqrt{2}}(1 - \frac{1}{\sqrt{2}})$$

Since $\phi/\pi$ is irrational (can be verified numerically: $\phi \approx 0.615\pi$), the sequence $(HT)^n$ never repeats, confirming the group is infinite and hence dense in $SU(2)$.

---

#### Example 2: Decompose a Rotation Using Clifford+T

**Problem:** Express $R_z(3\pi/4)$ using only Clifford+T gates.

**Solution:**

Note that $T = R_z(\pi/4)$ and $S = R_z(\pi/2) = T^2$.

$$R_z(3\pi/4) = R_z(\pi/2) \cdot R_z(\pi/4) = S \cdot T = T^3$$

Verification:
$$T^3 = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\cdot 3\pi/4} \end{pmatrix} = R_z(3\pi/4) \checkmark$$

For $R_z(-\pi/4) = T^\dagger = T^7$ (since $T^8 = I$).

---

#### Example 3: Count Clifford+T Circuits

**Problem:** How many distinct single-qubit unitaries can be exactly represented with at most $k$ T-gates (and arbitrary Clifford gates)?

**Solution:**

The single-qubit Clifford group has 24 elements. Each T-gate application moves between cosets of the Clifford group within $SU(2)$.

For $k=0$: 24 unitaries (just Clifford group)

For $k=1$: $24 + 24 \times 2 = 72$ unitaries
- The factor of 2 accounts for $T$ and $T^\dagger$ leading to different cosets
- But we must account for $T^2 = S \in \mathcal{C}_1$

More precisely, the number of distinct unitaries with exactly $t$ T-gates (counting $T^\dagger$ as $T^7$) in the minimal representation follows a recurrence based on the group structure.

For small $k$:
- $k=0$: 24 unitaries
- $k=1$: 72 unitaries
- $k=2$: 192 unitaries
- $k=3$: 480 unitaries

The count grows approximately as $24 \times 3^k$ for small $k$, eventually covering $SU(2)$ densely.

---

### Practice Problems

#### Level 1: Direct Application

**Problem 1.1:** Verify that $S = T^2$ by matrix multiplication.

**Problem 1.2:** Show that $HZH = X$ and $HSH^\dagger = S^\dagger$ (Clifford conjugation relations).

**Problem 1.3:** Compute the eigenvalues of the T-gate and identify its rotation axis.

---

#### Level 2: Intermediate

**Problem 2.1:** Prove that the single-qubit Clifford group has exactly 24 elements by:
(a) Showing it's isomorphic to the symmetry group of the octahedron
(b) Counting distinct mappings of the Pauli operators

**Problem 2.2:** Show that for any angle $\theta = m\pi/2^k$ (with $m$ odd and $k \geq 3$), the rotation $R_z(\theta)$ can be expressed exactly using Clifford gates and T-gates.

**Problem 2.3:** Prove that $HTH \cdot T \cdot HTH = R_y(\pi/4)$ up to global phase, providing another rotation axis.

---

#### Level 3: Challenging

**Problem 3.1:** **(Density Proof Details)**
Complete the density argument by showing that if $\theta/\pi$ is irrational and we have $R_{\hat{n}_1}(\theta)$ and $R_{\hat{n}_2}(\theta)$ for non-parallel $\hat{n}_1, \hat{n}_2$, then the generated group is dense in $SU(2)$.

Hint: Consider the sequence of nested commutators $[R_1, R_2], [[R_1, R_2], R_1], \ldots$

**Problem 3.2:** **(Ring Structure)**
The exactly representable single-qubit unitaries have entries in $\mathbb{Z}[\frac{1}{\sqrt{2}}, i, \omega]$ where $\omega = e^{i\pi/4}$. Show that this ring is closed under:
(a) Addition and multiplication
(b) Complex conjugation
(c) Division by $\sqrt{2}$

**Problem 3.3:** **(Eastin-Knill Avoidance)**
Explain why magic state injection circumvents the Eastin-Knill theorem, which states no code can have a universal transversal gate set. What is the resource cost?

---

### Computational Lab

```python
"""
Day 862 Computational Lab: Clifford+T Universality
Exploring gate generation and density in SU(2)
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from itertools import product

# Define basic gates
I = np.eye(2, dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)

H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
S = np.array([[1, 0], [0, 1j]], dtype=complex)
T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)
T_dag = np.conj(T).T

# CNOT for multi-qubit
CNOT = np.array([[1, 0, 0, 0],
                  [0, 1, 0, 0],
                  [0, 0, 0, 1],
                  [0, 0, 1, 0]], dtype=complex)

# Clifford group generators
clifford_generators = [H, S]

def generate_clifford_group(max_length=6):
    """Generate single-qubit Clifford group elements"""
    cliffords = {matrix_to_key(I)}
    queue = [I]

    while queue:
        current = queue.pop(0)
        for gen in clifford_generators:
            new_matrix = gen @ current
            key = matrix_to_key(new_matrix)
            if key not in cliffords:
                cliffords.add(key)
                queue.append(new_matrix)
                if len(cliffords) >= 24:
                    return cliffords
    return cliffords

def matrix_to_key(M, precision=6):
    """Convert matrix to hashable key"""
    # Normalize global phase
    phase = np.exp(-1j * np.angle(M[0, 0])) if np.abs(M[0, 0]) > 0.01 else 1
    M_normalized = M * phase
    return tuple(np.round(M_normalized.flatten(), precision).tolist())

def key_to_matrix(key):
    """Convert key back to matrix"""
    return np.array(key).reshape(2, 2)

# Generate Clifford group
print("Generating single-qubit Clifford group...")
clifford_keys = generate_clifford_group()
print(f"Number of Clifford elements: {len(clifford_keys)}")

def unitary_to_bloch_rotation(U):
    """
    Extract rotation axis and angle from SU(2) matrix.
    U = cos(θ/2)I - i sin(θ/2)(n_x X + n_y Y + n_z Z)
    """
    # Ensure U is in SU(2) (det = 1)
    det = np.linalg.det(U)
    U = U / np.sqrt(det)  # Normalize to SU(2)

    # Extract angle
    trace = np.trace(U)
    cos_half_theta = np.real(trace) / 2
    cos_half_theta = np.clip(cos_half_theta, -1, 1)
    theta = 2 * np.arccos(cos_half_theta)

    if np.abs(np.sin(theta/2)) < 1e-10:
        return 0, np.array([0, 0, 1])  # Identity or -Identity

    # Extract axis
    n_x = np.imag(U[0, 1] + U[1, 0]) / (2 * np.sin(theta/2))
    n_y = np.real(U[0, 1] - U[1, 0]) / (2 * np.sin(theta/2))
    n_z = np.imag(U[0, 0] - U[1, 1]) / (2 * np.sin(theta/2))

    axis = np.array([n_x, n_y, n_z])
    norm = np.linalg.norm(axis)
    if norm > 1e-10:
        axis = axis / norm

    return theta, axis

def generate_clifford_t_circuits(max_t_count=3):
    """Generate all Clifford+T circuits up to given T-count"""
    # Start with Clifford group (T-count = 0)
    circuits = {}  # key -> (matrix, T_count, description)

    for key in clifford_keys:
        M = key_to_matrix(key)
        circuits[matrix_to_key(M)] = (M, 0, "Clifford")

    # Add T gates iteratively
    gates_with_t = [T, T_dag]
    gate_names = ['T', 'T†']

    for t_count in range(1, max_t_count + 1):
        new_circuits = {}
        for key, (M, tc, desc) in circuits.items():
            if tc == t_count - 1:
                # Add T or T† followed by Cliffords
                for gate, name in zip(gates_with_t, gate_names):
                    new_M = gate @ M
                    # Multiply by all Cliffords
                    for cliff_key in clifford_keys:
                        C = key_to_matrix(cliff_key)
                        final_M = C @ new_M
                        final_key = matrix_to_key(final_M)
                        if final_key not in circuits and final_key not in new_circuits:
                            new_circuits[final_key] = (final_M, t_count, f"C·{name}·({desc})")
        circuits.update(new_circuits)
        print(f"T-count {t_count}: {len(circuits)} total distinct unitaries")

    return circuits

# Generate circuits with increasing T-count
print("\nGenerating Clifford+T circuits...")
circuits = generate_clifford_t_circuits(max_t_count=4)

# Visualize coverage on Bloch sphere (using rotation axis)
fig = plt.figure(figsize=(15, 5))

# Plot 1: Rotation axes for Clifford group
ax1 = fig.add_subplot(131, projection='3d')
clifford_points = []
for key in clifford_keys:
    M = key_to_matrix(key)
    theta, axis = unitary_to_bloch_rotation(M)
    if theta > 0.1:  # Skip identity-like
        clifford_points.append(axis * theta / np.pi)

if clifford_points:
    clifford_points = np.array(clifford_points)
    ax1.scatter(clifford_points[:, 0], clifford_points[:, 1], clifford_points[:, 2],
                c='blue', s=50, alpha=0.6)

# Draw unit sphere wireframe
u, v = np.mgrid[0:2*np.pi:20j, 0:np.pi:10j]
xs = np.cos(u)*np.sin(v)
ys = np.sin(u)*np.sin(v)
zs = np.cos(v)
ax1.plot_wireframe(xs, ys, zs, color='gray', alpha=0.1)

ax1.set_xlabel('X')
ax1.set_ylabel('Y')
ax1.set_zlabel('Z')
ax1.set_title('Clifford Group\n(24 elements)')
ax1.set_xlim([-1.5, 1.5])
ax1.set_ylim([-1.5, 1.5])
ax1.set_zlim([-1.5, 1.5])

# Plot 2: With T-count 1-2
ax2 = fig.add_subplot(132, projection='3d')
t_points = []
for key, (M, tc, desc) in circuits.items():
    if tc <= 2 and tc > 0:
        theta, axis = unitary_to_bloch_rotation(M)
        if theta > 0.1:
            t_points.append(axis * theta / np.pi)

if t_points:
    t_points = np.array(t_points)
    ax2.scatter(t_points[:, 0], t_points[:, 1], t_points[:, 2],
                c='red', s=20, alpha=0.3)

ax2.plot_wireframe(xs, ys, zs, color='gray', alpha=0.1)
ax2.set_xlabel('X')
ax2.set_ylabel('Y')
ax2.set_zlabel('Z')
ax2.set_title(f'Clifford + T (T-count ≤ 2)\n({sum(1 for k,v in circuits.items() if v[1]<=2)} elements)')
ax2.set_xlim([-1.5, 1.5])
ax2.set_ylim([-1.5, 1.5])
ax2.set_zlim([-1.5, 1.5])

# Plot 3: Higher T-count
ax3 = fig.add_subplot(133, projection='3d')
high_t_points = []
for key, (M, tc, desc) in circuits.items():
    if tc > 0:
        theta, axis = unitary_to_bloch_rotation(M)
        if theta > 0.1:
            high_t_points.append(axis * theta / np.pi)

if high_t_points:
    high_t_points = np.array(high_t_points)
    ax3.scatter(high_t_points[:, 0], high_t_points[:, 1], high_t_points[:, 2],
                c='green', s=10, alpha=0.2)

ax3.plot_wireframe(xs, ys, zs, color='gray', alpha=0.1)
ax3.set_xlabel('X')
ax3.set_ylabel('Y')
ax3.set_zlabel('Z')
ax3.set_title(f'Clifford + T (T-count ≤ 4)\n({len(circuits)} elements)')
ax3.set_xlim([-1.5, 1.5])
ax3.set_ylim([-1.5, 1.5])
ax3.set_zlim([-1.5, 1.5])

plt.tight_layout()
plt.savefig('clifford_t_coverage.png', dpi=150, bbox_inches='tight')
plt.show()

# Demonstrate non-repetition of (HT)^n sequence
print("\n" + "="*60)
print("Demonstrating density: sequence (HT)^n")
print("="*60)

HT = H @ T
sequence_traces = []
for n in range(1, 21):
    HTn = np.linalg.matrix_power(HT, n)
    trace = np.trace(HTn)
    sequence_traces.append(trace)
    # Extract rotation angle
    theta, axis = unitary_to_bloch_rotation(HTn)
    print(f"(HT)^{n:2d}: θ = {np.degrees(theta):8.3f}°, axis ≈ ({axis[0]:+.3f}, {axis[1]:+.3f}, {axis[2]:+.3f})")

# Verify commutator produces irrational rotation
print("\n" + "="*60)
print("Commutator [T, HTH] rotation angle")
print("="*60)

HTH = H @ T @ H
commutator = T @ HTH @ np.conj(T).T @ np.conj(HTH).T
theta_comm, axis_comm = unitary_to_bloch_rotation(commutator)
print(f"Commutator rotation angle: θ = {np.degrees(theta_comm):.6f}°")
print(f"θ/π = {theta_comm/np.pi:.10f}")
print(f"This is {'irrational' if abs(theta_comm/np.pi - round(theta_comm/np.pi * 100)/100) > 0.001 else 'rational'} (indicating infinite group)")

# Magic state injection verification
print("\n" + "="*60)
print("Magic State Injection Verification")
print("="*60)

# Create magic state |T⟩ = T|+⟩
plus = np.array([1, 1], dtype=complex) / np.sqrt(2)
T_state = T @ plus
print(f"|T⟩ = T|+⟩ = {T_state[0]:.4f}|0⟩ + {T_state[1]:.4f}|1⟩")

# Test injection on |ψ⟩ = α|0⟩ + β|1⟩
alpha, beta = 0.6, 0.8  # Example state
psi = np.array([alpha, beta], dtype=complex)
psi = psi / np.linalg.norm(psi)

# Direct T application
T_psi_direct = T @ psi
print(f"\nDirect T|ψ⟩ = {T_psi_direct[0]:.4f}|0⟩ + {T_psi_direct[1]:.4f}|1⟩")

# Injection circuit simulation
# |ψ⟩|T⟩ -> CNOT -> measure second qubit
initial = np.kron(psi, T_state)
CNOT_rev = np.array([[1, 0, 0, 0],
                      [0, 0, 0, 1],
                      [0, 0, 1, 0],
                      [0, 1, 0, 0]], dtype=complex)  # Control on first qubit
after_cnot = CNOT_rev @ initial

# Probability of measuring 0 or 1 on second qubit
prob_0 = np.abs(after_cnot[0])**2 + np.abs(after_cnot[2])**2
prob_1 = np.abs(after_cnot[1])**2 + np.abs(after_cnot[3])**2
print(f"\nMeasurement probabilities: P(0) = {prob_0:.4f}, P(1) = {prob_1:.4f}")

# State after measurement 0
state_m0 = np.array([after_cnot[0], after_cnot[2]]) / np.sqrt(prob_0)
print(f"After m=0: {state_m0[0]:.4f}|0⟩ + {state_m0[1]:.4f}|1⟩")

# State after measurement 1 (need S correction)
state_m1 = np.array([after_cnot[1], after_cnot[3]]) / np.sqrt(prob_1)
state_m1_corrected = S @ state_m1
print(f"After m=1 + S correction: {state_m1_corrected[0]:.4f}|0⟩ + {state_m1_corrected[1]:.4f}|1⟩")

# Verify both match T|ψ⟩
print(f"\nVerification (should match T|ψ⟩ up to global phase):")
print(f"Match m=0: {np.allclose(state_m0/state_m0[0]*T_psi_direct[0], T_psi_direct)}")
print(f"Match m=1: {np.allclose(state_m1_corrected/state_m1_corrected[0]*T_psi_direct[0], T_psi_direct)}")

print("\n" + "="*60)
print("Lab Complete: Clifford+T Universality Verified")
print("="*60)
```

---

### Summary

#### Key Formulas

| Concept | Formula |
|---------|---------|
| Clifford group | $\mathcal{C}_n = \{U : UPU^\dagger \in \mathcal{P}_n, \forall P \in \mathcal{P}_n\}$ |
| Single-qubit Clifford size | $\|\mathcal{C}_1\| = 24$ |
| T-gate | $T = \text{diag}(1, e^{i\pi/4})$ |
| T-gate order | $T^8 = I$ |
| Universality | $\overline{\langle H, S, T, \text{CNOT} \rangle} = SU(2^n)$ |
| Magic state | $\|T\rangle = \frac{1}{\sqrt{2}}(\|0\rangle + e^{i\pi/4}\|1\rangle)$ |

#### Main Takeaways

1. **Clifford gates alone are insufficient** for quantum computation (Gottesman-Knill)
2. **Adding T-gate achieves universality** through density in SU(2)
3. **Density proof relies on** rotations around non-parallel axes with irrational angle ratios
4. **Magic state injection** enables fault-tolerant T-gate implementation
5. **T-count is the critical resource** for fault-tolerant quantum computing

---

### Daily Checklist

- [ ] Can define Clifford group and its generators
- [ ] Understand Gottesman-Knill theorem and its implications
- [ ] Can reproduce the density argument for Clifford+T universality
- [ ] Understand magic state injection protocol
- [ ] Completed computational lab exploring gate coverage
- [ ] Worked through at least 2 practice problems per level

---

### Preview: Day 863

Tomorrow we study the **Solovay-Kitaev Theorem**, which answers a crucial question: *how efficiently* can we approximate arbitrary unitaries with Clifford+T? We will prove the remarkable bound of $O(\log^c(1/\epsilon))$ gates to achieve $\epsilon$-approximation, with $c \approx 3.97$. This theorem is the foundation of all practical gate synthesis algorithms.

---

*Day 862 establishes that Clifford+T is universal---tomorrow we learn how efficiently we can approximate any unitary.*

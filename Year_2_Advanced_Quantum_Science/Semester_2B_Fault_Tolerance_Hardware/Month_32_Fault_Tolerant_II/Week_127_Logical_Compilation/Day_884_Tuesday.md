# Day 884: Clifford+T Decomposition

## Overview

**Day:** 884 of 1008
**Week:** 127 (Logical Gate Compilation)
**Month:** 32 (Fault-Tolerant Quantum Computing II)
**Topic:** Decomposing Arbitrary Unitaries into Clifford+T Gate Sequences

---

## Schedule

| Block | Time | Duration | Focus |
|-------|------|----------|-------|
| Morning | 9:00 AM - 12:30 PM | 3.5 hrs | Clifford group and T-gate theory |
| Afternoon | 2:00 PM - 5:30 PM | 3.5 hrs | Synthesis algorithms and optimization |
| Evening | 7:00 PM - 9:00 PM | 2 hrs | Computational lab |

---

## Learning Objectives

By the end of today, you should be able to:

1. **Characterize** the Clifford group and its representation
2. **Explain** why T gates provide universality when added to Cliffords
3. **Apply** the Solovay-Kitaev algorithm for gate approximation
4. **Implement** the Ross-Selinger gridsynth algorithm
5. **Minimize** T-count using algebraic optimization techniques
6. **Analyze** trade-offs between synthesis precision and gate count

---

## The Clifford Group

### Definition

The **Clifford group** $\mathcal{C}_n$ on $n$ qubits is the normalizer of the Pauli group:

$$\boxed{\mathcal{C}_n = \{U : U P U^{\dagger} \in \mathcal{P}_n \text{ for all } P \in \mathcal{P}_n\}}$$

where $\mathcal{P}_n = \{\pm 1, \pm i\} \times \{I, X, Y, Z\}^{\otimes n}$ is the $n$-qubit Pauli group.

### Generators

The Clifford group is generated by:

$$\mathcal{C}_n = \langle H, S, \text{CNOT} \rangle$$

**Hadamard:**
$$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$

Action on Paulis: $HXH^{\dagger} = Z$, $HZH^{\dagger} = X$

**Phase gate:**
$$S = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}$$

Action on Paulis: $SXS^{\dagger} = Y$, $SZS^{\dagger} = Z$

**CNOT:**
$$\text{CNOT} = \begin{pmatrix} 1&0&0&0 \\ 0&1&0&0 \\ 0&0&0&1 \\ 0&0&1&0 \end{pmatrix}$$

Action: Maps $X \otimes I \to X \otimes X$, $Z \otimes I \to Z \otimes I$, etc.

### Size of the Clifford Group

For $n$ qubits:

$$|\mathcal{C}_n| = 2^{n^2 + 2n} \prod_{k=1}^{n}(4^k - 1)$$

**Single qubit:** $|\mathcal{C}_1| = 24$ (isomorphic to $S_4$, the symmetric group)

**Two qubits:** $|\mathcal{C}_2| = 11,520$

### Efficient Simulation

**Gottesman-Knill Theorem:** Clifford circuits can be classically simulated in polynomial time.

**Implications:**
- Clifford gates alone are not universal
- Need a non-Clifford gate (like T) for quantum advantage
- Clifford gates are "cheap" in fault-tolerant computation

---

## The T Gate and Universality

### T Gate Definition

$$T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix} = e^{-i\pi/8}R_z(\pi/4)$$

**Key property:** T is NOT in the Clifford group:
$$TXT^{\dagger} = \frac{1}{\sqrt{2}}(X + Y) \notin \mathcal{P}_1$$

### Why T Provides Universality

**Theorem:** $\{H, T\}$ generates a dense subgroup of $SU(2)$.

**Proof:**

Consider the rotations generated:
$$H = e^{i\pi/4} R_{\hat{x}+\hat{z}}(\pi)$$
$$T = e^{-i\pi/8} R_z(\pi/4)$$

The key is the combination:
$$HTH = e^{i\phi} R_x(\pi/4)$$

for some phase $\phi$.

Now we have:
- $T \sim R_z(\pi/4)$: rotation by $\pi/4$ about z-axis
- $HTH \sim R_x(\pi/4)$: rotation by $\pi/4$ about x-axis

**Lemma:** If $\theta/\pi$ is irrational, rotations around two non-parallel axes by angle $\theta$ generate a dense subgroup of $SU(2)$.

Since $\pi/4 / \pi = 1/4$ is rational, we need to show density differently. The key observation: by composing rotations, we can get arbitrarily small rotations, hence density. $\square$

### The Third Level of the Clifford Hierarchy

The **Clifford hierarchy** is defined inductively:

$$\mathcal{C}^{(1)} = \mathcal{P}_n \text{ (Pauli group)}$$
$$\mathcal{C}^{(k+1)} = \{U : UPU^{\dagger} \in \mathcal{C}^{(k)} \text{ for all } P \in \mathcal{P}_n\}$$

**Key facts:**
- $\mathcal{C}^{(2)} = \mathcal{C}_n$ (Clifford group)
- $T \in \mathcal{C}^{(3)}$ but $T \notin \mathcal{C}^{(2)}$
- Gates in $\mathcal{C}^{(3)}$ can be implemented using one T gate and Cliffords

---

## The Solovay-Kitaev Algorithm

### Statement

**Theorem (Solovay-Kitaev):** Let $\mathcal{G}$ be a finite gate set generating a dense subgroup of $SU(2)$. For any $U \in SU(2)$ and $\epsilon > 0$, there exists a sequence of $O(\log^c(1/\epsilon))$ gates from $\mathcal{G}$ that $\epsilon$-approximates $U$, where $c \approx 3.97$.

### Algorithm Overview

**Input:** Target unitary $U$, precision $\epsilon$
**Output:** Sequence of gates $g_1, \ldots, g_m$ such that $\|U - g_m \cdots g_1\| < \epsilon$

**Key Idea:** Recursively refine approximations using group commutators.

**Group Commutator:** For $V, W \in SU(2)$:
$$[V, W] = VWV^{\dagger}W^{\dagger}$$

If $V \approx I + \delta_V$ and $W \approx I + \delta_W$ for small $\delta$, then:
$$[V, W] \approx I + [\delta_V, \delta_W] + O(\delta^3)$$

The commutator reduces the "error" while squaring the approximation quality.

### Algorithm Steps

```
SOLOVAY_KITAEV(U, epsilon, depth):
    if depth == 0:
        return BASIC_APPROXIMATION(U, epsilon_0)

    U_n-1 = SOLOVAY_KITAEV(U, sqrt(epsilon), depth-1)
    Delta = U @ U_n-1.dag()

    # Decompose Delta as commutator [V, W]
    V, W = COMMUTATOR_DECOMPOSE(Delta)

    V_tilde = SOLOVAY_KITAEV(V, sqrt(epsilon), depth-1)
    W_tilde = SOLOVAY_KITAEV(W, sqrt(epsilon), depth-1)

    return V_tilde @ W_tilde @ V_tilde.dag() @ W_tilde.dag() @ U_n-1
```

### Complexity Analysis

At depth $d$:
- Approximation error: $\epsilon_d = \epsilon_0^{(3/2)^d}$
- Gate count: $T(d) = 5 T(d-1) + c$

Solving: $T(d) = O(5^d)$

To achieve precision $\epsilon$: $d = O(\log \log(1/\epsilon))$

Total gates: $O(5^{\log\log(1/\epsilon)}) = O(\log^c(1/\epsilon))$ where $c = \log_2 5 \approx 2.32$.

With optimizations, $c \approx 3.97$.

---

## Optimal Synthesis: Ross-Selinger Algorithm

### Motivation

Solovay-Kitaev gives $O(\log^c(1/\epsilon))$ with $c \approx 4$.

**Question:** What is the optimal T-count?

**Answer:** For a single rotation $R_z(\theta)$, the optimal T-count is:

$$\boxed{n_T^* = 3\log_2(1/\epsilon) + O(\log\log(1/\epsilon))}$$

This is achieved by the **Ross-Selinger gridsynth algorithm**.

### Key Insight: Exact Synthesis

Some rotations can be synthesized **exactly** using finitely many T gates.

**Theorem:** A single-qubit unitary $U$ can be exactly synthesized over Clifford+T if and only if its matrix entries lie in the ring:

$$\mathbb{Z}\left[\frac{1}{\sqrt{2}}, i\right] = \left\{\frac{a + bi + c\sqrt{2} + di\sqrt{2}}{2^k} : a,b,c,d \in \mathbb{Z}, k \in \mathbb{N}\right\}$$

### The Ring $\mathbb{Z}[\omega]$

Let $\omega = e^{i\pi/4} = \frac{1+i}{\sqrt{2}}$.

The ring of **cyclotomic integers** $\mathbb{Z}[\omega]$ contains exactly those complex numbers that appear in Clifford+T unitaries.

**Key properties:**
- $\omega^8 = 1$
- $\sqrt{2} = \omega + \omega^7 = \omega - \omega^{-1}$
- Every element: $z = a_0 + a_1\omega + a_2\omega^2 + \cdots + a_7\omega^7$

### Gridsynth Algorithm

**Goal:** Find $u \in \mathbb{Z}[\omega]$ with $|u| = 1$ such that $u \approx e^{i\theta}$.

**Approach:** Search on a 2D grid in $\mathbb{Z}[\omega]$ for points near the unit circle.

```
GRIDSYNTH(theta, epsilon):
    # Find precision level
    k = ceil(log2(1/epsilon) / 2)

    # Search grid at level k
    for candidate in GRID_SEARCH(k):
        u = candidate / sqrt(2)^k
        if |u| close to 1:
            if arg(u) close to theta:
                return SYNTHESIZE_EXACT(u)

    return failure
```

### T-Count from Gridsynth

The T-count is determined by the "denominator exponent" $k$:

$$n_T = 3k + O(1) = 3\log_2(1/\epsilon) + O(1)$$

**Comparison:**
| Method | T-count |
|--------|---------|
| Solovay-Kitaev | $O(\log^4(1/\epsilon))$ |
| Ross-Selinger | $3\log_2(1/\epsilon) + O(1)$ |
| Lower bound | $\log_2(1/\epsilon)$ |

---

## T-Count Optimization

### Why T-Count Matters

In fault-tolerant computing:
- **Clifford gates:** Transversal or via Pauli frame tracking → ~0 cost
- **T gates:** Require magic state distillation → dominant cost

**Example costs (surface code, d=17):**
| Gate | Time | Qubits |
|------|------|--------|
| Clifford | ~0 | 0 extra |
| T | ~1000 cycles | ~1000 |

### T-Count Reduction Techniques

#### 1. Phase Polynomial Optimization

Represent the circuit as a **phase polynomial**:

$$|\mathbf{x}\rangle \mapsto e^{i f(\mathbf{x})} |\mathbf{x}\rangle$$

where $f(\mathbf{x}) = \sum_S \theta_S \prod_{i \in S} x_i$ is a polynomial over $\mathbb{Z}_8$.

**T-Par Algorithm:** Minimizes T-count by finding equivalent phase polynomials with fewer terms.

#### 2. TODD Algorithm

**Template matching:** Replace patterns in the circuit with T-count-optimized equivalents.

**Example Templates:**
```
T-T†-T = T (modulo Cliffords)
CCZ = 7 T gates (standard) → 4 T gates (with ancilla)
```

#### 3. Ancilla-Assisted Synthesis

Trade ancilla qubits for reduced T-count:

**Toffoli gate:**
- No ancilla: 7 T gates
- With 1 ancilla: 4 T gates (Gidney)
- With unbounded ancillas: ~4 T gates amortized

#### 4. Algebraic Optimization

Exploit algebraic identities:

$$T \cdot T = S$$
$$T \cdot S = T^3 = T^{\dagger}S^{\dagger}$$
$$T^{\dagger} \cdot T^{\dagger} = S^{\dagger}$$

**T-count invariants:** Some circuit transformations preserve T-count.

### T-Count for Common Operations

| Operation | T-count (optimal) | Notes |
|-----------|-------------------|-------|
| T gate | 1 | Definition |
| $R_z(\pi/4)$ | 1 | = T |
| $R_z(\pi/2^k)$ | ~$3k$ | Via synthesis |
| CNOT | 0 | Clifford |
| Toffoli | 4 | With ancilla |
| $n$-controlled NOT | $8n - 12$ | Asymptotic |
| QFT ($n$ qubits) | $O(n^2 \log n)$ | Approximate |

---

## Worked Examples

### Example 1: Exact Synthesis of $R_z(\pi/8)$

**Problem:** Synthesize $R_z(\pi/8) = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/8} \end{pmatrix}$ exactly.

**Solution:**

Note that $e^{i\pi/8} = \omega^{1/2}$ where $\omega = e^{i\pi/4}$.

This is NOT in $\mathbb{Z}[\omega]$, so exact synthesis is impossible!

However, we can write:
$$R_z(\pi/8) = T^{1/2}$$

But $T^{1/2}$ is not a Clifford+T gate.

**Approximation needed:** Use gridsynth to approximate $e^{i\pi/8}$.

For $\epsilon = 10^{-10}$:
$$n_T \approx 3\log_2(10^{10}) \approx 3 \times 33 = 99 \text{ T gates}$$

### Example 2: T-count of Controlled-S

**Problem:** What is the T-count of controlled-S?

**Solution:**

Controlled-S can be decomposed as:
$$CS = (I \otimes T)(CNOT)(I \otimes T^{\dagger})(CNOT)(I \otimes T)$$

Wait, let's verify:
- We want $CS|00\rangle = |00\rangle$, $CS|01\rangle = |01\rangle$, $CS|10\rangle = |10\rangle$, $CS|11\rangle = i|11\rangle$

Alternative decomposition:
$$CS = \text{controlled-}T \cdot \text{controlled-}T$$

Each controlled-T has T-count... let's use the direct approach.

**Direct decomposition:**
$$CS = (T \otimes I) \cdot \text{CNOT} \cdot (T^{\dagger} \otimes I) \cdot \text{CNOT}$$

This gives T-count = 2.

Actually, controlled-S can be done with:

$$CS = (I \otimes T^{\dagger}) \cdot \text{CNOT} \cdot (I \otimes T) \cdot \text{CNOT} \cdot (T \otimes I)$$

**T-count = 3**

But there's a better decomposition using $S = T^2$:
$$CS = \text{controlled-}(T^2) = (CT)^2$$

If $CT$ has T-count 1 (it doesn't quite), then $CS$ would have T-count 2.

**Correct answer:** T-count(CS) = 2 with optimal decomposition.

### Example 3: T-par Optimization

**Problem:** Optimize the T-count of the following circuit:

```
q0: ──T──●──T†──
         │
q1: ──T──X──T───
```

**Solution:**

Express as phase polynomial. The circuit implements:

$$|x_0, x_1\rangle \mapsto e^{i\pi/4(x_0 - x_0(x_0 \oplus x_1) + x_1 + (x_0 \oplus x_1))} |x_0, x_1 \oplus x_0\rangle$$

Simplifying the phase:
$$\phi(x_0, x_1) = \frac{\pi}{4}(x_0 - x_0 x_0 - x_0 x_1 + x_0^2 + x_1 + x_0 + x_1 - x_0 x_1)$$

Wait, let me be more careful. Using $x_i^2 = x_i$ (binary):

Before CNOT: $T_0 T_1$ gives phase $\frac{\pi}{4}(x_0 + x_1)$
After CNOT with $x'_1 = x_0 \oplus x_1$: $T^{\dagger}_0 T_1$ gives phase $\frac{\pi}{4}(-x_0 + x_0 \oplus x_1)$

Total phase: $\frac{\pi}{4}(x_0 + x_1 - x_0 + x_0 \oplus x_1) = \frac{\pi}{4}(x_1 + x_0 \oplus x_1)$

Using $x_0 \oplus x_1 = x_0 + x_1 - 2x_0x_1$:
$$\phi = \frac{\pi}{4}(x_1 + x_0 + x_1 - 2x_0x_1) = \frac{\pi}{4}(x_0 + 2x_1 - 2x_0x_1)$$

This can be rewritten... The key point: T-par looks for equivalent simpler representations.

**Optimized:** If the phase polynomial can be rewritten with fewer terms, T-count reduces.

---

## Practice Problems

### Level 1: Direct Application

**P1.1** Verify that $S = T^2$ by matrix multiplication.

**P1.2** Show that $H$ conjugates $Z$ to $X$: compute $HZH^{\dagger}$.

**P1.3** What is the T-count for implementing $Z$? For $Y$?

### Level 2: Intermediate

**P2.1** Prove that $T \notin \mathcal{C}_1$ by showing $TXT^{\dagger} \notin \mathcal{P}_1$.

**P2.2** Using the Ross-Selinger bound $n_T = 3\log_2(1/\epsilon)$, calculate the T-count needed to approximate:
a) $R_z(\pi/16)$ to precision $10^{-5}$
b) $R_z(\sqrt{2})$ to precision $10^{-10}$

**P2.3** The 8-qubit QFT requires rotations $R_z(\pi/2^k)$ for $k = 1, \ldots, 7$. Estimate the total T-count assuming each rotation is synthesized to precision $10^{-8}$.

### Level 3: Challenging

**P3.1** Prove that any $2 \times 2$ unitary with entries in $\mathbb{Z}[1/\sqrt{2}, i]$ can be exactly synthesized over Clifford+T.

*Hint:* Use the fact that the Clifford+T group is exactly the unitary matrices over this ring.

**P3.2** Design an algorithm to determine the minimum T-count for a given phase polynomial over $n$ variables.

**P3.3** Prove the lower bound: Any synthesis of $R_z(\theta)$ for generic $\theta$ requires at least $\Omega(\log(1/\epsilon))$ T gates.

*Hint:* Consider the density of exactly representable angles.

---

## Computational Lab

```python
"""
Day 884: Clifford+T Decomposition
=================================

Implementing gate synthesis and T-count optimization.
"""

import numpy as np
from typing import List, Tuple, Optional, Dict
from dataclasses import dataclass
from fractions import Fraction
import cmath


# =============================================================================
# Fundamental Gates
# =============================================================================

# Pauli matrices
I = np.array([[1, 0], [0, 1]], dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)

# Clifford generators
H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
S = np.array([[1, 0], [0, 1j]], dtype=complex)
Sdg = np.array([[1, 0], [0, -1j]], dtype=complex)

# T gate
T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)
Tdg = np.array([[1, 0], [0, np.exp(-1j * np.pi / 4)]], dtype=complex)

# CNOT
CNOT = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
], dtype=complex)


def Rz(theta: float) -> np.ndarray:
    """Z-rotation by angle theta."""
    return np.array([
        [np.exp(-1j * theta / 2), 0],
        [0, np.exp(1j * theta / 2)]
    ], dtype=complex)


def Rx(theta: float) -> np.ndarray:
    """X-rotation by angle theta."""
    return np.array([
        [np.cos(theta/2), -1j * np.sin(theta/2)],
        [-1j * np.sin(theta/2), np.cos(theta/2)]
    ], dtype=complex)


# =============================================================================
# Clifford Group Operations
# =============================================================================

class CliffordTableau:
    """
    Represents a Clifford operation via its action on Paulis.

    For single qubit: tracks where X and Z map to.
    """

    def __init__(self):
        # Default: identity
        # x_dest: (pauli, phase) where X maps to phase * pauli
        # z_dest: (pauli, phase) where Z maps to
        self.x_dest = ('X', 1)
        self.z_dest = ('Z', 1)

    def apply_h(self):
        """Apply Hadamard: X <-> Z."""
        self.x_dest, self.z_dest = self.z_dest, self.x_dest

    def apply_s(self):
        """Apply S: X -> Y, Z -> Z."""
        pauli, phase = self.x_dest
        if pauli == 'X':
            self.x_dest = ('Y', phase)
        elif pauli == 'Y':
            self.x_dest = ('X', -phase)
        elif pauli == 'Z':
            self.x_dest = ('Z', phase)  # Z unchanged

    def to_matrix(self) -> np.ndarray:
        """Convert tableau back to matrix (up to global phase)."""
        # This is a simplified version
        paulis = {'I': I, 'X': X, 'Y': Y, 'Z': Z}
        # Reconstruct from action on X and Z
        # For full implementation, need to solve for the unitary
        pass

    def __repr__(self):
        return f"Clifford(X->{self.x_dest}, Z->{self.z_dest})"


def is_clifford(U: np.ndarray, tol: float = 1e-10) -> bool:
    """Check if single-qubit unitary is Clifford."""
    paulis = [X, Y, Z]
    for P in paulis:
        conjugated = U @ P @ U.conj().T
        # Check if result is ±1 or ±i times a Pauli
        is_pauli = False
        for Q in paulis:
            for phase in [1, -1, 1j, -1j]:
                if np.allclose(conjugated, phase * Q, atol=tol):
                    is_pauli = True
                    break
            if is_pauli:
                break
        if not is_pauli:
            return False
    return True


# =============================================================================
# Gate Synthesis
# =============================================================================

@dataclass
class SynthesisResult:
    """Result of gate synthesis."""
    gates: List[str]  # Sequence of gate names
    t_count: int
    error: float  # Approximation error
    matrix: np.ndarray  # Synthesized matrix


def basic_decompose_rz(theta: float) -> Tuple[List[str], int]:
    """
    Basic decomposition of Rz(theta) using known identities.

    Returns (gate_list, t_count).
    """
    # Normalize theta to [0, 2*pi)
    theta = theta % (2 * np.pi)

    # Check for exact cases
    cases = {
        0: ([], 0),
        np.pi/4: (['T'], 1),
        np.pi/2: (['S'], 0),
        3*np.pi/4: (['T', 'S'], 1),
        np.pi: (['Z'], 0),
        5*np.pi/4: (['S', 'S', 'T'], 1),
        3*np.pi/2: (['S', 'S', 'S'], 0),
        7*np.pi/4: (['Tdg'], 1),
    }

    for angle, result in cases.items():
        if np.isclose(theta, angle, atol=1e-10):
            return result

    # Not an exact case - needs synthesis
    return None


def solovay_kitaev_depth_0(U: np.ndarray, epsilon: float = 0.1) -> List[str]:
    """
    Basic approximation: find closest Clifford+T sequence of fixed length.

    This is a simplified version - real SK uses precomputed lookup.
    """
    # For demonstration, just try short sequences
    best_gates = []
    best_error = float('inf')

    gate_set = {
        'I': I, 'H': H, 'S': S, 'Sdg': Sdg, 'T': T, 'Tdg': Tdg
    }

    # Try sequences of length 1, 2, 3
    for length in range(1, 4):
        for gates in _generate_sequences(list(gate_set.keys()), length):
            matrix = I.copy()
            for g in gates:
                matrix = gate_set[g] @ matrix

            # Compute error (operator norm)
            error = np.linalg.norm(U - matrix, ord=2)
            if error < best_error:
                best_error = error
                best_gates = list(gates)

                if error < epsilon:
                    return best_gates

    return best_gates


def _generate_sequences(elements: List[str], length: int):
    """Generate all sequences of given length."""
    if length == 0:
        yield []
        return
    if length == 1:
        for e in elements:
            yield [e]
        return
    for e in elements:
        for rest in _generate_sequences(elements, length - 1):
            yield [e] + rest


def gridsynth_estimate_t_count(theta: float, epsilon: float) -> int:
    """
    Estimate T-count for synthesizing Rz(theta) to precision epsilon.

    Uses Ross-Selinger bound.
    """
    if epsilon <= 0:
        return float('inf')

    # Ross-Selinger bound: 3 * log2(1/epsilon) + O(1)
    base_count = 3 * np.log2(1/epsilon)

    # Add small constant for O(1) term
    return int(np.ceil(base_count)) + 4


class GridSynthesizer:
    """
    Simplified gridsynth-style synthesizer.

    Real implementation would use number-theoretic algorithms.
    """

    def __init__(self, epsilon: float = 1e-5):
        self.epsilon = epsilon

    def synthesize(self, theta: float) -> SynthesisResult:
        """
        Synthesize Rz(theta) to precision self.epsilon.
        """
        # Check for exact synthesis first
        exact = basic_decompose_rz(theta)
        if exact is not None:
            gates, t_count = exact
            return SynthesisResult(
                gates=gates,
                t_count=t_count,
                error=0.0,
                matrix=self._gates_to_matrix(gates)
            )

        # Estimate T-count
        t_count = gridsynth_estimate_t_count(theta, self.epsilon)

        # For demonstration, create approximate sequence
        # Real gridsynth would find exact sequence over Z[1/sqrt(2), i]
        gates = self._heuristic_synthesis(theta, t_count)

        matrix = self._gates_to_matrix(gates)
        target = Rz(theta)
        error = np.linalg.norm(target - matrix, ord=2)

        return SynthesisResult(
            gates=gates,
            t_count=sum(1 for g in gates if g in ['T', 'Tdg']),
            error=error,
            matrix=matrix
        )

    def _heuristic_synthesis(self, theta: float, t_budget: int) -> List[str]:
        """Heuristic synthesis - placeholder for real algorithm."""
        # This is NOT the real gridsynth algorithm
        # Just demonstrates the interface
        gates = []
        current_angle = 0

        # Build up angle using T gates
        while t_budget > 0 and abs(theta - current_angle) > self.epsilon:
            diff = theta - current_angle
            if diff > np.pi:
                diff -= 2 * np.pi
            elif diff < -np.pi:
                diff += 2 * np.pi

            if diff > 0:
                if diff >= np.pi/4:
                    gates.append('T')
                    current_angle += np.pi/4
                    t_budget -= 1
                else:
                    # Need smaller rotation - use HT sequences
                    gates.extend(['H', 'T', 'H'])
                    current_angle += np.pi/4  # Simplified
                    t_budget -= 1
            else:
                gates.append('Tdg')
                current_angle -= np.pi/4
                t_budget -= 1

        return gates

    def _gates_to_matrix(self, gates: List[str]) -> np.ndarray:
        """Convert gate sequence to matrix."""
        gate_matrices = {
            'I': I, 'H': H, 'S': S, 'Sdg': Sdg,
            'T': T, 'Tdg': Tdg, 'X': X, 'Y': Y, 'Z': Z
        }

        result = I.copy()
        for g in gates:
            result = gate_matrices.get(g, I) @ result

        return result


# =============================================================================
# T-Count Optimization
# =============================================================================

def t_count_circuit(gates: List[str]) -> int:
    """Count T gates in circuit."""
    return sum(1 for g in gates if g in ['T', 'Tdg'])


def simplify_circuit(gates: List[str]) -> List[str]:
    """
    Apply simple simplification rules.

    Rules:
    - T T = S
    - Tdg Tdg = Sdg
    - T Tdg = I
    - S S = Z
    - H H = I
    """
    if not gates:
        return gates

    result = []
    i = 0
    while i < len(gates):
        if i + 1 < len(gates):
            pair = (gates[i], gates[i+1])

            # Cancellation rules
            if pair == ('T', 'Tdg') or pair == ('Tdg', 'T'):
                i += 2
                continue
            if pair == ('H', 'H'):
                i += 2
                continue
            if pair == ('S', 'Sdg') or pair == ('Sdg', 'S'):
                i += 2
                continue

            # Combination rules
            if pair == ('T', 'T'):
                result.append('S')
                i += 2
                continue
            if pair == ('Tdg', 'Tdg'):
                result.append('Sdg')
                i += 2
                continue
            if pair == ('S', 'S'):
                result.append('Z')
                i += 2
                continue

        result.append(gates[i])
        i += 1

    # Recurse until no more simplifications
    if len(result) < len(gates):
        return simplify_circuit(result)
    return result


# =============================================================================
# Phase Polynomial Representation
# =============================================================================

class PhasePolynomial:
    """
    Represents diagonal phase gate as polynomial over binary variables.

    |x1, x2, ..., xn> -> exp(i * f(x1, ..., xn)) |x1, ..., xn>

    where f is a polynomial over Z_8 (representing multiples of pi/4).
    """

    def __init__(self, num_qubits: int):
        self.num_qubits = num_qubits
        # terms: dict mapping frozenset of qubit indices to coefficient (mod 8)
        self.terms: Dict[frozenset, int] = {}

    def add_term(self, qubits: Tuple[int, ...], coeff: int):
        """Add a phase term. Coefficient is in units of pi/4."""
        key = frozenset(qubits)
        self.terms[key] = (self.terms.get(key, 0) + coeff) % 8

        # Remove zero terms
        if self.terms[key] == 0:
            del self.terms[key]

    def add_t(self, qubit: int):
        """Add T gate on qubit."""
        self.add_term((qubit,), 1)  # T = exp(i*pi/4 * x)

    def add_ccz(self, q1: int, q2: int, q3: int):
        """Add CCZ gate."""
        self.add_term((q1, q2, q3), 4)  # CCZ = exp(i*pi * x1*x2*x3)

    def t_count(self) -> int:
        """
        Compute T-count for this phase polynomial.

        T-count is minimized by counting non-quadratic terms appropriately.
        """
        count = 0
        for qubits, coeff in self.terms.items():
            degree = len(qubits)
            if degree == 1:
                # Linear terms: each odd coefficient costs 1 T
                if coeff % 2 == 1:
                    count += 1
            elif degree >= 2:
                # Higher degree terms cost more
                # Simplified: each term costs its degree in T gates
                count += degree * (coeff % 2)

        return count

    def __repr__(self):
        terms = []
        for qubits, coeff in self.terms.items():
            if coeff != 0:
                vars_str = "*".join(f"x{q}" for q in sorted(qubits))
                terms.append(f"{coeff}*{vars_str}")
        return f"PhasePolynomial({' + '.join(terms)})"


# =============================================================================
# Demo
# =============================================================================

def demo_synthesis():
    """Demonstrate gate synthesis capabilities."""

    print("=" * 70)
    print("Day 884: Clifford+T Decomposition - Demonstration")
    print("=" * 70)

    # Example 1: Check Clifford property
    print("\n1. Clifford Gate Detection")
    print("-" * 40)

    for name, gate in [('H', H), ('S', S), ('T', T), ('HS', H @ S)]:
        result = is_clifford(gate)
        print(f"  {name}: {'Clifford' if result else 'NOT Clifford'}")

    # Example 2: Exact synthesis cases
    print("\n2. Exact Synthesis Cases")
    print("-" * 40)

    for theta in [0, np.pi/4, np.pi/2, np.pi, 3*np.pi/2]:
        result = basic_decompose_rz(theta)
        if result:
            gates, t_count = result
            print(f"  Rz({theta/np.pi:.3f}π): {gates}, T-count = {t_count}")
        else:
            print(f"  Rz({theta/np.pi:.3f}π): requires synthesis")

    # Example 3: T-count estimation
    print("\n3. T-count Estimation (Ross-Selinger)")
    print("-" * 40)

    for epsilon in [1e-3, 1e-5, 1e-8, 1e-10, 1e-15]:
        t_count = gridsynth_estimate_t_count(0.123, epsilon)
        print(f"  ε = {epsilon:.0e}: T-count ≈ {t_count}")

    # Example 4: Circuit simplification
    print("\n4. Circuit Simplification")
    print("-" * 40)

    circuits = [
        ['T', 'T'],
        ['T', 'Tdg'],
        ['H', 'H', 'T', 'T', 'T', 'Tdg'],
        ['T', 'H', 'T', 'H', 'T'],
    ]

    for circuit in circuits:
        simplified = simplify_circuit(circuit)
        original_t = t_count_circuit(circuit)
        new_t = t_count_circuit(simplified)
        print(f"  {circuit}")
        print(f"    -> {simplified}")
        print(f"    T-count: {original_t} -> {new_t}")

    # Example 5: GridSynth synthesis
    print("\n5. GridSynth Synthesis (Demonstration)")
    print("-" * 40)

    synth = GridSynthesizer(epsilon=1e-3)

    for theta in [np.pi/8, np.pi/3, np.sqrt(2)]:
        result = synth.synthesize(theta)
        print(f"  Rz({theta:.4f}):")
        print(f"    Gates: {result.gates[:10]}..." if len(result.gates) > 10
              else f"    Gates: {result.gates}")
        print(f"    T-count: {result.t_count}")
        print(f"    Error: {result.error:.2e}")

    # Example 6: Phase polynomial
    print("\n6. Phase Polynomial Representation")
    print("-" * 40)

    pp = PhasePolynomial(3)
    pp.add_t(0)
    pp.add_t(1)
    pp.add_ccz(0, 1, 2)
    print(f"  {pp}")
    print(f"  T-count estimate: {pp.t_count()}")


if __name__ == "__main__":
    demo_synthesis()
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| Clifford group | $\mathcal{C}_n = \{U : UPU^{\dagger} \in \mathcal{P}_n\}$ |
| Single-qubit Cliffords | $\|\mathcal{C}_1\| = 24$ |
| T gate | $T = \text{diag}(1, e^{i\pi/4})$ |
| Solovay-Kitaev | $n_{\text{gates}} = O(\log^{3.97}(1/\epsilon))$ |
| Ross-Selinger | $n_T = 3\log_2(1/\epsilon) + O(1)$ |
| Exact synthesis ring | $\mathbb{Z}[1/\sqrt{2}, i]$ |

### Main Takeaways

1. **Clifford gates** form a group that normalizes the Paulis and can be efficiently simulated
2. **T gate** breaks out of the Clifford group and provides universality
3. **Solovay-Kitaev** gives polylog gate count but suboptimal constants
4. **Ross-Selinger gridsynth** achieves near-optimal T-count of ~$3\log_2(1/\epsilon)$
5. **T-count optimization** is critical since T gates dominate fault-tolerant costs
6. **Phase polynomials** provide an algebraic framework for T-count analysis

---

## Daily Checklist

- [ ] I can define the Clifford group and its generators
- [ ] I understand why T gates are necessary for universality
- [ ] I can state the Solovay-Kitaev theorem
- [ ] I know the Ross-Selinger T-count bound
- [ ] I can estimate T-count for rotation synthesis
- [ ] I understand basic T-count optimization techniques

---

## Preview: Day 885

Tomorrow we explore **Repeat-Until-Success (RUS) circuits**:

- Probabilistic synthesis strategies
- Catalyst states and their preparation
- Expected runtime analysis for RUS
- Trade-offs between deterministic and probabilistic approaches
- Hybrid compilation strategies

RUS circuits offer an alternative to deterministic synthesis with potentially lower expected T-count.

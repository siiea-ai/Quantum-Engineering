# Day 932: Topological Quantum Computing Principles

## Schedule Overview (7 hours)

| Session | Duration | Focus |
|---------|----------|-------|
| Morning | 3 hours | Topological protection, anyons, and braiding fundamentals |
| Afternoon | 2 hours | Problem solving and mathematical derivations |
| Evening | 2 hours | Computational lab: Anyon braiding simulations |

## Learning Objectives

By the end of today, you will be able to:

1. **Explain topological protection** and why it provides intrinsic fault tolerance
2. **Distinguish between bosons, fermions, and anyons** using exchange statistics
3. **Define Abelian and non-Abelian anyons** and their braiding properties
4. **Derive fusion rules** for simple anyon systems
5. **Calculate topological degeneracy** from the number of anyons
6. **Articulate the computational model** based on braiding and measurement

---

## Core Content

### 1. The Concept of Topological Protection

Conventional quantum computing faces a fundamental challenge: qubits are extremely sensitive to local perturbations. Any interaction with the environment can cause decoherence. Topological quantum computing offers a radically different approach: **encode quantum information non-locally**, so that local noise cannot corrupt it.

#### Local vs. Non-Local Encoding

In conventional qubits:
$$|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$$

The coefficients $\alpha$ and $\beta$ are stored in local degrees of freedom (charge, flux, spin at a specific location). Any local perturbation $H_\text{noise}$ can flip or dephase the qubit.

In topological qubits, information is encoded in the **collective state** of spatially separated objects:
$$|\psi\rangle_\text{topo} = \alpha|0\rangle_\text{topo} + \beta|1\rangle_\text{topo}$$

where the logical states differ only in global, topological properties that cannot be changed by local operations.

#### The Energy Gap Protection

Topological phases are characterized by:

1. **Ground state degeneracy**: Multiple degenerate ground states
2. **Energy gap**: Excited states are separated by $\Delta E$
3. **Topological order**: Ground states cannot be distinguished by local measurements

For errors to occur, the system must:
- Either acquire enough energy to cross the gap (suppressed as $e^{-\Delta E/k_BT}$)
- Or have a perturbation that acts non-locally (exponentially suppressed with separation)

$$P_\text{error} \sim e^{-L/\xi}$$

where $L$ is the separation between anyons and $\xi$ is the correlation length.

### 2. Exchange Statistics and Anyons

#### Particle Exchange in 3D vs 2D

In three dimensions, exchanging identical particles twice returns the system to its original state. This leads to only two possibilities:

**Bosons**:
$$|\psi_1 \psi_2\rangle \xrightarrow{\text{exchange}} +|\psi_2 \psi_1\rangle$$

**Fermions**:
$$|\psi_1 \psi_2\rangle \xrightarrow{\text{exchange}} -|\psi_2 \psi_1\rangle$$

In **two dimensions**, the situation is fundamentally different. The path of exchange matters - we cannot smoothly deform the path where particle 1 goes around particle 2 clockwise into the path where it goes counterclockwise.

#### Anyon Statistics

In 2D, the exchange phase can be arbitrary:

$$|\psi_1 \psi_2\rangle \xrightarrow{\text{exchange}} e^{i\theta}|\psi_2 \psi_1\rangle$$

Particles with $\theta \neq 0, \pi$ are called **anyons** (from "any" statistics).

**Abelian Anyons**: The exchange results in a phase factor
$$\hat{T}_{12}|\psi\rangle = e^{i\theta}|\psi\rangle$$

**Non-Abelian Anyons**: The exchange results in a unitary matrix acting on a degenerate subspace
$$\hat{T}_{12}|\psi_a\rangle = \sum_b U_{ab}|\psi_b\rangle$$

### 3. Braiding and the Braid Group

#### The Braid Group $B_n$

For $n$ particles in 2D, the braid group $B_n$ is generated by elementary exchanges $\sigma_i$ (exchanging particles $i$ and $i+1$) satisfying:

$$\boxed{\sigma_i \sigma_j = \sigma_j \sigma_i \quad \text{for } |i-j| \geq 2}$$

$$\boxed{\sigma_i \sigma_{i+1} \sigma_i = \sigma_{i+1} \sigma_i \sigma_{i+1}}$$

These are the **Yang-Baxter equations** - the fundamental relations for braiding.

#### Pictorial Representation

Braids can be visualized as world-lines in (2+1)D spacetime:

```
Time ↑
     |
  1  2  3
  |  |  |
  | /   |     σ₁: particles 1 and 2 exchange
  |/    |
  |\    |
  | \   |
  |  |  |
  1  2  3
```

The braid group is **non-Abelian**: $\sigma_1 \sigma_2 \neq \sigma_2 \sigma_1$ in general.

### 4. Fusion Rules

When two anyons are brought together, they can "fuse" into other anyon types. The possible outcomes are described by **fusion rules**:

$$a \times b = \sum_c N_{ab}^c \, c$$

where $N_{ab}^c$ are non-negative integers indicating the number of ways $a$ and $b$ can fuse to $c$.

#### Example: Ising Anyons

The Ising anyon model has three particle types: $\{1, \psi, \sigma\}$

- $1$: vacuum (trivial particle)
- $\psi$: fermion
- $\sigma$: non-Abelian anyon (Majorana-like)

**Fusion rules**:
$$\boxed{1 \times a = a, \quad \psi \times \psi = 1, \quad \sigma \times \psi = \sigma}$$
$$\boxed{\sigma \times \sigma = 1 + \psi}$$

The last rule is crucial: when two $\sigma$ particles fuse, the result is **not deterministic**. They can become either $1$ or $\psi$. This ambiguity creates a two-dimensional Hilbert space - the qubit!

#### Quantum Dimension

The **quantum dimension** $d_a$ of an anyon $a$ characterizes how the Hilbert space grows:

For Ising anyons:
$$d_1 = 1, \quad d_\psi = 1, \quad d_\sigma = \sqrt{2}$$

With $n$ $\sigma$ particles, the dimension of the ground state manifold is:
$$\dim(\mathcal{H}) = d_\sigma^{n-2} = 2^{(n-2)/2}$$

### 5. Topological Degeneracy and Qubit Encoding

#### Ground State Degeneracy

For $2n$ Majorana zero modes (equivalently, $2n$ Ising $\sigma$ anyons), the ground state degeneracy is:

$$\boxed{D = 2^{n-1}}$$

This can encode $n-1$ qubits. The "missing" qubit corresponds to the total fermion parity, which is conserved.

#### Why Degeneracy?

The degeneracy arises because:
1. Each pair of $\sigma$ anyons can fuse to either $1$ or $\psi$
2. No local operator can distinguish these fusion outcomes
3. The fusion outcome is a non-local, topological degree of freedom

For 4 Majoranas ($\gamma_1, \gamma_2, \gamma_3, \gamma_4$):
- Define fermion parity operators: $P_{12} = i\gamma_1\gamma_2$, $P_{34} = i\gamma_3\gamma_4$
- Total parity: $P_\text{total} = P_{12} P_{34} = -\gamma_1\gamma_2\gamma_3\gamma_4$
- If total parity is fixed, we have a 2D space: one qubit

### 6. The Computational Model

#### Gate Operations via Braiding

In topological quantum computing:
- **Qubits**: Encoded in fusion spaces of non-Abelian anyons
- **Gates**: Implemented by braiding anyons around each other
- **Measurement**: Fusing anyons and measuring the outcome

The key advantage: **braiding is topologically protected**. The gate depends only on the topology of the braid, not on the exact path taken.

#### Universality Question

A critical question: Can braiding alone implement universal quantum computation?

For **Ising anyons** (Majorana-based): **No**. The Ising braiding group generates only the Clifford group, not universal gates.

For **Fibonacci anyons**: **Yes**. Braiding Fibonacci anyons can approximate any unitary to arbitrary precision.

$$\boxed{\text{Ising: Clifford gates only} \quad \text{Fibonacci: Universal}}$$

For Majorana-based systems, universality requires supplementing braiding with:
- Magic state injection
- Topologically unprotected operations
- Hybrid schemes with conventional gates

---

## Quantum Computing Applications

### Intrinsic Error Correction

Topological protection provides:
1. **Passive error correction**: No active syndrome measurement needed for topological errors
2. **Exponential suppression**: Error rates decrease exponentially with system size
3. **Threshold-free operation**: Below certain temperature, errors are essentially zero

### Comparison with Active QEC

| Aspect | Topological QC | Active QEC |
|--------|----------------|------------|
| Error protection | Built into physics | Active measurement/correction |
| Overhead | Fixed (anyons) | Scales with distance |
| Gate implementation | Braiding | Transversal/magic states |
| Universality | Model-dependent | Architecture-dependent |

### Hybrid Approaches

Modern proposals combine:
- Topological protection for memory
- Measurement-based computation for gates
- Magic state distillation for non-Clifford gates

---

## Worked Examples

### Example 1: Exchange Statistics Calculation

**Problem**: Show that exchanging two bosons twice gives +1, while for anyons with exchange phase $\theta$, double exchange gives $e^{2i\theta}$.

**Solution**:

For bosons, the exchange operator satisfies:
$$\hat{T}^2 = \hat{I}$$

since exchanging twice returns particles to original positions in 3D.

For anyons in 2D:
$$\hat{T}|\psi\rangle = e^{i\theta}|\psi\rangle$$

Double exchange (full braid):
$$\hat{T}^2|\psi\rangle = \hat{T}(e^{i\theta}|\psi\rangle) = e^{i\theta}\hat{T}|\psi\rangle = e^{2i\theta}|\psi\rangle$$

$$\boxed{\text{Double exchange phase} = 2\theta}$$

For semions ($\theta = \pi/2$): double exchange gives $-1$.

### Example 2: Counting Ground States

**Problem**: Calculate the ground state degeneracy for a system with 6 Majorana zero modes on a disk.

**Solution**:

With $n = 6$ Majorana zero modes (3 pairs), we use:
$$D = 2^{n/2 - 1} = 2^{6/2 - 1} = 2^2 = 4$$

Wait - this needs more careful analysis. On a disk (open boundary):
- 6 Majoranas can form 3 complex fermions: $c_j = (\gamma_{2j-1} + i\gamma_{2j})/2$
- Total states: $2^3 = 8$
- With fixed total parity: $2^{3-1} = 4$ states

$$\boxed{D = 4 \text{ (encodes 2 qubits)}}$$

### Example 3: Fusion Outcomes

**Problem**: Four Ising $\sigma$ anyons are created. What are the possible total fusion outcomes?

**Solution**:

Using fusion rules $\sigma \times \sigma = 1 + \psi$:

Step 1: Fuse $\sigma_1 \times \sigma_2$:
$$\sigma_1 \times \sigma_2 = 1 + \psi$$

Step 2: Fuse $\sigma_3 \times \sigma_4$:
$$\sigma_3 \times \sigma_4 = 1 + \psi$$

Step 3: Fuse the results:
- If both give $1$: $1 \times 1 = 1$
- If first gives $1$, second gives $\psi$: $1 \times \psi = \psi$
- If first gives $\psi$, second gives $1$: $\psi \times 1 = \psi$
- If both give $\psi$: $\psi \times \psi = 1$

Total outcomes: $1$ (2 ways) and $\psi$ (2 ways)

$$\boxed{(\sigma)^4 \to 2 \cdot 1 + 2 \cdot \psi}$$

The two ways to get each outcome form the qubit basis!

---

## Practice Problems

### Level 1: Direct Application

1. **Braid Relations**: Verify that $\sigma_1\sigma_3 = \sigma_3\sigma_1$ for 4 particles by drawing the braids.

2. **Anyon Phases**: For an anyon with exchange phase $\theta = \pi/4$, what is the phase acquired when particle 1 goes around particle 2 completely (full monodromy)?

3. **Fusion Counting**: How many ways can 6 Ising $\sigma$ anyons fuse to the vacuum $1$?

### Level 2: Intermediate

4. **Quantum Dimension**: The total quantum dimension of an anyon theory is $\mathcal{D} = \sqrt{\sum_a d_a^2}$. Calculate $\mathcal{D}$ for the Ising theory.

5. **Topological S-matrix**: The modular S-matrix for Ising anyons is:
   $$S = \frac{1}{2}\begin{pmatrix} 1 & 1 & \sqrt{2} \\ 1 & 1 & -\sqrt{2} \\ \sqrt{2} & -\sqrt{2} & 0 \end{pmatrix}$$
   Verify that $S^2 = C$ where $C$ is the charge conjugation matrix.

6. **Braiding Unitarity**: For the elementary braiding matrix $\sigma_i = e^{i\phi}U_i$, show that unitarity requires $U_i U_i^\dagger = I$.

### Level 3: Challenging

7. **Fibonacci Fusion**: Fibonacci anyons have types $\{1, \tau\}$ with fusion rules $\tau \times \tau = 1 + \tau$.
   a) Calculate the quantum dimension of $\tau$.
   b) Show that $d_\tau = \phi = (1+\sqrt{5})/2$ (golden ratio).
   c) Calculate the dimension of the Hilbert space with $n$ $\tau$ particles.

8. **Yang-Baxter**: Prove that if $\sigma_i$ satisfies the Yang-Baxter equation, then the representation $\rho(\sigma_i) = e^{i\pi/4}\exp(\pi \gamma_i \gamma_{i+1}/4)$ also satisfies it.

---

## Computational Lab: Anyon Braiding Simulation

```python
"""
Day 932 Computational Lab: Topological Quantum Computing Fundamentals
Simulating anyon braiding and fusion in the Ising model
"""

import numpy as np
from scipy.linalg import expm
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# =============================================================================
# Part 1: Ising Anyon Fusion Rules
# =============================================================================

def ising_fusion_table():
    """
    Display the Ising anyon fusion rules.
    Types: 1 (vacuum), psi (fermion), sigma (non-Abelian)
    """
    print("=" * 50)
    print("Ising Anyon Fusion Rules")
    print("=" * 50)

    # Fusion table
    fusion = {
        ('1', '1'): '1',
        ('1', 'ψ'): 'ψ',
        ('1', 'σ'): 'σ',
        ('ψ', '1'): 'ψ',
        ('ψ', 'ψ'): '1',
        ('ψ', 'σ'): 'σ',
        ('σ', '1'): 'σ',
        ('σ', 'ψ'): 'σ',
        ('σ', 'σ'): '1 + ψ'  # Non-deterministic!
    }

    print("\n  ×  |  1   |  ψ   |  σ")
    print("-" * 30)
    for a in ['1', 'ψ', 'σ']:
        row = f"  {a}  |"
        for b in ['1', 'ψ', 'σ']:
            row += f" {fusion[(a, b)]:^4} |"
        print(row)

    # Quantum dimensions
    print("\nQuantum Dimensions:")
    print(f"  d_1 = 1")
    print(f"  d_ψ = 1")
    print(f"  d_σ = √2 ≈ {np.sqrt(2):.4f}")
    print(f"\nTotal quantum dimension: D = √(1² + 1² + (√2)²) = 2")

    return fusion

# =============================================================================
# Part 2: Braiding Matrices for Ising Anyons
# =============================================================================

def ising_braiding_matrices():
    """
    Construct the braiding matrices for Ising anyons.
    These act on the fusion space of multiple sigma anyons.
    """
    print("\n" + "=" * 50)
    print("Ising Anyon Braiding Matrices")
    print("=" * 50)

    # For 4 sigma anyons (1 qubit), basis is |1⟩, |ψ⟩ for fusion of first two sigmas
    # R-matrices: R^{σσ}_1 = e^{-iπ/8}, R^{σσ}_ψ = e^{3iπ/8}

    R_1 = np.exp(-1j * np.pi / 8)  # σσ → 1 channel
    R_psi = np.exp(3j * np.pi / 8)  # σσ → ψ channel

    # Braiding matrix for exchanging anyons 1 and 2 (in computational basis)
    sigma_12 = np.diag([R_1, R_psi])

    # For exchange of anyons 2 and 3, we need F-matrices
    # F^{σσσ}_σ = 1/√2 * [[1, 1], [1, -1]]
    F = (1/np.sqrt(2)) * np.array([[1, 1], [1, -1]])
    F_inv = F  # F is its own inverse (unitary and symmetric)

    # σ_23 = F^{-1} · diag(R_1, R_ψ) · F
    sigma_23 = F_inv @ np.diag([R_1, R_psi]) @ F

    print("\nBraiding matrix σ₁₂ (exchange particles 1,2):")
    print(f"  Diagonal in fusion basis:")
    print(f"  |1⟩ → e^{{-iπ/8}} |1⟩")
    print(f"  |ψ⟩ → e^{{3iπ/8}} |ψ⟩")

    print("\nBraiding matrix σ₂₃ (exchange particles 2,3):")
    print(f"  σ₂₃ = F⁻¹ · R · F")
    print(f"  Matrix form:")
    print(f"  {sigma_23}")

    # Verify braiding relation: σ₁σ₂σ₁ = σ₂σ₁σ₂
    lhs = sigma_12 @ sigma_23 @ sigma_12
    rhs = sigma_23 @ sigma_12 @ sigma_23

    print("\nVerifying Yang-Baxter equation: σ₁σ₂σ₁ = σ₂σ₁σ₂")
    print(f"  ||LHS - RHS|| = {np.linalg.norm(lhs - rhs):.2e}")

    return sigma_12, sigma_23, F

# =============================================================================
# Part 3: Visualizing Braids
# =============================================================================

def visualize_braid(braid_word, n_strands=3, ax=None):
    """
    Visualize a braid given as a word in generators σ_i.
    braid_word: list of integers, positive for σ_i, negative for σ_i^{-1}
    """
    if ax is None:
        fig = plt.figure(figsize=(8, 6))
        ax = fig.add_subplot(111, projection='3d')

    # Time runs along z-axis
    n_steps = len(braid_word) + 1
    z_vals = np.linspace(0, 1, n_steps)

    # Initialize strand positions
    strand_positions = np.zeros((n_strands, n_steps, 2))
    for i in range(n_strands):
        strand_positions[i, 0, 0] = i  # x position
        strand_positions[i, 0, 1] = 0  # y position (depth for 3D)

    # Current x-positions of strands
    current_x = list(range(n_strands))

    for step, generator in enumerate(braid_word):
        idx = abs(generator) - 1  # Convert to 0-indexed
        over = generator > 0  # True if σ, False if σ^{-1}

        # Exchange strands at positions idx and idx+1
        current_x[idx], current_x[idx + 1] = current_x[idx + 1], current_x[idx]

        for i in range(n_strands):
            strand_positions[i, step + 1, 0] = current_x.index(i)
            # Add y-offset to show which strand goes over
            if current_x.index(i) == idx or current_x.index(i) == idx + 1:
                strand_positions[i, step + 1, 1] = 0.1 * (1 if over else -1)
            else:
                strand_positions[i, step + 1, 1] = 0

    # Plot each strand
    colors = plt.cm.tab10(np.linspace(0, 1, n_strands))
    for i in range(n_strands):
        # Interpolate for smooth curves
        t_fine = np.linspace(0, 1, 100)
        x_fine = np.interp(t_fine, z_vals, strand_positions[i, :, 0])
        y_fine = np.interp(t_fine, z_vals, strand_positions[i, :, 1])
        z_fine = t_fine

        ax.plot(x_fine, y_fine, z_fine, color=colors[i], linewidth=2,
                label=f'Strand {i+1}')

    ax.set_xlabel('Position')
    ax.set_ylabel('Depth')
    ax.set_zlabel('Time')
    ax.set_title(f'Braid: {braid_word}')
    ax.legend()

    return ax

# =============================================================================
# Part 4: Ground State Degeneracy
# =============================================================================

def compute_degeneracy(n_anyons, anyon_type='ising'):
    """
    Compute ground state degeneracy for n anyons.
    """
    print("\n" + "=" * 50)
    print(f"Ground State Degeneracy: {n_anyons} {anyon_type} anyons")
    print("=" * 50)

    if anyon_type == 'ising':
        # For n sigma anyons (n even), degeneracy is 2^{n/2 - 1}
        if n_anyons % 2 != 0:
            print("Warning: Odd number of σ anyons, total charge is σ")
            degeneracy = 2**((n_anyons - 1) // 2)
        else:
            degeneracy = 2**(n_anyons // 2 - 1)

        n_qubits = int(np.log2(degeneracy))

    elif anyon_type == 'fibonacci':
        # Dimension grows as Fibonacci numbers
        fib = [1, 1]
        for i in range(n_anyons - 1):
            fib.append(fib[-1] + fib[-2])
        degeneracy = fib[n_anyons]
        n_qubits = np.log2(degeneracy)

    print(f"  Number of anyons: {n_anyons}")
    print(f"  Ground state degeneracy: {degeneracy}")
    print(f"  Equivalent qubits: {n_qubits:.2f}")

    return degeneracy

# =============================================================================
# Part 5: Topological Error Suppression
# =============================================================================

def error_suppression_plot():
    """
    Plot error probability vs separation for topological protection.
    """
    print("\n" + "=" * 50)
    print("Topological Error Suppression")
    print("=" * 50)

    fig, axes = plt.subplots(1, 2, figsize=(12, 5))

    # Error vs separation
    xi = 1  # Correlation length (normalized)
    L = np.linspace(0.5, 10, 100)  # Separation in units of xi

    P_topo = np.exp(-L / xi)  # Topological error rate

    # Compare with thermal error for conventional qubit
    T_ratio = np.array([0.1, 0.2, 0.5])  # k_B T / Δ

    ax1 = axes[0]
    ax1.semilogy(L, P_topo, 'b-', linewidth=2, label='Topological (∝ exp(-L/ξ))')
    ax1.axhline(y=1e-4, color='r', linestyle='--', label='Error threshold')
    ax1.set_xlabel('Separation L/ξ')
    ax1.set_ylabel('Error Probability')
    ax1.set_title('Topological Error Suppression')
    ax1.legend()
    ax1.grid(True, alpha=0.3)
    ax1.set_ylim([1e-6, 1])

    # Degeneracy scaling
    ax2 = axes[1]
    n_anyons = np.arange(2, 20, 2)
    deg_ising = 2**(n_anyons // 2 - 1)

    # Fibonacci numbers for comparison
    fib = [1, 1]
    for i in range(20):
        fib.append(fib[-1] + fib[-2])
    deg_fib = [fib[n] for n in n_anyons]

    ax2.semilogy(n_anyons, deg_ising, 'o-', label='Ising (2^{n/2-1})', linewidth=2)
    ax2.semilogy(n_anyons, deg_fib, 's-', label='Fibonacci (F_n)', linewidth=2)
    ax2.set_xlabel('Number of Anyons')
    ax2.set_ylabel('Ground State Degeneracy')
    ax2.set_title('Hilbert Space Dimension')
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    plt.savefig('topological_protection.png', dpi=150, bbox_inches='tight')
    plt.show()

    print("\nKey insight: Error rate decreases EXPONENTIALLY with separation!")
    print("At L = 10ξ: P_error ≈ 4.5 × 10⁻⁵")

# =============================================================================
# Part 6: Complete Simulation
# =============================================================================

def main():
    """Run all demonstrations."""
    print("╔" + "=" * 58 + "╗")
    print("║  Day 932: Topological Quantum Computing Fundamentals     ║")
    print("╚" + "=" * 58 + "╝")

    # 1. Fusion rules
    fusion = ising_fusion_table()

    # 2. Braiding matrices
    sigma_12, sigma_23, F = ising_braiding_matrices()

    # 3. Visualize a braid
    print("\n" + "=" * 50)
    print("Braid Visualization")
    print("=" * 50)

    fig = plt.figure(figsize=(15, 5))

    # Simple exchange
    ax1 = fig.add_subplot(131, projection='3d')
    visualize_braid([1], n_strands=3, ax=ax1)
    ax1.set_title('σ₁: Exchange 1↔2')

    # Double exchange
    ax2 = fig.add_subplot(132, projection='3d')
    visualize_braid([1, 1], n_strands=3, ax=ax2)
    ax2.set_title('σ₁²: Full monodromy')

    # Yang-Baxter: σ₁σ₂σ₁
    ax3 = fig.add_subplot(133, projection='3d')
    visualize_braid([1, 2, 1], n_strands=3, ax=ax3)
    ax3.set_title('σ₁σ₂σ₁ (Yang-Baxter)')

    plt.tight_layout()
    plt.savefig('braid_examples.png', dpi=150, bbox_inches='tight')
    plt.show()

    # 4. Ground state degeneracy
    for n in [4, 6, 8, 10]:
        compute_degeneracy(n, 'ising')

    print("\n" + "-" * 50)
    print("Fibonacci anyons (for comparison):")
    for n in [4, 6, 8, 10]:
        compute_degeneracy(n, 'fibonacci')

    # 5. Error suppression
    error_suppression_plot()

    # 6. Demonstrate gate from braiding
    print("\n" + "=" * 50)
    print("Gate from Braiding")
    print("=" * 50)

    # Compute σ₁₂² (double exchange)
    sigma_12_sq = sigma_12 @ sigma_12
    print(f"\nσ₁₂² (full monodromy of particles 1,2):")
    print(f"  = diag(e^{{-iπ/4}}, e^{{3iπ/4}})")
    print(f"  = diag({np.exp(-1j*np.pi/4):.4f}, {np.exp(3j*np.pi/4):.4f})")

    # This is related to the Z gate (up to global phase)
    Z_gate = np.array([[1, 0], [0, -1]])
    print(f"\n  Note: σ₁₂² ∝ Z gate (phase gate) up to global phase")

    print("\n" + "=" * 50)
    print("Summary")
    print("=" * 50)
    print("""
Key Results:
1. Anyons exist only in 2D - exchange statistics beyond bosons/fermions
2. Non-Abelian anyons have degenerate ground states for quantum storage
3. Braiding implements topologically protected gates
4. Ising anyons (Majoranas) give Clifford gates; not universal alone
5. Errors are exponentially suppressed with anyon separation
    """)

if __name__ == "__main__":
    main()
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| Anyon exchange | $\|\psi\rangle \to e^{i\theta}\|\psi\rangle$ |
| Braid group relations | $\sigma_i\sigma_{i+1}\sigma_i = \sigma_{i+1}\sigma_i\sigma_{i+1}$ |
| Ising fusion | $\sigma \times \sigma = 1 + \psi$ |
| Quantum dimension | $d_\sigma = \sqrt{2}$ |
| Ground state degeneracy | $D = 2^{n/2-1}$ for $n$ $\sigma$ anyons |
| Error suppression | $P_\text{error} \sim e^{-L/\xi}$ |

### Main Takeaways

1. **Topological protection** arises from non-local encoding - information is stored in relationships between spatially separated anyons, not in any single location.

2. **Anyons** are particles with exotic exchange statistics that only exist in 2D systems. Non-Abelian anyons have degenerate ground states that can encode quantum information.

3. **Braiding operations** implement unitary gates through the physical motion of anyons. These gates depend only on the topology of the braid, providing intrinsic fault tolerance.

4. **Fusion rules** describe how anyons combine. The ambiguity in fusion outcomes for non-Abelian anyons creates the Hilbert space for quantum computation.

5. **Ising anyons** (the type realized by Majorana zero modes) can implement Clifford gates but require additional resources for universality.

---

## Daily Checklist

- [ ] I can explain why topological qubits are protected from local noise
- [ ] I understand the difference between Abelian and non-Abelian anyons
- [ ] I can state the fusion rules for Ising anyons
- [ ] I can calculate the ground state degeneracy for $n$ Majorana zero modes
- [ ] I understand why Ising anyons alone don't give universal quantum computation
- [ ] I have run the computational lab and understand braiding matrix construction

---

## Preview of Day 933

Tomorrow we dive into **Majorana Fermions** - the specific type of non-Abelian anyon that may be realized in condensed matter systems. We'll explore:

- The self-conjugate property: $\gamma = \gamma^\dagger$
- Majorana operators from fermion operators
- The Kitaev chain model and its topological phases
- Why Majoranas come in pairs and form non-local fermions

The connection between abstract anyon physics and real materials will become concrete!

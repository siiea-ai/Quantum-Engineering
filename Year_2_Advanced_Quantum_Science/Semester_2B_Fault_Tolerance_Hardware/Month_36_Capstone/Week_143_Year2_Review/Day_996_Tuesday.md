# Day 996: Semester 2A Review - Stabilizer & Topological Codes

## Schedule Overview

| Block | Time | Duration | Activity |
|-------|------|----------|----------|
| Morning | 9:00 AM - 12:30 PM | 3.5 hours | Core Review: Stabilizer Formalism & Topological Codes |
| Afternoon | 2:00 PM - 4:30 PM | 2.5 hours | Qualifying Exam Problem Practice |
| Evening | 7:00 PM - 8:00 PM | 1 hour | Synthesis and Concept Mapping |

**Total Study Time:** 7 hours

---

## Learning Objectives

By the end of Day 996, you will be able to:

1. **Apply** the stabilizer formalism to analyze and construct quantum codes
2. **Construct** CSS codes from classical linear codes
3. **Explain** the Gottesman-Knill theorem and its implications
4. **Derive** the toric code Hamiltonian and identify its ground states
5. **Characterize** anyonic excitations and their braiding properties
6. **Connect** topological protection to physical error mechanisms

---

## Core Review Content

### 1. The Pauli Group

#### Single-Qubit Pauli Group

$$\mathcal{P}_1 = \{\pm I, \pm iI, \pm X, \pm iX, \pm Y, \pm iY, \pm Z, \pm iZ\}$$

**Properties:**
- Order: $|\mathcal{P}_1| = 16$
- Closed under multiplication
- Every element squares to $\pm I$
- $XZ = -ZX = iY$

#### n-Qubit Pauli Group

$$\mathcal{P}_n = \{i^k P_1 \otimes P_2 \otimes \cdots \otimes P_n : k \in \{0,1,2,3\}, P_j \in \{I,X,Y,Z\}\}$$

**Size:** $|\mathcal{P}_n| = 4 \cdot 4^n$

**Key property:** Elements either commute or anticommute:
$$\boxed{PQ = \pm QP \text{ for all } P, Q \in \mathcal{P}_n}$$

---

### 2. Stabilizer Formalism

#### Stabilizer Group Definition

A **stabilizer group** $S$ is an Abelian subgroup of $\mathcal{P}_n$ such that:
1. $-I \notin S$ (non-trivial)
2. All elements commute
3. Generated by independent generators $\{g_1, \ldots, g_{n-k}\}$

#### Stabilizer Code Space

The code space is the simultaneous +1 eigenspace:

$$\boxed{\mathcal{C} = \{|\psi\rangle : g|\psi\rangle = |\psi\rangle \text{ for all } g \in S\}}$$

**Dimension:** $\dim(\mathcal{C}) = 2^k$ for $n-k$ independent generators

#### Example: 5-Qubit Code

Generators:
$$g_1 = XZZXI, \quad g_2 = IXZZX, \quad g_3 = XIXZZ, \quad g_4 = ZXIXZ$$

Parameters: [[5, 1, 3]] - the smallest code correcting any single-qubit error.

---

### 3. Syndrome Measurement

#### Syndrome Extraction

For error $E$ on encoded state $|\psi\rangle$:

$$g_i \cdot E|\psi\rangle = \pm E|\psi\rangle$$

The syndrome is the pattern of $\pm 1$ eigenvalues.

**Syndrome formula:**
$$s_i = \begin{cases} 0 & \text{if } [g_i, E] = 0 \\ 1 & \text{if } \{g_i, E\} = 0 \end{cases}$$

#### Syndrome Table Construction

For each correctable error $E_j$, compute:
$$\vec{s}(E_j) = (s_1, s_2, \ldots, s_{n-k})$$

Distinct syndromes enable unique error identification.

---

### 4. CSS Codes

#### Construction from Classical Codes

Given two classical codes $C_1[n, k_1, d_1]$ and $C_2[n, k_2, d_2]$ with $C_2 \subset C_1$:

**CSS code:** $[[n, k_1 - k_2, \min(d_1, d_2^\perp)]]$

**Stabilizers:**
- X-type: $X^{\vec{c}}$ for $\vec{c} \in C_2$
- Z-type: $Z^{\vec{c}}$ for $\vec{c} \in C_1^\perp$

#### Steane [[7,1,3]] Code

From Hamming [7,4,3] code with $H = C_1 = C_2^\perp$:

**Stabilizer generators:**

| Generator | Type | Weight |
|-----------|------|--------|
| $IIIXXXX$ | X | 4 |
| $IXXIIXX$ | X | 4 |
| $XIXIXIX$ | X | 4 |
| $IIIZZZZ$ | Z | 4 |
| $IZZIIZZ$ | Z | 4 |
| $ZIZIZIZ$ | Z | 4 |

**Logical operators:**
$$\bar{X} = X^{\otimes 7}, \quad \bar{Z} = Z^{\otimes 7}$$

---

### 5. Gottesman-Knill Theorem

#### Statement

A quantum circuit using only:
1. Clifford gates ($H$, $S$, $CNOT$)
2. Preparation in computational basis states
3. Measurements in computational basis
4. Classical conditioning on measurement outcomes

can be **efficiently simulated classically** in $O(n^2)$ time per gate.

#### Implications

| Circuit Type | Efficiently Simulable? |
|--------------|----------------------|
| Clifford only | Yes |
| Clifford + T gate | No (universal) |
| Clifford + magic states | No |
| Stabilizer state prep | Yes |

**Key insight:** Stabilizer states remain stabilizer states under Clifford operations.

#### Tableau Representation

An $n$-qubit stabilizer state specified by $2n \times (2n+1)$ binary tableau:
- $n$ rows for stabilizer generators
- $n$ rows for destabilizers
- $2n$ columns for X,Z components
- 1 column for phase

---

### 6. Toric Code

#### Kitaev's Construction (1997)

Place qubits on edges of a square lattice with periodic boundaries (torus).

**Vertex operators (detect X errors):**
$$\boxed{A_v = \prod_{e \ni v} X_e}$$

**Plaquette operators (detect Z errors):**
$$\boxed{B_p = \prod_{e \in \partial p} Z_e}$$

#### Hamiltonian

$$H = -\sum_v A_v - \sum_p B_p$$

Ground states satisfy $A_v = B_p = +1$ for all $v, p$.

#### Code Parameters

For $L \times L$ lattice:
- Physical qubits: $n = 2L^2$
- Logical qubits: $k = 2$
- Distance: $d = L$

$$\boxed{[[2L^2, 2, L]]}$$

---

### 7. Anyonic Excitations

#### Excitation Types

**e-particle (electric charge):**
- Created by $A_v = -1$ violation
- Endpoint of Z-string error

**m-particle (magnetic flux):**
- Created by $B_p = -1$ violation
- Endpoint of X-string error

**Fermion (em composite):**
- Bound state of e and m
- Has fermionic statistics

#### Braiding Statistics

When e moves around m:
$$|e\rangle|m\rangle \xrightarrow{\text{braid}} -|e\rangle|m\rangle$$

This $-1$ phase is the signature of **mutual anyonic statistics**.

#### Fusion Rules

$$e \times e = 1, \quad m \times m = 1, \quad e \times m = \epsilon \text{ (fermion)}$$

---

### 8. Topological Protection

#### Why Errors Must Form Strings

Single-qubit errors create anyons in pairs. To cause a logical error:
- Errors must form a non-contractible loop
- Loop must wind around torus handle
- Requires $O(L)$ errors for distance-$L$ code

#### Error Chain Picture

```
Error chain:    X - X - X - X - X
                |               |
Anyons:         e               e

Logical error requires: chain spanning full code distance
```

#### Thermal Stability

At temperature $T$:
$$P(\text{logical error}) \propto e^{-\Delta E \cdot L / k_B T}$$

where $\Delta E$ is energy cost per anyon.

---

## Concept Map: Stabilizer & Topological Codes

```
Pauli Group P_n
       │
       ▼
Stabilizer Group S ⊂ P_n
       │
       ├──► Stabilizer States: S|ψ⟩ = |ψ⟩
       │
       ├──► CSS Construction: C_2 ⊂ C_1
       │           │
       │           ▼
       │    Steane [[7,1,3]]
       │
       └──► Gottesman-Knill: Efficient simulation
                   │
                   ▼
           Need non-Clifford for universality
                   │
                   ▼
           Magic states / T-gates

Toric Code (Topological)
       │
       ├──► A_v, B_p stabilizers
       │
       ├──► Anyons: e, m, ε
       │
       ├──► Braiding statistics
       │
       └──► Topological protection: d = L
```

---

## Qualifying Exam Practice Problems

### Problem 1: Stabilizer Analysis (25 points)

**Question:** Consider the stabilizer group generated by:
$$g_1 = XXII, \quad g_2 = ZZII, \quad g_3 = IIXX, \quad g_4 = IIZZ$$

(a) How many logical qubits does this code encode?
(b) Find the logical $\bar{X}$ and $\bar{Z}$ operators
(c) What is the code distance?
(d) What class of errors can this code detect?

**Solution:**

**(a)** Number of logical qubits:
- $n = 4$ physical qubits
- $m = 4$ stabilizer generators
- BUT: Check independence!

$g_1 \cdot g_2 = YYII$, $g_3 \cdot g_4 = IIYY$

These are independent. Also check: Do any products give $I$?

$g_1g_2g_3g_4 = YYII \cdot IIYY = YYYY$, not identity.

All 4 generators independent: $k = n - m = 4 - 4 = 0$?

Wait, let's recheck. For $g_1 = XXII$, $g_2 = ZZII$: do they commute?
- $[XX, ZZ]$ on qubits 1,2: $XX \cdot ZZ = (XZ)(XZ) = (-iY)(-iY) = -YY$
- $ZZ \cdot XX = (ZX)(ZX) = (iY)(iY) = -YY$
- They commute! Good.

But these don't form a valid stabilizer group - $g_1$ and $g_2$ don't commute!
$X_1X_2 \cdot Z_1Z_2 \neq Z_1Z_2 \cdot X_1X_2$ ... actually they do because each pair anticommutes twice.

Reconsidering: This encodes $k = 0$ qubits? No, that's a state, not a code.

Actually, $g_1g_2 = -YYII$ (anticommute locally, commute globally).

Let me reconsider the problem. Actually $(XX)(ZZ) = XZXZ = (-iY)(-iY) = -YY$ and $(ZZ)(XX) = -YY$. They commute.

Independent generators: 4, so $k = 4 - 4 = 0$. This specifies a unique state (not useful as a code), unless there's a dependency.

**Actually:** The code is $[[4, 0, -]]$ - stabilizer state, not error-correcting code.

**(b)** No logical operators exist for $k=0$.

**(c)** Distance undefined for $k=0$.

**(d)** Can detect errors that anticommute with at least one stabilizer.

---

### Problem 2: CSS Code Construction (25 points)

**Question:** Construct a CSS code from the classical repetition code $C_1 = \{000, 111\}$ and its dual.

(a) Find $C_1^\perp$
(b) Write the stabilizer generators
(c) Determine the code parameters [[n, k, d]]
(d) Give explicit codewords $|0_L\rangle$ and $|1_L\rangle$

**Solution:**

**(a)** Repetition code $C_1 = \{000, 111\}$ has generator matrix $G = [111]$.

Parity check matrix: $H = \begin{pmatrix} 1 & 1 & 0 \\ 0 & 1 & 1 \end{pmatrix}$

$C_1^\perp$ = row space of $H$ = $\{000, 110, 011, 101\}$

Note: $C_1 \subset C_1^\perp$ (since $000, 111 \in C_1^\perp$? Check: $111 \cdot 110 = 0$ mod 2? $1+1+0 = 0$. Yes!)

Wait, we need $C_2 \subset C_1$. Let $C_2 = C_1^\perp$ and $C_1 = $ full space? That won't work.

Let's use $C_1 = C_1^\perp = \{000, 110, 011, 101\}$ (Hamming-like).

Actually for CSS: Take $C_2 = C_1 = \{000, 111\}$ (repetition code itself).

$C_2^\perp = C_1^\perp = \{000, 110, 011, 101\}$

Check $C_2 \subset C_1$: $\{000, 111\} \subset \{000, 111\}$. Yes (trivially).

**(b)** Stabilizers:
- X-type from $C_2 = \{000, 111\}$: Only non-trivial is $XXX$
- Z-type from $C_1^\perp = \{000, 110, 011, 101\}$: $ZZI$, $IZZ$, $ZIZ$ (dependent)

Generators: $\{XXX, ZZI, IZZ\}$

**(c)** Parameters:
- $n = 3$
- $k = k_1 - k_2 = 1 - 1 = 0$?

Hmm, this gives a stabilizer state, not a code. The repetition code is self-dual at $n=3$!

**Correct approach:** Use $C_1 =$ [7,4,3] Hamming, $C_2 = C_1^\perp$ = [7,3,4] to get Steane code.

**(d)** For the Steane code [[7,1,3]]:
$$|0_L\rangle = \frac{1}{\sqrt{8}} \sum_{c \in C_2} |c\rangle$$
$$|1_L\rangle = \frac{1}{\sqrt{8}} \sum_{c \in C_2} |c \oplus 1111111\rangle$$

---

### Problem 3: Toric Code Analysis (25 points)

**Question:** For a $3 \times 3$ toric code:

(a) How many physical qubits are there?
(b) How many independent stabilizer generators?
(c) What is the code distance?
(d) If a Z error occurs on edge $e$, which plaquettes are violated?

**Solution:**

**(a)** Physical qubits = edges of $3 \times 3$ torus
- Horizontal edges: $3 \times 3 = 9$
- Vertical edges: $3 \times 3 = 9$
- **Total: $n = 18$**

**(b)** Stabilizer generators:
- Vertex operators $A_v$: 9 vertices, but $\prod_v A_v = I$, so 8 independent
- Plaquette operators $B_p$: 9 plaquettes, but $\prod_p B_p = I$, so 8 independent
- **Total: 16 independent generators**

Logical qubits: $k = 18 - 16 = 2$ (confirms [[18, 2, 3]])

**(c)** Distance $d = L = 3$

Minimum weight logical operator must wrap around torus:
- Logical $\bar{X}_1$: Z operators on 3 vertical edges forming horizontal loop
- Logical $\bar{Z}_1$: X operators on 3 horizontal edges forming vertical loop

**(d)** Z error on edge $e$:
- $Z_e$ anticommutes with $B_p$ if $e \in \partial p$
- Each edge borders exactly 2 plaquettes
- **Both adjacent plaquettes are violated** (have eigenvalue $-1$)

---

### Problem 4: Gottesman-Knill Application (15 points)

**Question:** Determine whether each circuit can be efficiently classically simulated:

(a) $H^{\otimes n}$ followed by $n$ CNOT gates in a chain
(b) $H$ on first qubit, $T$ on first qubit, CNOT to second
(c) Prepare $|0\rangle^{\otimes n}$, apply Cliffords, measure in Z basis
(d) VQE circuit with parameterized rotations

**Solution:**

**(a)** $H^{\otimes n}$ + CNOT chain
- All Clifford gates
- **Efficiently simulable** by Gottesman-Knill

**(b)** $H$, $T$, CNOT
- Contains T gate (non-Clifford)
- **Not efficiently simulable** (unless trivially small)

**(c)** Prepare, Clifford, measure
- Exactly Gottesman-Knill scenario
- **Efficiently simulable** in $O(n^2)$ per gate

**(d)** VQE with parameterized rotations
- Continuous parameters = non-Clifford
- **Not efficiently simulable** (exponential in general)

---

### Problem 5: Anyon Braiding (10 points)

**Question:** In the toric code, describe the physical process of braiding an e-particle around an m-particle, and explain why this produces a $-1$ phase.

**Solution:**

**Physical process:**
1. Create e-m pair at locations $v_1, p_1$ (string of Z errors creates e's, X errors create m's)
2. Move e-particle around m-particle via sequence of Z operators
3. Return e to original position

**Phase calculation:**
- Moving e around closed loop = acting with $Z$ operators on loop edges
- This $Z$-loop operator anticommutes with $B_p$ at enclosed plaquette
- Since m-particle means $B_p = -1$, the loop acts as $-1$

**Algebraic view:**
$$Z_{\text{loop}} B_p = -B_p Z_{\text{loop}}$$

When loop encloses $m$ (where $B_p = -1$):
$$|\psi_{em}\rangle \xrightarrow{Z_{\text{loop}}} -|\psi_{em}\rangle$$

This mutual statistics is **anyonic** (neither bosonic +1 nor fermionic exchange $-1$, but braiding $-1$).

---

## Computational Review

```python
"""
Day 996 Computational Review: Stabilizer & Topological Codes
Semester 2A Review - Week 143
"""

import numpy as np
from itertools import product
import matplotlib.pyplot as plt

# =============================================================================
# Part 1: Stabilizer Tableau Operations
# =============================================================================

print("=" * 70)
print("Part 1: Stabilizer Tableau Representation")
print("=" * 70)

class StabilizerTableau:
    """
    Efficient representation of stabilizer states.
    Tableau format: (n stabilizers) x (2n + 1) binary matrix
    Columns: X1...Xn | Z1...Zn | phase
    """

    def __init__(self, n):
        self.n = n
        # Initialize to |0...0⟩ state
        # Stabilizers are Z1, Z2, ..., Zn
        self.tableau = np.zeros((n, 2*n + 1), dtype=int)
        for i in range(n):
            self.tableau[i, n + i] = 1  # Z_i stabilizer

    def apply_H(self, qubit):
        """Apply Hadamard to qubit."""
        # H: X <-> Z
        for i in range(self.n):
            # Swap X and Z columns for this qubit
            self.tableau[i, qubit], self.tableau[i, self.n + qubit] = \
                self.tableau[i, self.n + qubit], self.tableau[i, qubit]
            # Update phase based on Y content
            if self.tableau[i, qubit] == 1 and self.tableau[i, self.n + qubit] == 1:
                self.tableau[i, 2*self.n] ^= 1

    def apply_S(self, qubit):
        """Apply S (phase) gate to qubit."""
        # S: X -> Y = iXZ, Z -> Z
        for i in range(self.n):
            if self.tableau[i, qubit] == 1:
                self.tableau[i, 2*self.n] ^= self.tableau[i, self.n + qubit]
                self.tableau[i, self.n + qubit] ^= 1

    def apply_CNOT(self, control, target):
        """Apply CNOT with given control and target."""
        for i in range(self.n):
            # X_c -> X_c X_t
            if self.tableau[i, control] == 1:
                self.tableau[i, target] ^= 1
            # Z_t -> Z_c Z_t
            if self.tableau[i, self.n + target] == 1:
                self.tableau[i, self.n + control] ^= 1

    def get_stabilizers(self):
        """Return stabilizer generators as Pauli strings."""
        paulis = ['I', 'X', 'Z', 'Y']
        stabs = []
        for i in range(self.n):
            s = ""
            phase = "+" if self.tableau[i, 2*self.n] == 0 else "-"
            for j in range(self.n):
                x = self.tableau[i, j]
                z = self.tableau[i, self.n + j]
                s += paulis[x + 2*z]
            stabs.append(phase + s)
        return stabs

# Demo: Create Bell state |Φ+⟩
print("\nCreating Bell state |Φ+⟩:")
tab = StabilizerTableau(2)
print(f"Initial (|00⟩): {tab.get_stabilizers()}")

tab.apply_H(0)
print(f"After H on q0: {tab.get_stabilizers()}")

tab.apply_CNOT(0, 1)
print(f"After CNOT(0,1): {tab.get_stabilizers()}")
print("Expected: +XX, +ZZ for |Φ+⟩")

# =============================================================================
# Part 2: CSS Code Structure
# =============================================================================

print("\n" + "=" * 70)
print("Part 2: Steane Code Structure")
print("=" * 70)

def steane_code_info():
    """Display Steane [[7,1,3]] code structure."""

    # Parity check matrix of [7,4,3] Hamming code
    H_hamming = np.array([
        [1, 0, 1, 0, 1, 0, 1],
        [0, 1, 1, 0, 0, 1, 1],
        [0, 0, 0, 1, 1, 1, 1]
    ])

    print("Hamming [7,4,3] parity check matrix H:")
    print(H_hamming)

    # X-type stabilizers (from H)
    print("\nX-type stabilizers (rows of H mapped to X):")
    for row in H_hamming:
        stab = ''.join(['X' if b else 'I' for b in row])
        print(f"  {stab}")

    # Z-type stabilizers (same pattern)
    print("\nZ-type stabilizers (rows of H mapped to Z):")
    for row in H_hamming:
        stab = ''.join(['Z' if b else 'I' for b in row])
        print(f"  {stab}")

    print("\nLogical operators:")
    print("  X_L = XXXXXXX")
    print("  Z_L = ZZZZZZZ")

    return H_hamming

H = steane_code_info()

# =============================================================================
# Part 3: Toric Code Visualization
# =============================================================================

print("\n" + "=" * 70)
print("Part 3: Toric Code Structure")
print("=" * 70)

def visualize_toric_code(L):
    """Create visualization of L x L toric code."""

    fig, ax = plt.subplots(1, 1, figsize=(8, 8))

    # Draw lattice
    for i in range(L):
        for j in range(L):
            # Horizontal edges
            ax.plot([i, i+1], [j, j], 'b-', linewidth=2, alpha=0.5)
            # Vertical edges
            ax.plot([i, i], [j, j+1], 'b-', linewidth=2, alpha=0.5)

    # Draw vertices
    for i in range(L):
        for j in range(L):
            ax.plot(i, j, 'ko', markersize=10)

    # Highlight a vertex operator
    v_x, v_y = 1, 1
    edges_v = [(v_x-0.5, v_y), (v_x+0.5, v_y), (v_x, v_y-0.5), (v_x, v_y+0.5)]
    for ex, ey in edges_v:
        ax.plot([v_x, ex*2-v_x+0.5 if ex != v_x else v_x],
                [v_y, ey*2-v_y+0.5 if ey != v_y else v_y],
                'r-', linewidth=4)
    ax.plot(v_x, v_y, 'ro', markersize=15, label='Vertex (A_v)')

    # Highlight a plaquette operator
    p_x, p_y = 1.5, 1.5
    ax.add_patch(plt.Rectangle((1, 1), 1, 1, fill=True,
                                facecolor='green', alpha=0.3,
                                edgecolor='green', linewidth=3,
                                label='Plaquette (B_p)'))

    ax.set_xlim(-0.5, L + 0.5)
    ax.set_ylim(-0.5, L + 0.5)
    ax.set_aspect('equal')
    ax.set_title(f'Toric Code on {L}x{L} Lattice', fontsize=14)
    ax.legend(loc='upper right')
    ax.set_xlabel('Edges carry qubits')

    # Add annotations
    ax.annotate('Vertex operator A_v\n(product of X on edges)',
                xy=(1, 1), xytext=(2.5, 0.3),
                arrowprops=dict(arrowstyle='->', color='red'),
                fontsize=10, color='red')

    ax.annotate('Plaquette operator B_p\n(product of Z on edges)',
                xy=(1.5, 1.5), xytext=(2.5, 2.7),
                arrowprops=dict(arrowstyle='->', color='green'),
                fontsize=10, color='green')

    plt.tight_layout()
    plt.savefig('day_996_toric_code.png', dpi=150, bbox_inches='tight')
    plt.close()
    print(f"Saved toric code visualization")

visualize_toric_code(3)

# Code parameters
L = 3
n_qubits = 2 * L * L
n_vertices = L * L
n_plaquettes = L * L
n_stabilizers = (n_vertices - 1) + (n_plaquettes - 1)  # -1 for each constraint
k_logical = n_qubits - n_stabilizers

print(f"\nToric code parameters for L={L}:")
print(f"  Physical qubits: n = 2L² = {n_qubits}")
print(f"  Stabilizer generators: {n_stabilizers}")
print(f"  Logical qubits: k = {k_logical}")
print(f"  Code distance: d = L = {L}")
print(f"  Notation: [[{n_qubits}, {k_logical}, {L}]]")

# =============================================================================
# Part 4: Anyon Creation and Detection
# =============================================================================

print("\n" + "=" * 70)
print("Part 4: Anyon Excitations")
print("=" * 70)

def demonstrate_anyons():
    """Show how errors create anyons in toric code."""

    print("\nError → Anyon mapping:")
    print("-" * 40)
    print("Z error on edge e:")
    print("  - Anticommutes with A_v at endpoints of e")
    print("  - Creates pair of e-anyons (electric charges)")
    print()
    print("X error on edge e:")
    print("  - Anticommutes with B_p for plaquettes containing e")
    print("  - Creates pair of m-anyons (magnetic fluxes)")
    print()
    print("Y error = XZ error:")
    print("  - Creates both e and m anyons")
    print("  - Composite ε = e×m (fermion)")

    # Fusion rules
    print("\nFusion rules:")
    print("  e × e = 1 (vacuum)")
    print("  m × m = 1 (vacuum)")
    print("  e × m = ε (fermion)")
    print("  ε × ε = 1 (vacuum)")

    # Braiding
    print("\nBraiding statistics:")
    print("  e around m: phase = -1 (mutual anyonic)")
    print("  e around e: phase = +1 (bosonic)")
    print("  m around m: phase = +1 (bosonic)")

demonstrate_anyons()

# =============================================================================
# Part 5: Syndrome Decoding Visualization
# =============================================================================

print("\n" + "=" * 70)
print("Part 5: Syndrome Pattern Recognition")
print("=" * 70)

def visualize_syndrome():
    """Visualize syndrome pattern for an error."""

    fig, axes = plt.subplots(1, 2, figsize=(12, 5))
    L = 4

    # Left: Error configuration
    ax1 = axes[0]
    ax1.set_title('Error Configuration (X errors)', fontsize=12)

    # Draw lattice
    for i in range(L):
        for j in range(L):
            ax1.plot([i, i+1], [j, j], 'b-', linewidth=1, alpha=0.3)
            ax1.plot([i, i], [j, j+1], 'b-', linewidth=1, alpha=0.3)

    # Mark errors (X errors create m-anyons)
    error_edges = [(0.5, 1), (1.5, 1), (2.5, 1)]  # Horizontal string
    for ex, ey in error_edges:
        ax1.plot(ex, ey, 'rx', markersize=15, mew=3)

    ax1.set_xlim(-0.5, L)
    ax1.set_ylim(-0.5, L)
    ax1.set_aspect('equal')

    # Right: Syndrome pattern
    ax2 = axes[1]
    ax2.set_title('Syndrome (violated B_p plaquettes)', fontsize=12)

    for i in range(L):
        for j in range(L):
            ax2.plot([i, i+1], [j, j], 'b-', linewidth=1, alpha=0.3)
            ax2.plot([i, i], [j, j+1], 'b-', linewidth=1, alpha=0.3)

    # Mark violated plaquettes (endpoints of error string)
    violated = [(0.5, 0.5), (0.5, 1.5), (2.5, 0.5), (2.5, 1.5)]
    for px, py in violated:
        ax2.add_patch(plt.Rectangle((px-0.4, py-0.4), 0.8, 0.8,
                                     facecolor='red', alpha=0.5))
        ax2.text(px, py, 'm', ha='center', va='center', fontsize=12, fontweight='bold')

    ax2.set_xlim(-0.5, L)
    ax2.set_ylim(-0.5, L)
    ax2.set_aspect('equal')

    plt.tight_layout()
    plt.savefig('day_996_syndrome.png', dpi=150, bbox_inches='tight')
    plt.close()
    print("Saved syndrome visualization")

visualize_syndrome()

# =============================================================================
# Summary
# =============================================================================

print("\n" + "=" * 70)
print("Review Summary")
print("=" * 70)

print("""
Key Concepts Reviewed:
1. Pauli group P_n: 4×4^n elements, commute or anticommute
2. Stabilizer codes: S|ψ⟩ = |ψ⟩ for all s ∈ S
3. CSS codes: Combine classical codes, separate X and Z correction
4. Gottesman-Knill: Clifford circuits efficiently simulable
5. Toric code: [[2L², 2, L]], topological protection
6. Anyons: e (electric), m (magnetic), mutual statistics

Important Formulas:
- Code dimension: k = n - number of generators
- Toric code: A_v = ∏X_e, B_p = ∏Z_e
- Braiding phase: e around m → -1
""")

print("Review complete!")
```

---

## Summary Tables

### Stabilizer Code Comparison

| Code | [[n,k,d]] | Stabilizer Weight | Transversal Gates |
|------|-----------|-------------------|-------------------|
| 5-qubit | [[5,1,3]] | 4 | None universal |
| Steane | [[7,1,3]] | 4 | All Cliffords |
| Shor | [[9,1,3]] | 2,6 | Limited |
| Surface | [[d²,1,d]] | 4 | Limited |
| Toric | [[2L²,2,L]] | 4 | Limited |

### Topological Code Properties

| Property | Toric Code | Surface Code |
|----------|------------|--------------|
| Boundary | Periodic (torus) | Open |
| Logical qubits | 2 | 1 |
| Distance | L | d |
| Protection | Topological | Topological |
| Excitations | Anyons e, m | Anyons e, m |

### Gottesman-Knill Summary

| Ingredient | Simulable? |
|------------|------------|
| Clifford gates | Yes |
| Pauli measurements | Yes |
| Stabilizer states | Yes |
| Classical control | Yes |
| T gate | No |
| Magic states | No |
| Continuous rotations | No |

---

## Self-Assessment Checklist

### Stabilizer Formalism
- [ ] Can compute commutators of Pauli strings
- [ ] Can determine code parameters from stabilizers
- [ ] Can find logical operators for a stabilizer code
- [ ] Understand tableau representation

### CSS Codes
- [ ] Can construct CSS code from classical codes
- [ ] Know Steane code structure
- [ ] Understand transversal gate properties

### Topological Codes
- [ ] Can write toric code Hamiltionian
- [ ] Understand anyon types and fusion rules
- [ ] Can explain topological protection mechanism
- [ ] Know braiding statistics

---

## Preview: Day 997

Tomorrow we review **Surface Codes in depth**, covering:
- Surface codes with boundaries (planar codes)
- Lattice surgery for logical gates
- Decoding algorithms: MWPM, Union-Find
- Real-time decoding constraints
- Google Willow and IBM experimental results

---

*"Topology protects quantum information the way geography protects cities."*
--- Alexei Kitaev

---

**Next:** [Day_997_Wednesday.md](Day_997_Wednesday.md) - Surface Codes Review

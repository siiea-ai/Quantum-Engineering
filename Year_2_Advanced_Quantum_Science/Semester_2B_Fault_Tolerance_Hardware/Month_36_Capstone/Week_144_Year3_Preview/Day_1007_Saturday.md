# Day 1007: Capstone Project Completion

## Schedule Overview (7 hours)

| Session | Duration | Focus |
|---------|----------|-------|
| Morning | 3 hours | Project finalization, documentation |
| Afternoon | 2 hours | Presentation preparation, portfolio assembly |
| Evening | 2 hours | Final review, submission preparation |

## Learning Objectives

By the end of today, you will be able to:

1. **Complete** a comprehensive capstone project demonstrating Year 2 mastery
2. **Document** code, methods, and results to professional standards
3. **Present** project findings clearly and effectively
4. **Compile** a portfolio of Year 2 accomplishments
5. **Reflect** on the learning journey and growth
6. **Prepare** capstone deliverables for assessment

## Core Content

### 1. The Capstone Project Purpose

The Year 2 capstone project serves to:

- **Demonstrate mastery** of core concepts from Year 2
- **Integrate knowledge** across QEC, fault tolerance, hardware, and algorithms
- **Show research capability** through independent work
- **Prepare for Year 3** by practicing research-style investigation
- **Build portfolio** for qualifying exam and beyond

$$\boxed{\text{Capstone} = \text{Integration} + \text{Originality} + \text{Documentation}}$$

### 2. Capstone Project Options

Choose one of these project types:

#### Option A: QLDPC Code Implementation and Analysis

**Objective:** Implement and analyze a quantum LDPC code

**Components:**
1. Implement a simple QLDPC code construction
2. Compare with surface code of similar size
3. Analyze threshold under various noise models
4. Benchmark decoder performance

**Deliverables:**
- Working code implementation
- Comparison plots and analysis
- Written report (5-10 pages)
- Presentation slides (15-20 slides)

#### Option B: Variational Algorithm Benchmarking

**Objective:** Compare VQE/QAOA across simulated platforms

**Components:**
1. Implement VQE for a specific Hamiltonian
2. Test multiple ansatz structures
3. Compare noise effects across platform models
4. Analyze resource requirements

**Deliverables:**
- Complete simulation code
- Performance comparison data
- Analysis report (5-10 pages)
- Presentation slides (15-20 slides)

#### Option C: Literature Review and Research Proposal

**Objective:** Comprehensive review with original proposal

**Components:**
1. Systematic review of 20+ papers on chosen topic
2. Synthesis of current state and gaps
3. Original research proposal
4. Feasibility analysis

**Deliverables:**
- Annotated bibliography
- Literature review (10-15 pages)
- Research proposal (5-8 pages)
- Presentation slides (15-20 slides)

#### Option D: Hardware-Specific QEC Analysis

**Objective:** Analyze error correction on specific hardware platform

**Components:**
1. Characterize noise model for chosen platform
2. Analyze code performance under platform constraints
3. Propose optimizations
4. Benchmark on simulated/real data

**Deliverables:**
- Noise model and analysis
- Performance simulations
- Optimization recommendations
- Report and presentation

### 3. Project Documentation Standards

Professional documentation is essential:

#### Code Documentation

**README.md Template:**
```markdown
# [Project Title]

## Overview
[Brief description of project]

## Installation
```bash
pip install -r requirements.txt
```

## Usage
```python
from project import main_function
result = main_function(parameters)
```

## Project Structure
```
project/
├── src/           # Source code
├── tests/         # Unit tests
├── data/          # Data files
├── figures/       # Generated figures
└── docs/          # Documentation
```

## Results
[Summary of key findings]

## Author
[Your name, date]
```

**Code Style:**
- Clear function names
- Comprehensive docstrings
- Type hints where helpful
- Comments explaining complex logic
- Consistent formatting (PEP 8)

#### Written Report Structure

**Title Page:**
- Project title
- Author name
- Date
- Course/Program identifier

**Abstract (200-300 words):**
- Problem statement
- Approach
- Key findings
- Conclusions

**Table of Contents**

**1. Introduction (1-2 pages):**
- Background and motivation
- Problem statement
- Objectives
- Report structure

**2. Background (2-3 pages):**
- Relevant theory
- Prior work
- Key concepts

**3. Methodology (2-3 pages):**
- Approach description
- Implementation details
- Tools and resources used

**4. Results (2-3 pages):**
- Findings presentation
- Figures and tables
- Analysis

**5. Discussion (1-2 pages):**
- Interpretation of results
- Comparison with expectations
- Limitations
- Future work

**6. Conclusions (0.5-1 page):**
- Summary of contributions
- Key takeaways

**References**

**Appendices (as needed):**
- Additional data
- Code listings
- Supplementary figures

### 4. Presentation Guidelines

**Slide Structure (15-20 slides):**

| Slide(s) | Content | Time |
|----------|---------|------|
| 1 | Title slide | 30 sec |
| 2-3 | Motivation and background | 2 min |
| 4-5 | Problem statement and objectives | 2 min |
| 6-9 | Methodology | 4 min |
| 10-14 | Results and analysis | 5 min |
| 15-17 | Discussion | 3 min |
| 18-19 | Conclusions and future work | 2 min |
| 20 | Questions | - |
| **Total** | | **~20 min** |

**Presentation Tips:**
- One main idea per slide
- Minimal text, more figures
- Practice timing
- Prepare for questions
- Have backup slides for details

### 5. Portfolio Compilation

Your Year 2 portfolio documents your journey:

#### Portfolio Contents

**1. Learning Documentation:**
- Daily study logs (sample)
- Problem sets completed
- Lab notebooks/code

**2. Projects and Assignments:**
- Week-end projects
- Monthly assessments
- Capstone project

**3. Skills Demonstration:**
- Code samples
- Derivations and proofs
- Analysis examples

**4. Growth Evidence:**
- Early vs. late work comparison
- Improvement trajectory
- Self-assessments

**5. Research Preparation:**
- Literature reviews
- Research proposal draft
- Direction statement

#### Portfolio Organization

```
Year_2_Portfolio/
├── 01_Overview/
│   ├── curriculum_summary.md
│   └── learning_objectives.md
├── 02_Semester_2A_QEC/
│   ├── key_concepts.md
│   ├── problem_samples/
│   └── projects/
├── 03_Semester_2B_FT_Hardware/
│   ├── key_concepts.md
│   ├── problem_samples/
│   └── projects/
├── 04_Capstone/
│   ├── project_report.pdf
│   ├── presentation.pdf
│   └── code/
├── 05_Research_Preparation/
│   ├── literature_review.md
│   ├── proposal_draft.md
│   └── direction_statement.md
└── 06_Self_Assessment/
    ├── skills_inventory.md
    ├── growth_reflection.md
    └── year3_goals.md
```

### 6. Assessment Rubric

**Capstone Grading Criteria:**

| Component | Weight | Criteria |
|-----------|--------|----------|
| **Technical Correctness** | 30% | Methods properly implemented and applied |
| **Depth of Analysis** | 25% | Thorough investigation, not superficial |
| **Presentation Quality** | 20% | Clear writing, good figures, organized |
| **Originality** | 15% | Creative approaches, novel insights |
| **Connection to Field** | 10% | Links to broader research context |

**Score Interpretation:**
- 90-100%: Exceptional - publishable quality
- 80-89%: Excellent - strong PhD-level work
- 70-79%: Good - meets expectations
- 60-69%: Adequate - some weaknesses
- Below 60%: Needs improvement

### 7. Capstone Project: Sample Implementation

Below is a sample capstone project structure for Option A:

```python
"""
Year 2 Capstone Project: QLDPC Code Analysis
Comparing quantum LDPC codes with surface codes
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple, Dict
from dataclasses import dataclass
import stim

# =============================================================================
# Part 1: Code Definitions
# =============================================================================

@dataclass
class QuantumCode:
    """Base class for quantum error correction codes."""
    n: int  # physical qubits
    k: int  # logical qubits
    d: int  # distance

    def encoding_rate(self) -> float:
        """Calculate encoding rate k/n."""
        return self.k / self.n

    def overhead(self) -> float:
        """Calculate overhead n/k."""
        return self.n / self.k

class SurfaceCode(QuantumCode):
    """Surface code implementation."""

    def __init__(self, distance: int):
        n = 2 * distance**2 - 1  # data + ancilla
        k = 1
        super().__init__(n, k, distance)
        self.L = distance

    def stabilizers(self) -> List[str]:
        """Generate stabilizer generators (simplified)."""
        # Placeholder for full implementation
        return [f"X stabilizers: {self.L**2 - 1}",
                f"Z stabilizers: {self.L**2 - 1}"]

class SimpleQLDPCCode(QuantumCode):
    """Simplified QLDPC code for demonstration."""

    def __init__(self, n: int, k: int, d: int, row_weight: int):
        super().__init__(n, k, d)
        self.row_weight = row_weight

    def check_LDPC_property(self) -> bool:
        """Verify LDPC property (low row weight)."""
        return self.row_weight <= np.log2(self.n)

# =============================================================================
# Part 2: Noise Model and Simulation
# =============================================================================

class NoiseModel:
    """Depolarizing noise model for simulation."""

    def __init__(self, p: float):
        """Initialize with error probability p."""
        self.p = p

    def apply_to_qubit(self) -> str:
        """Apply noise to single qubit, return error type."""
        r = np.random.random()
        if r < self.p / 3:
            return 'X'
        elif r < 2 * self.p / 3:
            return 'Y'
        elif r < self.p:
            return 'Z'
        else:
            return 'I'

def simulate_code_performance(code: QuantumCode,
                             error_rates: List[float],
                             shots: int = 10000) -> Dict[str, List[float]]:
    """
    Simulate logical error rate vs physical error rate.

    This is a simplified simulation for demonstration.
    Full implementation would use proper syndrome extraction and decoding.
    """
    logical_error_rates = []

    for p in error_rates:
        logical_errors = 0

        for _ in range(shots):
            # Simplified model: logical error if >= d/2 errors occur
            num_errors = np.sum(np.random.random(code.n) < p)
            if num_errors >= code.d / 2:
                logical_errors += 1

        logical_error_rates.append(logical_errors / shots)

    return {
        'physical': error_rates,
        'logical': logical_error_rates
    }

# =============================================================================
# Part 3: Comparison Analysis
# =============================================================================

def compare_codes(distances: List[int],
                 error_rates: List[float],
                 shots: int = 5000):
    """Compare surface code with QLDPC code."""

    results = {
        'surface': {},
        'qldpc': {}
    }

    for d in distances:
        # Surface code
        surface = SurfaceCode(d)
        surface_results = simulate_code_performance(
            surface, error_rates, shots)
        results['surface'][d] = {
            'code': surface,
            'results': surface_results
        }

        # QLDPC code (simplified parameters)
        # In reality, QLDPC codes have better k scaling
        n_qldpc = d**2  # Simplified
        k_qldpc = max(1, d // 2)  # Better rate
        qldpc = SimpleQLDPCCode(n_qldpc, k_qldpc, d, row_weight=6)
        qldpc_results = simulate_code_performance(
            qldpc, error_rates, shots)
        results['qldpc'][d] = {
            'code': qldpc,
            'results': qldpc_results
        }

    return results

def visualize_comparison(results: Dict, distances: List[int]):
    """Create comparison visualizations."""

    fig, axes = plt.subplots(2, 2, figsize=(14, 12))

    # Plot 1: Logical error rate comparison for each distance
    ax1 = axes[0, 0]
    colors = plt.cm.viridis(np.linspace(0, 1, len(distances)))

    for i, d in enumerate(distances):
        surface_data = results['surface'][d]['results']
        qldpc_data = results['qldpc'][d]['results']

        ax1.semilogy(surface_data['physical'], surface_data['logical'],
                    'o-', color=colors[i], label=f'Surface d={d}')
        ax1.semilogy(qldpc_data['physical'], qldpc_data['logical'],
                    's--', color=colors[i], label=f'QLDPC d={d}')

    ax1.set_xlabel('Physical Error Rate')
    ax1.set_ylabel('Logical Error Rate')
    ax1.set_title('Logical Error Rate Comparison')
    ax1.legend(fontsize=8)
    ax1.grid(True, alpha=0.3)

    # Plot 2: Overhead comparison
    ax2 = axes[0, 1]
    surface_overhead = [results['surface'][d]['code'].overhead()
                       for d in distances]
    qldpc_overhead = [results['qldpc'][d]['code'].overhead()
                     for d in distances]

    x = np.arange(len(distances))
    width = 0.35
    ax2.bar(x - width/2, surface_overhead, width, label='Surface Code',
           color='steelblue', alpha=0.7)
    ax2.bar(x + width/2, qldpc_overhead, width, label='QLDPC Code',
           color='coral', alpha=0.7)
    ax2.set_xticks(x)
    ax2.set_xticklabels([f'd={d}' for d in distances])
    ax2.set_ylabel('Overhead (n/k)')
    ax2.set_title('Qubit Overhead Comparison')
    ax2.legend()

    # Plot 3: Rate comparison
    ax3 = axes[1, 0]
    surface_rate = [results['surface'][d]['code'].encoding_rate()
                   for d in distances]
    qldpc_rate = [results['qldpc'][d]['code'].encoding_rate()
                 for d in distances]

    ax3.plot(distances, surface_rate, 'o-', label='Surface Code',
            color='steelblue', linewidth=2, markersize=8)
    ax3.plot(distances, qldpc_rate, 's-', label='QLDPC Code',
            color='coral', linewidth=2, markersize=8)
    ax3.set_xlabel('Distance')
    ax3.set_ylabel('Encoding Rate (k/n)')
    ax3.set_title('Encoding Rate vs Distance')
    ax3.legend()
    ax3.grid(True, alpha=0.3)

    # Plot 4: Summary statistics table
    ax4 = axes[1, 1]
    ax4.axis('off')

    # Create summary table
    table_data = []
    for d in distances:
        surface = results['surface'][d]['code']
        qldpc = results['qldpc'][d]['code']
        table_data.append([
            f'd={d}',
            f'{surface.n}',
            f'{qldpc.n}',
            f'{surface.encoding_rate():.4f}',
            f'{qldpc.encoding_rate():.4f}'
        ])

    table = ax4.table(
        cellText=table_data,
        colLabels=['Distance', 'Surface n', 'QLDPC n',
                  'Surface Rate', 'QLDPC Rate'],
        loc='center',
        cellLoc='center'
    )
    table.auto_set_font_size(False)
    table.set_fontsize(10)
    table.scale(1.2, 1.5)
    ax4.set_title('Code Parameters Comparison', fontsize=12, pad=20)

    plt.tight_layout()
    plt.savefig('capstone_code_comparison.png', dpi=150, bbox_inches='tight')
    plt.show()

    return fig

# =============================================================================
# Part 4: Report Generation
# =============================================================================

def generate_report(results: Dict, distances: List[int]) -> str:
    """Generate markdown report summary."""

    report = """# Year 2 Capstone Project Report
## QLDPC Code Analysis and Comparison with Surface Codes

### Abstract
This project analyzes quantum LDPC codes and compares their performance
with surface codes, the current leading candidate for fault-tolerant
quantum computing. We implement simplified models of both code families
and compare logical error rates, qubit overhead, and encoding rates.

### 1. Introduction
Quantum error correction is essential for fault-tolerant quantum computing.
Surface codes offer high thresholds (~1%) but require O(d^2) physical qubits
per logical qubit. QLDPC codes promise constant overhead while maintaining
good distance, potentially revolutionizing resource requirements.

### 2. Methods
We implemented simplified models of:
- Surface codes with distances {distances}
- QLDPC codes with comparable parameters

Simulations used depolarizing noise and simplified syndrome extraction.

### 3. Results
"""

    for d in distances:
        surface = results['surface'][d]['code']
        qldpc = results['qldpc'][d]['code']
        report += f"""
#### Distance {d}:
- Surface code: [[{surface.n}, {surface.k}, {surface.d}]], rate = {surface.encoding_rate():.4f}
- QLDPC code: [[{qldpc.n}, {qldpc.k}, {qldpc.d}]], rate = {qldpc.encoding_rate():.4f}
"""

    report += """
### 4. Discussion
The results demonstrate the potential advantage of QLDPC codes in encoding rate,
though practical implementation faces challenges in syndrome extraction locality.

### 5. Conclusions
QLDPC codes offer promising improvements in qubit efficiency, motivating
continued research into practical implementations.

### References
1. Panteleev & Kalachev, "Asymptotically Good QLDPC Codes" (2022)
2. Fowler et al., "Surface codes: Towards practical..." (2012)
"""

    return report

# =============================================================================
# Part 5: Main Execution
# =============================================================================

print("=" * 70)
print("Year 2 Capstone Project: QLDPC Code Analysis")
print("=" * 70)

# Parameters
distances = [3, 5, 7, 9]
error_rates = np.logspace(-3, -1, 20)
shots = 2000

print("\nRunning code comparison simulation...")
print(f"Distances: {distances}")
print(f"Error rates: {error_rates[0]:.4f} to {error_rates[-1]:.4f}")
print(f"Shots per configuration: {shots}")

# Run comparison
results = compare_codes(distances, list(error_rates), shots)

# Print summary
print("\n" + "=" * 70)
print("Simulation Results Summary")
print("=" * 70)

for d in distances:
    surface = results['surface'][d]['code']
    qldpc = results['qldpc'][d]['code']
    print(f"\nDistance {d}:")
    print(f"  Surface code: [[{surface.n}, {surface.k}, {surface.d}]]")
    print(f"    Rate: {surface.encoding_rate():.4f}, Overhead: {surface.overhead():.1f}x")
    print(f"  QLDPC code: [[{qldpc.n}, {qldpc.k}, {qldpc.d}]]")
    print(f"    Rate: {qldpc.encoding_rate():.4f}, Overhead: {qldpc.overhead():.1f}x")

# Generate report
print("\n" + "=" * 70)
print("Generating Report...")
print("=" * 70)
report = generate_report(results, distances)
print(report)

# Uncomment to generate visualizations:
# visualize_comparison(results, distances)

print("\n" + "=" * 70)
print("Capstone project simulation complete!")
print("=" * 70)
```

## Connections to Year 2 Knowledge

The capstone project integrates knowledge from across Year 2:

### From Semester 2A (Error Correction)
- Stabilizer code theory (foundation for all implementations)
- Surface code structure (comparison baseline)
- Threshold analysis methods
- Decoding concepts

### From Semester 2B (Fault Tolerance & Hardware)
- Resource estimation framework
- Hardware constraint awareness
- Algorithm implementation skills
- Performance benchmarking

### Integration Points

| Year 2 Topic | Capstone Application |
|--------------|---------------------|
| Stabilizer formalism | Code implementation |
| Surface codes | Baseline comparison |
| QLDPC codes | Novel analysis |
| Fault tolerance | Context and motivation |
| Hardware | Practical considerations |
| Algorithms | Simulation methods |

## Practical Exercises

### Exercise 1: Project Selection

Choose your capstone project and justify:

**Selected Option:** _______________________

**Justification (why this fits your interests and skills):**
_______________________

**Timeline for completion:**
| Task | Hours | Deadline |
|------|-------|----------|
| Implementation | | |
| Testing | | |
| Analysis | | |
| Documentation | | |
| Presentation | | |

### Exercise 2: Documentation Checklist

For your project, verify documentation completeness:

**Code Documentation:**
- [ ] README with setup instructions
- [ ] Clear function docstrings
- [ ] Comments on complex logic
- [ ] Example usage
- [ ] Test cases

**Written Report:**
- [ ] Abstract
- [ ] Introduction
- [ ] Background
- [ ] Methodology
- [ ] Results
- [ ] Discussion
- [ ] Conclusions
- [ ] References

**Presentation:**
- [ ] Title slide
- [ ] Motivation
- [ ] Methods
- [ ] Results
- [ ] Conclusions
- [ ] Questions slide

### Exercise 3: Portfolio Assembly

Compile your Year 2 portfolio:

**Contents Checklist:**
- [ ] Curriculum overview
- [ ] Semester 2A highlights
- [ ] Semester 2B highlights
- [ ] Key projects
- [ ] Capstone project
- [ ] Research preparation
- [ ] Self-assessment
- [ ] Year 3 goals

### Exercise 4: Reflection

Write a 500-word reflection on your Year 2 journey:

**Topics to address:**
- What were the most challenging topics?
- What were the most rewarding moments?
- How has your understanding evolved?
- What would you do differently?
- How are you prepared for Year 3?

## Summary

### Key Concepts

| Concept | Description |
|---------|-------------|
| Capstone Project | Integration demonstration |
| Documentation | Professional code and writing |
| Presentation | Clear communication of results |
| Portfolio | Evidence of Year 2 learning |
| Assessment | Evaluation against rubric |

### Project Checklist

```
Before Submission:
[ ] Code runs without errors
[ ] All tests pass
[ ] Documentation complete
[ ] Report formatted properly
[ ] Figures clear and labeled
[ ] Presentation practiced
[ ] Portfolio compiled
```

### Main Takeaways

1. **The capstone demonstrates integration** - it's not about any single topic

2. **Documentation matters as much as code** - others must understand your work

3. **Quality over quantity** - depth beats breadth in a capstone

4. **The portfolio tells your story** - curate it thoughtfully

5. **This prepares you for research** - the same skills apply in Year 3+

## Daily Checklist

- [ ] I have finalized my capstone project
- [ ] All code is documented and tested
- [ ] The written report is complete
- [ ] Presentation slides are prepared
- [ ] My portfolio is compiled
- [ ] I have reflected on my Year 2 journey
- [ ] All deliverables are ready for submission
- [ ] I am prepared for Day 1008's celebration

## Preview: Day 1008

Tomorrow is the **final day of Year 2**. We will:
- Celebrate the completion of 336 days of Year 2
- Review the journey from Day 673 to Day 1008
- Complete the Year 2 exit assessment
- Finalize preparation for Year 3
- Transition from student to researcher

Tomorrow marks a major milestone. Be proud of what you've accomplished.

---

*"A capstone is not the end of learning - it's proof that you've learned enough to start contributing. The real work begins now."*

---

| Navigation | Link |
|------------|------|
| Previous Day | [Day 1006: Research Directions](./Day_1006_Friday.md) |
| Next Day | [Day 1008: Year 2 Conclusion](./Day_1008_Sunday.md) |
| Week Overview | [Week 144 README](./README.md) |

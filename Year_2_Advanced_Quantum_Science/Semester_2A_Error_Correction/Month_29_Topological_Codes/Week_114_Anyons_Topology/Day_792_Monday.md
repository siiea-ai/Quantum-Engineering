# Day 792: Anyonic Excitations Introduction

## Year 2, Semester 2A: Quantum Error Correction
### Month 29: Topological Codes | Week 114: Anyons & Topological Order

---

## Schedule Overview

| Time Block | Duration | Focus |
|------------|----------|-------|
| Morning | 3 hours | Quasiparticles and exchange statistics theory |
| Afternoon | 2.5 hours | Problem solving: anyonic systems |
| Evening | 1.5 hours | Computational lab: visualizing anyon statistics |

---

## Learning Objectives

By the end of today, you will be able to:

1. Define quasiparticles and explain their emergence in many-body systems
2. Derive why particle exchange statistics depend on spatial dimension
3. Distinguish bosons, fermions, and anyons through exchange phases
4. Connect stabilizer violations to anyonic excitations in the toric code
5. Identify the four particle types in the toric code: 1, e, m, ε
6. Explain the topological protection of anyonic properties

---

## Core Content

### 1. Quasiparticles in Condensed Matter Systems

In many-body quantum systems, the low-energy excitations often behave as effective particles called **quasiparticles**. These emergent entities carry well-defined quantum numbers and can be created, moved, and annihilated, even though they are collective excitations of the underlying microscopic degrees of freedom.

#### Definition of Quasiparticles

A quasiparticle is a localized excitation above a ground state that:
- Has well-defined energy and momentum
- Maintains its identity under adiabatic evolution
- Can be characterized by local quantum numbers

**Mathematical Characterization**:

Consider a ground state $|\Omega\rangle$. A quasiparticle at position $\mathbf{r}$ is created by:
$$|\psi_\mathbf{r}\rangle = \hat{\phi}^\dagger(\mathbf{r})|\Omega\rangle$$

where $\hat{\phi}^\dagger(\mathbf{r})$ is a local creation operator.

#### Examples Across Physics

| System | Quasiparticle | Properties |
|--------|---------------|------------|
| Metals | Electrons/holes | Fermionic, charge ±e |
| Superconductors | Bogoliubov quasiparticles | Mixed electron-hole |
| Magnets | Magnons | Bosonic spin waves |
| Fractional QHE | Composite fermions | Fractional charge |
| Toric Code | Anyons | Exotic statistics |

### 2. Exchange Statistics in Quantum Mechanics

#### The Spin-Statistics Connection (3D)

In three-dimensional space, the exchange of two identical particles is topologically trivial—any exchange path can be continuously deformed to the identity. This leads to only two possibilities:

**Bosons**: Exchange gives phase +1
$$|\psi_{12}\rangle = |\psi_{21}\rangle$$

**Fermions**: Exchange gives phase −1
$$|\psi_{12}\rangle = -|\psi_{21}\rangle$$

The mathematical reason: The fundamental group of the configuration space is:
$$\pi_1(\text{Config}_2(\mathbb{R}^3)) = \mathbb{Z}_2$$

This group has only two one-dimensional representations: trivial (+1) and sign (−1).

#### The 2D Revolution: Braid Group

In two dimensions, particle worldlines in (2+1)D spacetime form **braids**. Two exchanges are not equivalent to no exchange—they produce a double braid that cannot be untangled!

$$\pi_1(\text{Config}_2(\mathbb{R}^2)) = \mathbb{Z}$$

The infinite cyclic group $\mathbb{Z}$ has infinitely many one-dimensional representations:
$$\sigma \mapsto e^{i\theta}$$

for any angle $\theta \in [0, 2\pi)$.

#### Anyons: Particles with Any Statistics

**Definition**: An anyon is a quasiparticle in 2D whose exchange gives a phase $e^{i\theta}$ with $\theta \notin \{0, \pi\}$.

$$\boxed{|\psi_{12}\rangle = e^{i\theta}|\psi_{21}\rangle}$$

**Terminology**:
- $\theta = 0$: Boson
- $\theta = \pi$: Fermion
- $\theta = \pi/2$: Semion
- $0 < \theta < \pi$: Abelian anyon

### 3. The Braid Group Formalism

#### Generators and Relations

For $n$ particles, the braid group $B_n$ is generated by exchanges $\sigma_i$ (exchange particles $i$ and $i+1$):

**Defining Relations**:
$$\sigma_i \sigma_j = \sigma_j \sigma_i \quad \text{for } |i-j| \geq 2$$
$$\sigma_i \sigma_{i+1} \sigma_i = \sigma_{i+1} \sigma_i \sigma_{i+1}$$

The second relation is the **Yang-Baxter equation**, essential for consistent braiding.

#### Abelian vs Non-Abelian Anyons

**Abelian Anyons**: All braiding operations commute. The state space for $n$ anyons is one-dimensional.
$$\sigma_i |\psi\rangle = e^{i\theta} |\psi\rangle$$

**Non-Abelian Anyons**: Braiding operations are represented by matrices that don't commute. The state space is degenerate.
$$\sigma_i |\psi_a\rangle = \sum_b [R_i]_{ab} |\psi_b\rangle$$

The toric code hosts **Abelian anyons**; non-Abelian anyons appear in the ν = 5/2 FQHE state.

### 4. Stabilizer Violations as Anyonic Excitations

Recall from Week 113 that the toric code Hamiltonian is:
$$H = -\sum_v A_v - \sum_p B_p$$

where stabilizers are:
$$A_v = \prod_{e \ni v} Z_e, \qquad B_p = \prod_{e \in \partial p} X_e$$

#### Ground State Characterization

The ground state $|\Omega\rangle$ satisfies:
$$A_v |\Omega\rangle = +|\Omega\rangle \quad \forall v$$
$$B_p |\Omega\rangle = +|\Omega\rangle \quad \forall p$$

#### Excited States: Stabilizer Violations

An **excitation** occurs when a stabilizer has eigenvalue −1:

| Violation | Stabilizer | Particle Type | Name |
|-----------|------------|---------------|------|
| $A_v = -1$ | Star operator | e-particle | Electric charge |
| $B_p = -1$ | Plaquette operator | m-particle | Magnetic flux |
| Both at same location | $A_v = B_p = -1$ | ε-particle | Fermion |

### 5. The Four Particle Types of Toric Code

The toric code has exactly four distinct particle types forming a group under fusion:

$$\mathcal{A} = \{1, e, m, \varepsilon\} \cong \mathbb{Z}_2 \times \mathbb{Z}_2$$

#### The Vacuum (1)

The trivial particle type. No stabilizer violations.
- Self-statistics: Trivial (bosonic)
- Can be created from vacuum: Yes (no cost)

#### Electric Charge (e)

Created by violating star operators ($A_v = -1$).
- Always created in pairs at string endpoints
- Self-statistics: Bosonic ($\theta_{ee} = 0$)
- Energy cost: 2 (per particle)

#### Magnetic Flux (m)

Created by violating plaquette operators ($B_p = -1$).
- Always created in pairs at string endpoints
- Self-statistics: Bosonic ($\theta_{mm} = 0$)
- Energy cost: 2 (per particle)

#### Epsilon Fermion (ε)

Bound state of e and m located at the same site.
- Self-statistics: Fermionic ($\theta_{\varepsilon\varepsilon} = \pi$)
- Composite nature: $\varepsilon = e \times m$
- Remarkable emergence of fermion from bosons!

### 6. Topological Protection of Anyonic Properties

The statistical properties of anyons are **topologically protected**: they cannot be changed by local perturbations.

#### Why Local Operations Cannot Change Statistics

Consider adding a perturbation $V = \sum_i V_i$ where each $V_i$ acts on a finite region. The braiding phase acquired when anyon $a$ circles anyon $b$ depends only on:

1. The topological class of the path (number of windings)
2. The anyon types involved

It does **not** depend on:
- The exact path taken
- The shape of the anyons
- Local details of the Hamiltonian

This is because the phase is determined by the **global monodromy** of the wave function, which is a topological invariant.

#### Mathematical Statement

Let $U_\gamma$ be the unitary implementing adiabatic transport along path $\gamma$. For topologically equivalent paths $\gamma \sim \gamma'$:
$$U_\gamma = U_{\gamma'} \cdot (\text{dynamical phase})$$

The statistical phase is the difference from the dynamical phase and depends only on topology.

---

## Quantum Computing Connection

### Anyons as Natural Qubits

The topological protection of anyonic properties makes them ideal for fault-tolerant quantum computing:

1. **Noise Immunity**: Local perturbations cannot change the quantum information encoded in anyon positions
2. **Gate by Braiding**: Quantum gates are implemented by physically moving anyons around each other
3. **Measurement by Fusion**: Readout occurs by bringing anyons together and observing their fusion outcome

### The Toric Code Paradigm

While the toric code's Abelian anyons cannot perform universal quantum computation through braiding alone, they provide:
- Natural implementation of logical qubits (ground state degeneracy)
- Error correction through syndrome measurement
- Foundation for understanding more exotic non-Abelian systems

---

## Worked Examples

### Example 1: Counting Anyon Types from Group Theory

**Problem**: Show that a system with $\mathbb{Z}_2$ gauge structure has exactly 4 anyon types.

**Solution**:

For a discrete gauge theory with gauge group $G$, the anyon types are classified by:
$$\mathcal{A} = G \times \hat{G}$$

where $\hat{G}$ is the group of irreducible representations (characters) of $G$.

For $G = \mathbb{Z}_2$:
- Elements: $\{0, 1\}$ (or $\{1, -1\}$ multiplicatively)
- Characters: $\hat{\mathbb{Z}}_2 = \{1, \epsilon\}$ where $\epsilon(g) = (-1)^g$

Therefore:
$$\mathcal{A} = \mathbb{Z}_2 \times \mathbb{Z}_2 = \{(0,1), (0,\epsilon), (1,1), (1,\epsilon)\}$$

Identifying:
- $(0, 1) \to 1$ (vacuum)
- $(1, 1) \to e$ (charge)
- $(0, \epsilon) \to m$ (flux)
- $(1, \epsilon) \to \varepsilon$ (fermion)

$$\boxed{|\mathcal{A}| = |G| \cdot |\hat{G}| = 2 \cdot 2 = 4}$$

### Example 2: Verifying the Braid Group Relation

**Problem**: Verify that the Yang-Baxter equation $\sigma_1 \sigma_2 \sigma_1 = \sigma_2 \sigma_1 \sigma_2$ is satisfied for Abelian anyons with exchange phase $e^{i\theta}$.

**Solution**:

For Abelian anyons, each $\sigma_i$ acts as multiplication by $e^{i\theta}$.

Left side:
$$\sigma_1 \sigma_2 \sigma_1 |\psi\rangle = e^{i\theta} \cdot e^{i\theta} \cdot e^{i\theta} |\psi\rangle = e^{3i\theta} |\psi\rangle$$

Right side:
$$\sigma_2 \sigma_1 \sigma_2 |\psi\rangle = e^{i\theta} \cdot e^{i\theta} \cdot e^{i\theta} |\psi\rangle = e^{3i\theta} |\psi\rangle$$

Since both sides equal $e^{3i\theta}|\psi\rangle$:
$$\boxed{\sigma_1 \sigma_2 \sigma_1 = \sigma_2 \sigma_1 \sigma_2 \quad \checkmark}$$

For non-Abelian anyons, this becomes a non-trivial matrix equation.

### Example 3: Energy of Anyon Configurations

**Problem**: Calculate the energy of a state with 2 e-particles and 2 m-particles in the toric code.

**Solution**:

The toric code Hamiltonian:
$$H = -\sum_v A_v - \sum_p B_p$$

Ground state energy (all stabilizers = +1):
$$E_0 = -N_v - N_p$$

where $N_v$ is the number of vertices and $N_p$ is the number of plaquettes.

With excitations:
- Each e-particle: One vertex has $A_v = -1$ instead of $+1$, contributing $+1$ instead of $-1$
- Energy cost per e-particle: $\Delta E_e = 2$

- Each m-particle: One plaquette has $B_p = -1$ instead of $+1$
- Energy cost per m-particle: $\Delta E_m = 2$

Total energy:
$$E = E_0 + 2 \cdot \Delta E_e + 2 \cdot \Delta E_m = E_0 + 2(2) + 2(2) = E_0 + 8$$

$$\boxed{\Delta E_{\text{total}} = 8}$$

---

## Practice Problems

### Direct Application

**Problem 1**: The Configuration Space Argument
Show that for two distinguishable particles in 3D, the configuration space is $\mathbb{R}^6$ minus a 3D subspace (where particles coincide). Explain why this has trivial fundamental group.

**Problem 2**: Anyon Phase Accumulation
An anyon with exchange phase $\theta = 2\pi/5$ is exchanged with an identical anyon 7 times. What is the total accumulated phase? Express in the range $[0, 2\pi)$.

**Problem 3**: Stabilizer Counting
On a toric code with $L \times L$ lattice (periodic boundaries), how many independent star operators are there? How many plaquette operators? (Hint: there's a constraint.)

### Intermediate

**Problem 4**: The Semion
A semion has exchange phase $\theta = \pi/2$.
(a) What is the self-statistics phase when two semions are exchanged?
(b) What happens when a semion is rotated by $2\pi$ (brought around itself)?
(c) Is a semion its own antiparticle?

**Problem 5**: Non-Abelian Representation Dimension
For Fibonacci anyons, the fusion rule is $\tau \times \tau = 1 + \tau$. If you have $n$ such anyons, the dimension of the state space grows as $\phi^n$ where $\phi$ is the golden ratio. Verify this for $n = 4, 5, 6$ by iterating the fusion.

**Problem 6**: Locality and Stabilizers
Prove that for any local operator $O$ acting on a finite region of the toric code, if that region doesn't contain the anyons, then $O$ commutes with the anyon creation operators at leading order.

### Challenging

**Problem 7**: Dimension of Braid Group Representations
For the braid group $B_3$ (three strands), the group is generated by $\sigma_1, \sigma_2$ with relation $\sigma_1\sigma_2\sigma_1 = \sigma_2\sigma_1\sigma_2$. Find all irreducible representations up to dimension 2.

**Problem 8**: Anyonic Entropy
Consider $n$ pairs of e-particles on a plane. Each pair must eventually fuse to vacuum. How many topologically distinct ways are there to pair them up? Relate this to the Catalan numbers.

---

## Computational Lab: Visualizing Anyon Statistics

```python
"""
Day 792 Computational Lab: Visualizing Anyon Statistics
Demonstrates the topological distinction between 2D and 3D particle exchange
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from matplotlib.patches import FancyArrowPatch
from mpl_toolkits.mplot3d.proj3d import proj_transform

class Arrow3D(FancyArrowPatch):
    """3D arrow for visualization"""
    def __init__(self, xs, ys, zs, *args, **kwargs):
        super().__init__((0,0), (0,0), *args, **kwargs)
        self._verts3d = xs, ys, zs

    def draw(self, renderer):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj_transform(xs3d, ys3d, zs3d, self.axes.M)
        self.set_positions((xs[0],ys[0]),(xs[1],ys[1]))
        super().draw(renderer)

    def do_3d_projection(self, renderer=None):
        xs3d, ys3d, zs3d = self._verts3d
        xs, ys, zs = proj_transform(xs3d, ys3d, zs3d, self.axes.M)
        self.set_positions((xs[0],ys[0]),(xs[1],ys[1]))
        return np.min(zs)

def exchange_path_2d(t, clockwise=True):
    """
    Generate 2D exchange path for two particles
    Particles at (-1, 0) and (1, 0) exchange via semicircular paths
    """
    sign = -1 if clockwise else 1
    # Particle 1: starts at (-1, 0), ends at (1, 0)
    x1 = np.cos(np.pi - sign * np.pi * t)
    y1 = sign * np.sin(np.pi * t)

    # Particle 2: starts at (1, 0), ends at (-1, 0)
    x2 = np.cos(sign * np.pi * t)
    y2 = -sign * np.sin(np.pi * t)

    return (x1, y1), (x2, y2)

def exchange_path_3d(t, over=True):
    """
    Generate 3D exchange path - can go over or under
    In 3D, these paths are topologically equivalent!
    """
    # Particle 1
    x1 = np.cos(np.pi - np.pi * t)
    y1 = 0
    z1 = (0.5 if over else -0.5) * np.sin(np.pi * t)

    # Particle 2
    x2 = np.cos(np.pi * t)
    y2 = 0
    z2 = (-0.5 if over else 0.5) * np.sin(np.pi * t)

    return (x1, y1, z1), (x2, y2, z2)

def visualize_2d_exchange():
    """Visualize non-equivalent exchanges in 2D"""
    fig, axes = plt.subplots(1, 2, figsize=(12, 5))

    t_vals = np.linspace(0, 1, 100)

    for idx, (clockwise, title) in enumerate([(True, 'Clockwise Exchange (σ)'),
                                                (False, 'Counter-clockwise (σ⁻¹)')]):
        ax = axes[idx]

        # Plot exchange paths
        path1_x, path1_y = [], []
        path2_x, path2_y = [], []
        for t in t_vals:
            p1, p2 = exchange_path_2d(t, clockwise)
            path1_x.append(p1[0])
            path1_y.append(p1[1])
            path2_x.append(p2[0])
            path2_y.append(p2[1])

        ax.plot(path1_x, path1_y, 'b-', linewidth=2, label='Particle 1')
        ax.plot(path2_x, path2_y, 'r-', linewidth=2, label='Particle 2')

        # Mark start and end positions
        ax.scatter([-1, 1], [0, 0], c=['blue', 'red'], s=100, zorder=5,
                   edgecolors='black', linewidths=2)
        ax.scatter([1, -1], [0, 0], c=['blue', 'red'], s=100, zorder=5,
                   marker='s', edgecolors='black', linewidths=2, alpha=0.5)

        # Add arrows to show direction
        mid_idx = len(t_vals) // 2
        ax.annotate('', xy=(path1_x[mid_idx+5], path1_y[mid_idx+5]),
                    xytext=(path1_x[mid_idx-5], path1_y[mid_idx-5]),
                    arrowprops=dict(arrowstyle='->', color='blue', lw=2))
        ax.annotate('', xy=(path2_x[mid_idx+5], path2_y[mid_idx+5]),
                    xytext=(path2_x[mid_idx-5], path2_y[mid_idx-5]),
                    arrowprops=dict(arrowstyle='->', color='red', lw=2))

        ax.set_xlim(-1.5, 1.5)
        ax.set_ylim(-1.2, 1.2)
        ax.set_aspect('equal')
        ax.set_title(title, fontsize=14)
        ax.legend()
        ax.grid(True, alpha=0.3)
        ax.set_xlabel('x')
        ax.set_ylabel('y')

    fig.suptitle('2D Exchange: σ and σ⁻¹ are NOT equivalent!', fontsize=16)
    plt.tight_layout()
    plt.savefig('exchange_2d.png', dpi=150, bbox_inches='tight')
    plt.show()

def visualize_3d_exchange():
    """Visualize equivalent exchanges in 3D"""
    fig = plt.figure(figsize=(14, 5))

    t_vals = np.linspace(0, 1, 100)

    for idx, (over, title) in enumerate([(True, '3D Exchange (over)'),
                                          (False, '3D Exchange (under)')]):
        ax = fig.add_subplot(1, 3, idx + 1, projection='3d')

        path1_x, path1_y, path1_z = [], [], []
        path2_x, path2_y, path2_z = [], [], []
        for t in t_vals:
            p1, p2 = exchange_path_3d(t, over)
            path1_x.append(p1[0])
            path1_y.append(p1[1])
            path1_z.append(p1[2])
            path2_x.append(p2[0])
            path2_y.append(p2[1])
            path2_z.append(p2[2])

        ax.plot(path1_x, path1_y, path1_z, 'b-', linewidth=2, label='Particle 1')
        ax.plot(path2_x, path2_y, path2_z, 'r-', linewidth=2, label='Particle 2')

        # Start positions
        ax.scatter([-1], [0], [0], c='blue', s=100, marker='o')
        ax.scatter([1], [0], [0], c='red', s=100, marker='o')

        ax.set_xlabel('x')
        ax.set_ylabel('y')
        ax.set_zlabel('z')
        ax.set_title(title, fontsize=12)
        ax.legend()

    # Third panel: Show equivalence
    ax = fig.add_subplot(1, 3, 3, projection='3d')

    # Draw both paths (showing they can be deformed into each other)
    for over, color, alpha in [(True, 'blue', 0.7), (False, 'green', 0.7)]:
        path_x, path_y, path_z = [], [], []
        for t in t_vals:
            p1, _ = exchange_path_3d(t, over)
            path_x.append(p1[0])
            path_y.append(p1[1])
            path_z.append(p1[2])
        ax.plot(path_x, path_y, path_z, color=color, linewidth=2, alpha=alpha)

    # Draw interpolating paths
    for frac in [0.25, 0.5, 0.75]:
        path_x, path_y, path_z = [], [], []
        for t in t_vals:
            p1_over, _ = exchange_path_3d(t, True)
            p1_under, _ = exchange_path_3d(t, False)
            x = (1-frac) * p1_over[0] + frac * p1_under[0]
            y = (1-frac) * p1_over[1] + frac * p1_under[1]
            z = (1-frac) * p1_over[2] + frac * p1_under[2]
            path_x.append(x)
            path_y.append(y)
            path_z.append(z)
        ax.plot(path_x, path_y, path_z, 'gray', linewidth=1, alpha=0.5)

    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_zlabel('z')
    ax.set_title('Continuous Deformation', fontsize=12)

    fig.suptitle('3D Exchange: Over and Under ARE equivalent!', fontsize=16)
    plt.tight_layout()
    plt.savefig('exchange_3d.png', dpi=150, bbox_inches='tight')
    plt.show()

def anyonic_phase_accumulation():
    """Demonstrate phase accumulation for different anyon types"""
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    n_exchanges = np.arange(0, 13)

    anyon_types = [
        ('Boson', 0, 'blue'),
        ('Fermion', np.pi, 'red'),
        ('Semion', np.pi/2, 'green'),
        ('θ = 2π/5', 2*np.pi/5, 'purple'),
    ]

    # Plot 1: Phase vs number of exchanges
    ax = axes[0]
    for name, theta, color in anyon_types:
        phases = (n_exchanges * theta) % (2 * np.pi)
        ax.plot(n_exchanges, phases, 'o-', color=color, label=name, markersize=8)

    ax.set_xlabel('Number of Exchanges', fontsize=12)
    ax.set_ylabel('Accumulated Phase (mod 2π)', fontsize=12)
    ax.set_title('Phase Accumulation', fontsize=14)
    ax.legend()
    ax.set_yticks([0, np.pi/2, np.pi, 3*np.pi/2, 2*np.pi])
    ax.set_yticklabels(['0', 'π/2', 'π', '3π/2', '2π'])
    ax.grid(True, alpha=0.3)

    # Plot 2: Complex phase representation
    ax = axes[1]
    theta_vals = np.linspace(0, 2*np.pi, 100)
    ax.plot(np.cos(theta_vals), np.sin(theta_vals), 'k-', alpha=0.3)

    for name, theta, color in anyon_types:
        for n in range(8):
            phase = n * theta
            x, y = np.cos(phase), np.sin(phase)
            size = 100 + 20 * n
            ax.scatter([x], [y], c=color, s=size, alpha=0.6, edgecolors='black')

    ax.set_xlim(-1.5, 1.5)
    ax.set_ylim(-1.5, 1.5)
    ax.set_aspect('equal')
    ax.set_xlabel('Re(e^{iφ})', fontsize=12)
    ax.set_ylabel('Im(e^{iφ})', fontsize=12)
    ax.set_title('Phase on Unit Circle', fontsize=14)
    ax.grid(True, alpha=0.3)

    # Plot 3: Periodicity
    ax = axes[2]
    for name, theta, color in anyon_types:
        if theta > 0:
            period = 2 * np.pi / theta
            ax.bar(name, period, color=color, alpha=0.7, edgecolor='black')

    ax.set_ylabel('Exchanges for Full Cycle', fontsize=12)
    ax.set_title('Exchange Periodicity', fontsize=14)
    ax.axhline(y=2, color='gray', linestyle='--', label='Double exchange')

    plt.tight_layout()
    plt.savefig('anyon_phases.png', dpi=150, bbox_inches='tight')
    plt.show()

def toric_code_anyon_types():
    """Visualize the four anyon types in the toric code"""
    fig, axes = plt.subplots(2, 2, figsize=(12, 10))

    anyon_data = [
        ('Vacuum (1)', 'None', 'Trivial', 'gray', 0),
        ('Electric (e)', 'Star (Av = -1)', 'Bosonic', 'blue', 1),
        ('Magnetic (m)', 'Plaquette (Bp = -1)', 'Bosonic', 'red', 2),
        ('Epsilon (ε = e×m)', 'Both', 'Fermionic', 'purple', 3),
    ]

    for idx, (name, violation, statistics, color, pos) in enumerate(anyon_data):
        ax = axes[pos // 2, pos % 2]

        # Draw a small lattice
        L = 4
        for i in range(L):
            for j in range(L):
                ax.plot([i, i+1], [j, j], 'k-', alpha=0.3)
                ax.plot([i, i], [j, j+1], 'k-', alpha=0.3)
        ax.plot([L, L], [0, L-1], 'k-', alpha=0.3)
        ax.plot([0, L-1], [L, L], 'k-', alpha=0.3)

        # Mark vertices
        for i in range(L+1):
            for j in range(L+1):
                ax.scatter([i], [j], c='black', s=20)

        # Highlight relevant stabilizer
        if pos == 1:  # e-particle (star violation)
            # Highlight a vertex and its star
            v = (2, 2)
            ax.scatter([v[0]], [v[1]], c=color, s=200, zorder=5, marker='*')
            for dx, dy in [(0.5, 0), (-0.5, 0), (0, 0.5), (0, -0.5)]:
                ax.plot([v[0], v[0]+dx], [v[1], v[1]+dy], color=color, linewidth=3)

        elif pos == 2:  # m-particle (plaquette violation)
            # Highlight a plaquette
            p = (1.5, 1.5)
            rect = plt.Rectangle((1, 1), 1, 1, fill=True, facecolor=color,
                                   alpha=0.3, edgecolor=color, linewidth=3)
            ax.add_patch(rect)
            ax.scatter([p[0]], [p[1]], c=color, s=200, zorder=5, marker='h')

        elif pos == 3:  # epsilon (both)
            # Highlight both at same location
            v = (2, 2)
            ax.scatter([v[0]], [v[1]], c='blue', s=200, zorder=5, marker='*')
            for dx, dy in [(0.5, 0), (-0.5, 0), (0, 0.5), (0, -0.5)]:
                ax.plot([v[0], v[0]+dx], [v[1], v[1]+dy], color='blue', linewidth=2)
            rect = plt.Rectangle((1.5, 1.5), 1, 1, fill=True, facecolor='red',
                                   alpha=0.3, edgecolor='red', linewidth=2)
            ax.add_patch(rect)

        ax.set_xlim(-0.5, L+0.5)
        ax.set_ylim(-0.5, L+0.5)
        ax.set_aspect('equal')
        ax.set_title(f'{name}\nViolation: {violation}\nSelf-statistics: {statistics}',
                     fontsize=12)
        ax.set_xticks([])
        ax.set_yticks([])

    fig.suptitle('Anyon Types in the Toric Code', fontsize=16)
    plt.tight_layout()
    plt.savefig('toric_anyons.png', dpi=150, bbox_inches='tight')
    plt.show()

def main():
    """Run all visualizations"""
    print("=" * 60)
    print("Day 792: Anyonic Excitations - Computational Lab")
    print("=" * 60)

    print("\n1. Visualizing 2D particle exchange (non-equivalent paths)...")
    visualize_2d_exchange()

    print("\n2. Visualizing 3D particle exchange (equivalent paths)...")
    visualize_3d_exchange()

    print("\n3. Phase accumulation for different anyon types...")
    anyonic_phase_accumulation()

    print("\n4. Toric code anyon types...")
    toric_code_anyon_types()

    print("\n" + "=" * 60)
    print("Key Insights:")
    print("=" * 60)
    print("• In 2D, clockwise and counter-clockwise exchanges differ")
    print("• In 3D, all exchange paths are topologically equivalent")
    print("• Anyons accumulate phases that can be any value θ ∈ [0, 2π)")
    print("• The toric code has exactly 4 anyon types: 1, e, m, ε")
    print("• ε = e × m is a fermion despite e and m being bosons!")
    print("=" * 60)

if __name__ == "__main__":
    main()
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| Boson exchange | $\|\psi_{12}\rangle = +\|\psi_{21}\rangle$ |
| Fermion exchange | $\|\psi_{12}\rangle = -\|\psi_{21}\rangle$ |
| Anyon exchange | $\|\psi_{12}\rangle = e^{i\theta}\|\psi_{21}\rangle$ |
| 2D configuration space | $\pi_1 = \mathbb{Z}$ (braid group) |
| 3D configuration space | $\pi_1 = \mathbb{Z}_2$ (permutation) |
| Toric code anyons | $\mathcal{A} = \{1, e, m, \varepsilon\}$ |
| Yang-Baxter equation | $\sigma_i \sigma_{i+1} \sigma_i = \sigma_{i+1} \sigma_i \sigma_{i+1}$ |

### Main Takeaways

1. **Dimension matters**: Only 2D systems support anyonic statistics because particle worldlines form non-trivial braids
2. **Topological origin**: The braid group $B_n$ replaces the permutation group $S_n$ for identical particles in 2D
3. **Quasiparticle nature**: Anyons are emergent excitations in many-body systems, not fundamental particles
4. **Stabilizer connection**: In the toric code, anyons correspond to stabilizer violations
5. **Four types**: The toric code has vacuum (1), electric (e), magnetic (m), and fermion (ε) excitations
6. **Protection**: Anyonic properties are topologically protected from local perturbations

---

## Daily Checklist

### Morning Theory (3 hours)
- [ ] Understand quasiparticle concept and emergence
- [ ] Derive the configuration space topology argument
- [ ] Master the braid group vs permutation group distinction
- [ ] Connect stabilizer violations to anyon creation

### Afternoon Problems (2.5 hours)
- [ ] Complete all Direct Application problems
- [ ] Work through at least 2 Intermediate problems
- [ ] Attempt at least 1 Challenging problem

### Evening Lab (1.5 hours)
- [ ] Run all visualization code
- [ ] Modify parameters to explore different anyon types
- [ ] Create your own visualization of braiding

### Self-Assessment Questions
1. Why can't anyons exist in 3D?
2. What physical process creates e-particles in the toric code?
3. Why are there exactly 4 anyon types in the toric code?

---

## Preview: Day 793

Tomorrow we dive deep into **electric charges (e-particles)**: the anyonic excitations created by star operator violations. We'll learn how Z-string operators create e-particle pairs, how these particles move through the lattice, and prove their bosonic self-statistics. This sets up the parallel treatment of m-particles on Wednesday.

---

*Day 792 of 2184 | Year 2, Month 29, Week 114 | Quantum Engineering PhD Curriculum*

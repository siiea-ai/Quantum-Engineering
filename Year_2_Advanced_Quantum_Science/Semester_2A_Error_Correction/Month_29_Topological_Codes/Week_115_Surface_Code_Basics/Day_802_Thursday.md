# Day 802: Logical Operators on the Planar Code

## Month 29: Topological Codes | Week 115: Surface Code Implementation
### Year 2: Advanced Quantum Science

---

## Schedule Overview

| Session | Duration | Focus |
|---------|----------|-------|
| **Morning** | 3 hours | Logical X and Z as boundary-to-boundary strings |
| **Afternoon** | 2.5 hours | String-net picture, operator equivalence classes |
| **Evening** | 1.5 hours | Computational lab: Logical operator visualization |

**Total Study Time**: 7 hours

---

## Learning Objectives

By the end of Day 802, you will be able to:

1. **Construct** logical X operators as strings from smooth to smooth boundary
2. **Construct** logical Z operators as strings from rough to rough boundary
3. **Explain** the string-net interpretation of logical operators
4. **Prove** that deformable strings represent the same logical operator
5. **Calculate** the minimum weight (code distance) from operator geometry
6. **Describe** the complementary pairing between X and Z logical operators

---

## Morning Session: Logical Operator Theory (3 hours)

### 1. Review: Boundaries and Logical Structure

Recall from Day 799 that the planar surface code has:
- **Smooth boundaries** (X-type): Left and right edges
- **Rough boundaries** (Z-type): Top and bottom edges

This configuration encodes exactly **1 logical qubit**.

The key question: What are the logical $\bar{X}$ and $\bar{Z}$ operators?

### 2. Logical Z: Rough-to-Rough Strings

The logical Z operator is a **string of Z operators** connecting two rough boundaries.

#### Construction

Consider a vertical path from the top (rough) boundary to the bottom (rough) boundary:

```
Rough boundary (top)
        │
        Z
        │
        Z
        │
        Z
        │
        Z
        │
        Z
        │
Rough boundary (bottom)
```

This string of Z operators defines:

$$\boxed{\bar{Z} = \prod_{q \in \text{vertical path}} Z_q}$$

#### Why This Works

1. **Commutes with all X-stabilizers**:
   - Each X-stabilizer (plaquette) intersects the vertical path at an **even number** of qubits (0 or 2)
   - $\bar{Z}$ and $B_p$ share even overlap → they commute

2. **Commutes with all Z-stabilizers**:
   - Z-stabilizers and Z-operators always commute ($[Z, Z] = 0$)

3. **Not a stabilizer**:
   - $\bar{Z}$ is not a product of Z-stabilizers (it spans boundary to boundary)
   - Therefore, it acts non-trivially on the code space

#### Minimum Weight

The shortest path from rough to rough boundary has length equal to the number of rows:

$$\text{wt}(\bar{Z}_{\min}) = d \quad \text{(for } d \times d \text{ code)}$$

This is the **Z-distance** of the code.

### 3. Logical X: Smooth-to-Smooth Strings

The logical X operator is a **string of X operators** connecting two smooth boundaries.

#### Construction

Consider a horizontal path from the left (smooth) boundary to the right (smooth) boundary:

```
Smooth       X───X───X───X───X       Smooth
boundary                             boundary
(left)                               (right)
```

This string of X operators defines:

$$\boxed{\bar{X} = \prod_{q \in \text{horizontal path}} X_q}$$

#### Why This Works

1. **Commutes with all Z-stabilizers**:
   - Each Z-stabilizer intersects the horizontal path at an even number of qubits
   - $\bar{X}$ and $A_v$ share even overlap → they commute

2. **Commutes with all X-stabilizers**:
   - X-stabilizers and X-operators always commute

3. **Not a stabilizer**:
   - $\bar{X}$ spans boundary to boundary, not generated by X-stabilizers

#### Minimum Weight

The shortest horizontal path has length:

$$\text{wt}(\bar{X}_{\min}) = d$$

This is the **X-distance** of the code.

### 4. Anticommutation of Logical Operators

For the logical operators to correctly encode a qubit, we need:

$$\bar{X} \bar{Z} = -\bar{Z} \bar{X}$$

#### Proof

Consider the overlap between a horizontal X-string and a vertical Z-string:

```
        Rough
          │
          Z
          │
    ──X───X───X───   ← Horizontal X-string
          │
          Z
          │
        Rough
```

The two strings **intersect at exactly one qubit** (the crossing point).

At this qubit: $X \cdot Z = -Z \cdot X$ (Pauli anticommutation)

Therefore:
$$\bar{X} \bar{Z} = -\bar{Z} \bar{X}$$

$$\boxed{\text{Logical operators anticommute: } \{\bar{X}, \bar{Z}\} = 0}$$

### 5. String Deformation and Equivalence Classes

Not all strings representing the same logical operator look identical—they form **equivalence classes**.

#### Deformation Rules

Two strings represent the same logical operator if they differ by a product of stabilizers.

**Z-string deformation**:
- A Z-string can be "pushed" through an X-stabilizer by multiplying with that stabilizer
- This adds or removes edges in the path

```
Before:           After (deformed by B_p):
    │                  │ │
    Z                  Z─Z
    │                    │
```

**X-string deformation**:
- An X-string can be "pushed" through a Z-stabilizer
- Similar edge modification

#### Equivalence Classes

All Z-strings from rough to rough that differ by X-stabilizers represent the **same logical Z**.

Formally:
$$[\bar{Z}] = \{\bar{Z} \cdot S : S \in \langle B_p \rangle\}$$

The **minimum weight** representative is the one that minimizes qubit count.

### 6. The String-Net Picture

Logical operators in the surface code have a beautiful interpretation as **string-nets**.

#### Z-strings (Electric Strings)

- Start and end at rough boundaries
- Create or annihilate **e-anyons** (Z-error excitations)
- The string is the "worldline" of an e-anyon moving from boundary to boundary

#### X-strings (Magnetic Strings)

- Start and end at smooth boundaries
- Create or annihilate **m-anyons** (X-error excitations)
- The string is the worldline of an m-anyon

#### Topological Invariance

The key insight: **Only the topology of the string matters, not its geometry**.

A Z-string that goes "around" obstacles is equivalent (up to stabilizers) to a straight path, as long as it connects the same boundary types.

### 7. Multiple Representatives

For a given logical operator, there are **exponentially many** equivalent representatives.

#### Counting for Logical Z

For a $d \times d$ surface code:
- Each row has $d$ qubits
- A Z-path must cross each row exactly once
- At each row, the path can "jog" left or right

Number of minimum-weight representatives: approximately $\binom{d}{d/2}$ (for paths that jog symmetrically)

More generally, considering all equivalent strings:
$$|\text{representatives of } \bar{Z}| = 2^{\Theta(d^2)}$$

This exponential degeneracy is important for error correction—it provides many ways to interpret the same logical operation.

---

## Quantum Mechanics Connection

### Topological Protection

The surface code provides **topological protection** through the geometry of logical operators:

1. **Distance = path length**: An error must span the entire code (boundary to boundary) to cause a logical fault

2. **Local errors are correctable**: Any error with support smaller than $d/2$ can be corrected without logical damage

3. **Decoherence resistance**: The logical information is "spread out" over the entire lattice

#### The Homological Interpretation

From algebraic topology:
- Logical Z operators are **1-chains** (paths) in the primal lattice
- Logical X operators are 1-chains in the dual lattice
- Stabilizers are **boundaries** (∂ of 2-chains)
- Logical operators are elements of **homology**: $H_1 = \ker \partial / \text{im } \partial$

This means:
$$\bar{Z} \in H_1(\Sigma, \partial_{rough}) \quad \text{(relative homology)}$$

The code encodes information in the topological structure of the surface!

### Anyonic Worldlines

In the topological quantum field theory interpretation:
- A Z-string is the worldline of an **e-anyon** moving through spacetime
- An X-string is the worldline of an **m-anyon**
- Rough boundaries **condense e-anyons** (they can disappear there)
- Smooth boundaries **condense m-anyons**

The anticommutation of logical operators reflects the **mutual statistics** of e and m anyons:
$$\theta_{em} = \pi \quad \text{(semionic mutual statistics)}$$

---

## Afternoon Session: Worked Examples (2.5 hours)

### Example 1: All Minimum-Weight Logical Z Representatives

**Problem**: For a distance-3 surface code, enumerate all minimum-weight representatives of the logical Z operator.

**Solution**:

For a 3×3 surface code with rough boundaries on top/bottom:

```
Layout:
  q0───q1───q2     ← Row 0 (top, rough boundary)
   │    │    │
  q3───q4───q5     ← Row 1
   │    │    │
  q6───q7───q8     ← Row 2 (bottom, rough boundary)
```

Minimum-weight Z paths (weight 3, one qubit per row):

1. $\bar{Z}_1 = Z_0 Z_3 Z_6$ (left column)
2. $\bar{Z}_2 = Z_1 Z_4 Z_7$ (middle column)
3. $\bar{Z}_3 = Z_2 Z_5 Z_8$ (right column)
4. $\bar{Z}_4 = Z_0 Z_4 Z_8$ (diagonal)
5. $\bar{Z}_5 = Z_2 Z_4 Z_6$ (anti-diagonal)

Wait—diagonals have weight 3 but may not be valid paths. Let me reconsider.

A valid Z-path must connect adjacent qubits. In the layout above:
- Vertical paths: columns (3 options)
- Diagonal paths: only if adjacency exists

For the standard surface code layout:
- $\bar{Z}_1 = Z_0 Z_3 Z_6$ ✓
- $\bar{Z}_2 = Z_1 Z_4 Z_7$ ✓
- $\bar{Z}_3 = Z_2 Z_5 Z_8$ ✓

Other weight-3 paths (with one horizontal step):
- $\bar{Z}_4 = Z_0 Z_4 Z_7$ (step right at row 0→1, step left at row 1→2)?
  - This requires $Z_0, Z_4, Z_7$ where q0→q4 is a step right, q4→q7 is straight down. ✓
- Similar paths exist.

$$\boxed{\text{At least 3 straight-column representatives, plus "kinked" paths}}$$

### Example 2: Verifying Commutation with Stabilizers

**Problem**: For the distance-3 code, verify that $\bar{Z} = Z_1 Z_4 Z_7$ commutes with all X-stabilizers.

**Solution**:

X-stabilizers for distance-3 code (assuming 4 plaquettes):

- $B_1 = X_0 X_1 X_3 X_4$ (top-left plaquette)
- $B_2 = X_1 X_2 X_4 X_5$ (top-right plaquette)
- $B_3 = X_3 X_4 X_6 X_7$ (bottom-left plaquette)
- $B_4 = X_4 X_5 X_7 X_8$ (bottom-right plaquette)

Check overlap with $\bar{Z} = Z_1 Z_4 Z_7$:

- $B_1 \cap \bar{Z} = \{1, 4\}$ → overlap = 2 (even) → commutes ✓
- $B_2 \cap \bar{Z} = \{1, 4\}$ → overlap = 2 (even) → commutes ✓
- $B_3 \cap \bar{Z} = \{4, 7\}$ → overlap = 2 (even) → commutes ✓
- $B_4 \cap \bar{Z} = \{4, 7\}$ → overlap = 2 (even) → commutes ✓

All overlaps are even, so $[\bar{Z}, B_p] = 0$ for all plaquettes.

$$\boxed{\bar{Z} \text{ commutes with all X-stabilizers}}$$

### Example 3: String Deformation

**Problem**: Show that $Z_0 Z_3 Z_6$ and $Z_1 Z_3 Z_6$ differ by an X-stabilizer, hence represent equivalent logical operators.

**Solution**:

Actually, let's check:

$Z_0 Z_3 Z_6$ = left column
$Z_1 Z_3 Z_6$ = ?

The difference: $Z_0 Z_3 Z_6 \cdot Z_1 Z_3 Z_6 = Z_0 Z_1$ (since $Z^2 = I$)

Is $Z_0 Z_1$ a product of stabilizers?

Looking at X-stabilizers: They are products of X operators, not Z.
Looking at Z-stabilizers: These are products of Z on vertices.

For $Z_0 Z_1$ to be a stabilizer, we'd need a Z-stabilizer containing exactly q0 and q1.

In the standard code, Z-stabilizers at boundary might have weight 2. If there's a Z-stabilizer $A = Z_0 Z_1$, then yes, $Z_0 Z_3 Z_6$ and $Z_1 Z_3 Z_6$ are equivalent.

Actually, I need to be more careful. The statement "differ by an X-stabilizer" applies to X-strings (for logical X equivalence). For Z-strings:

Two Z-strings are equivalent if they differ by a **product of X-stabilizers** (which would be an X-type operator, not Z).

Wait—this is confusing. Let me clarify:

**Correct statement**: Two representatives of $\bar{Z}$ are equivalent if they differ by a product of **X-stabilizers evaluated as support on the Z-string**.

No, that's not right either. Let me think again.

**The key relationship**:
- $\bar{Z}$ and $\bar{Z}'$ are equivalent logical operators if $\bar{Z} \cdot \bar{Z}'$ is in the stabilizer group.
- For Z-type operators, $\bar{Z} \cdot \bar{Z}'$ is a Z-type operator.
- This must be a product of Z-stabilizers.

So: $Z_0 Z_3 Z_6$ and $Z_1 Z_3 Z_6$ are equivalent iff $Z_0 Z_1$ is a Z-stabilizer.

If there's a boundary Z-stabilizer $A_v = Z_0 Z_1$ at the top rough boundary, then yes!

$$\boxed{\text{Equivalence: } Z_0 Z_3 Z_6 \sim Z_1 Z_3 Z_6 \text{ via } A_v = Z_0 Z_1}$$

---

## Practice Problems

### Problem Set 802

#### Direct Application

1. **Logical X paths**: For a distance-5 surface code, list all minimum-weight (weight-5) representatives of the logical X operator that follow straight horizontal paths.

2. **Anticommutation check**: For the distance-3 code, verify that $\bar{X} = X_0 X_1 X_2$ and $\bar{Z} = Z_0 Z_3 Z_6$ anticommute by computing their overlap.

3. **Stabilizer commutation**: Show that $\bar{X} = X_3 X_4 X_5$ commutes with all Z-stabilizers in the distance-3 code.

#### Intermediate

4. **Non-minimum weight logical operators**: Find a weight-5 representative of $\bar{Z}$ in the distance-3 code. Verify it's equivalent to a minimum-weight representative by finding the stabilizer difference.

5. **Boundary effects**: In a distance-5 code with non-standard boundaries (3 smooth, 1 rough), how many independent logical operators exist? What are their minimum weights?

6. **Counting representatives**: For a $d \times d$ surface code, derive a formula (or bound) for the number of minimum-weight representatives of $\bar{Z}$.

#### Challenging

7. **Topological proof**: Prove that any Z-string connecting rough boundaries can be deformed (via stabilizers) to a "straight" vertical path.

8. **Distance from geometry**: For a rectangular $d_X \times d_Z$ surface code, prove that the X-distance is $d_X$ and the Z-distance is $d_Z$.

9. **Logical operator from syndrome history**: Given a sequence of syndrome measurements, describe how to infer which logical errors may have occurred (this previews decoding).

---

## Evening Session: Computational Lab (1.5 hours)

### Lab 802: Logical Operator Visualization and Verification

```python
"""
Day 802 Computational Lab: Logical Operators on Planar Codes
Visualization and verification of logical X and Z operators
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle, FancyBboxPatch, Arrow
from matplotlib.collections import LineCollection
from itertools import combinations
from typing import List, Tuple, Set

class LogicalOperatorAnalyzer:
    """
    Analyzes logical operators on a surface code.

    For a d×d surface code:
    - Logical Z connects rough (top/bottom) boundaries
    - Logical X connects smooth (left/right) boundaries
    """

    def __init__(self, d: int):
        """
        Initialize analyzer for distance-d surface code.

        Parameters:
            d: Code distance (odd, >= 3)
        """
        if d < 3 or d % 2 == 0:
            raise ValueError("Distance must be odd and >= 3")

        self.d = d
        self.n = d * d  # Number of data qubits

        # Build qubit layout
        self._build_layout()
        self._build_stabilizers()

    def _build_layout(self):
        """Create qubit position mapping."""
        self.qubit_pos = {}  # (row, col) -> qubit index
        self.pos_qubit = {}  # qubit index -> (row, col)

        idx = 0
        for row in range(self.d):
            for col in range(self.d):
                self.qubit_pos[(row, col)] = idx
                self.pos_qubit[idx] = (row, col)
                idx += 1

    def _build_stabilizers(self):
        """Build X and Z stabilizer generators."""
        d = self.d

        # X-stabilizers (plaquettes)
        self.x_stabilizers = []
        for row in range(d - 1):
            for col in range(d - 1):
                stab = [
                    self.qubit_pos[(row, col)],
                    self.qubit_pos[(row, col + 1)],
                    self.qubit_pos[(row + 1, col)],
                    self.qubit_pos[(row + 1, col + 1)]
                ]
                self.x_stabilizers.append(set(stab))

        # Z-stabilizers (dual vertices, simplified)
        self.z_stabilizers = []
        # Horizontal edges
        for row in range(d):
            for col in range(d - 1):
                stab = [
                    self.qubit_pos[(row, col)],
                    self.qubit_pos[(row, col + 1)]
                ]
                self.z_stabilizers.append(set(stab))

    def get_logical_z_representatives(self, max_weight: int = None) -> List[Set[int]]:
        """
        Find representatives of logical Z (vertical paths).

        Returns list of qubit sets representing logical Z operators.
        """
        if max_weight is None:
            max_weight = self.d

        representatives = []

        # Minimum weight: straight columns
        for col in range(self.d):
            path = {self.qubit_pos[(row, col)] for row in range(self.d)}
            representatives.append(path)

        # Could add "kinked" paths here for completeness

        return representatives

    def get_logical_x_representatives(self, max_weight: int = None) -> List[Set[int]]:
        """
        Find representatives of logical X (horizontal paths).

        Returns list of qubit sets representing logical X operators.
        """
        if max_weight is None:
            max_weight = self.d

        representatives = []

        # Minimum weight: straight rows
        for row in range(self.d):
            path = {self.qubit_pos[(row, col)] for col in range(self.d)}
            representatives.append(path)

        return representatives

    def verify_commutation(self, operator: Set[int], op_type: str) -> bool:
        """
        Verify that an operator commutes with all appropriate stabilizers.

        Parameters:
            operator: Set of qubit indices
            op_type: 'X' or 'Z'

        Returns:
            True if operator commutes with all required stabilizers
        """
        if op_type == 'Z':
            # Z-operator must commute with X-stabilizers (even overlap)
            for stab in self.x_stabilizers:
                overlap = len(operator & stab)
                if overlap % 2 != 0:
                    return False
        else:  # op_type == 'X'
            # X-operator must commute with Z-stabilizers (even overlap)
            for stab in self.z_stabilizers:
                overlap = len(operator & stab)
                if overlap % 2 != 0:
                    return False

        return True

    def check_anticommutation(self, log_x: Set[int], log_z: Set[int]) -> bool:
        """
        Check that logical X and Z anticommute.

        They anticommute iff their overlap is odd.
        """
        overlap = len(log_x & log_z)
        return overlap % 2 == 1

    def visualize_logical_operators(self, figsize: Tuple[int, int] = (12, 5)):
        """
        Visualize logical X and Z operators on the surface code.
        """
        fig, axes = plt.subplots(1, 2, figsize=figsize)

        # Get representative logical operators
        log_z = self.get_logical_z_representatives()[self.d // 2]  # Middle column
        log_x = self.get_logical_x_representatives()[self.d // 2]  # Middle row

        # Left plot: Logical Z
        ax = axes[0]
        self._draw_lattice(ax)
        self._draw_boundaries(ax)
        self._draw_operator(ax, log_z, 'Z', color='purple')
        ax.set_title(f'Logical Z: Rough → Rough\nWeight = {len(log_z)}', fontsize=12)

        # Right plot: Logical X
        ax = axes[1]
        self._draw_lattice(ax)
        self._draw_boundaries(ax)
        self._draw_operator(ax, log_x, 'X', color='green')
        ax.set_title(f'Logical X: Smooth → Smooth\nWeight = {len(log_x)}', fontsize=12)

        plt.tight_layout()
        return fig, axes

    def _draw_lattice(self, ax):
        """Draw the basic lattice structure."""
        d = self.d

        # Draw grid lines
        for i in range(d):
            ax.axhline(y=i, color='lightgray', linewidth=0.5, zorder=1)
            ax.axvline(x=i, color='lightgray', linewidth=0.5, zorder=1)

        # Draw data qubits
        for idx, (row, col) in self.pos_qubit.items():
            ax.scatter(col, d - 1 - row, s=200, c='black', zorder=5)
            ax.annotate(str(idx), (col, d - 1 - row), ha='center', va='center',
                       color='white', fontsize=7, zorder=6)

        ax.set_xlim(-0.5, d - 0.5)
        ax.set_ylim(-0.5, d - 0.5)
        ax.set_aspect('equal')
        ax.axis('off')

    def _draw_boundaries(self, ax):
        """Draw boundary indicators."""
        d = self.d

        # Smooth boundaries (left and right) - blue
        ax.plot([-0.4, -0.4], [-0.3, d - 0.7], 'b-', linewidth=4, label='Smooth')
        ax.plot([d - 0.6, d - 0.6], [-0.3, d - 0.7], 'b-', linewidth=4)

        # Rough boundaries (top and bottom) - red
        ax.plot([-0.3, d - 0.7], [-0.4, -0.4], 'r-', linewidth=4, label='Rough')
        ax.plot([-0.3, d - 0.7], [d - 0.6, d - 0.6], 'r-', linewidth=4)

    def _draw_operator(self, ax, operator: Set[int], op_type: str, color: str):
        """Draw a logical operator as connected path."""
        d = self.d

        # Get positions of qubits in operator
        positions = [(col, d - 1 - row) for idx in operator
                     for row, col in [self.pos_qubit[idx]]]

        # Sort by position to draw path
        if op_type == 'Z':
            # Vertical path: sort by y
            positions.sort(key=lambda p: -p[1])
        else:
            # Horizontal path: sort by x
            positions.sort(key=lambda p: p[0])

        # Draw path
        xs, ys = zip(*positions)
        ax.plot(xs, ys, color=color, linewidth=3, zorder=3, alpha=0.7)

        # Highlight qubits in operator
        ax.scatter(xs, ys, s=300, c=color, zorder=4, alpha=0.8)

        # Label
        ax.text(positions[0][0], positions[0][1] + 0.3, op_type,
               ha='center', va='bottom', fontsize=14, fontweight='bold', color=color)


def demonstrate_anticommutation():
    """Demonstrate that logical X and Z anticommute."""
    print("\n" + "="*60)
    print("Logical Operator Anticommutation")
    print("="*60)

    for d in [3, 5, 7]:
        analyzer = LogicalOperatorAnalyzer(d)

        log_z = analyzer.get_logical_z_representatives()[d // 2]
        log_x = analyzer.get_logical_x_representatives()[d // 2]

        overlap = log_x & log_z
        anticommute = analyzer.check_anticommutation(log_x, log_z)

        print(f"\nDistance {d}:")
        print(f"  Logical Z: {sorted(log_z)}")
        print(f"  Logical X: {sorted(log_x)}")
        print(f"  Overlap: {overlap} (size = {len(overlap)})")
        print(f"  Anticommute: {anticommute}")


def verify_stabilizer_commutation():
    """Verify that logical operators commute with stabilizers."""
    print("\n" + "="*60)
    print("Stabilizer Commutation Verification")
    print("="*60)

    d = 5
    analyzer = LogicalOperatorAnalyzer(d)

    print(f"\nDistance-{d} surface code:")
    print(f"  X-stabilizers: {len(analyzer.x_stabilizers)}")
    print(f"  Z-stabilizers: {len(analyzer.z_stabilizers)}")

    # Check all logical Z representatives
    print("\nLogical Z representatives:")
    for i, log_z in enumerate(analyzer.get_logical_z_representatives()):
        commutes = analyzer.verify_commutation(log_z, 'Z')
        print(f"  Z_{i}: {sorted(log_z)} - Commutes with X-stabs: {commutes}")

    # Check all logical X representatives
    print("\nLogical X representatives:")
    for i, log_x in enumerate(analyzer.get_logical_x_representatives()):
        commutes = analyzer.verify_commutation(log_x, 'X')
        print(f"  X_{i}: {sorted(log_x)} - Commutes with Z-stabs: {commutes}")


def string_deformation_demo():
    """Demonstrate string deformation via stabilizers."""
    print("\n" + "="*60)
    print("String Deformation Demo")
    print("="*60)

    d = 3
    analyzer = LogicalOperatorAnalyzer(d)

    # Two logical Z representatives
    log_z1 = analyzer.get_logical_z_representatives()[0]  # Left column
    log_z2 = analyzer.get_logical_z_representatives()[1]  # Middle column

    print(f"\nDistance-{d} code:")
    print(f"  Logical Z_1: {sorted(log_z1)} (left column)")
    print(f"  Logical Z_2: {sorted(log_z2)} (middle column)")

    # Difference
    diff = log_z1 ^ log_z2  # Symmetric difference
    print(f"  Difference Z_1 ⊕ Z_2: {sorted(diff)}")

    # Check if difference is a product of Z-stabilizers
    # (This is a simplified check)
    print("\n  To show equivalence, we need to express the difference")
    print("  as a product of Z-stabilizers (boundary terms).")

    # Visualize
    fig, axes = plt.subplots(1, 3, figsize=(15, 5))

    for ax, (log_z, title) in zip(axes, [
        (log_z1, "Logical Z₁ (left column)"),
        (log_z2, "Logical Z₂ (middle column)"),
        (diff, "Difference (boundary stabilizers)")
    ]):
        analyzer._draw_lattice(ax)
        analyzer._draw_boundaries(ax)

        # Draw operator
        positions = [(col, d - 1 - row) for idx in log_z
                     for row, col in [analyzer.pos_qubit[idx]]]
        if positions:
            xs, ys = zip(*positions)
            ax.scatter(xs, ys, s=400, c='purple', zorder=4, alpha=0.8)
        ax.set_title(title, fontsize=11)

    plt.tight_layout()
    plt.savefig('string_deformation.png', dpi=150, bbox_inches='tight')
    plt.show()


def plot_all_representatives():
    """Plot all minimum-weight logical operator representatives."""
    print("\n" + "="*60)
    print("All Minimum-Weight Representatives")
    print("="*60)

    d = 5
    analyzer = LogicalOperatorAnalyzer(d)

    log_z_reps = analyzer.get_logical_z_representatives()
    log_x_reps = analyzer.get_logical_x_representatives()

    print(f"\nDistance-{d} code:")
    print(f"  Minimum-weight logical Z representatives: {len(log_z_reps)}")
    print(f"  Minimum-weight logical X representatives: {len(log_x_reps)}")

    # Visualize all Z representatives
    fig, axes = plt.subplots(1, d, figsize=(3 * d, 3))

    for i, (ax, log_z) in enumerate(zip(axes, log_z_reps)):
        analyzer._draw_lattice(ax)

        positions = [(col, d - 1 - row) for idx in log_z
                     for row, col in [analyzer.pos_qubit[idx]]]
        xs, ys = zip(*positions)
        ax.plot(xs, ys, 'purple', linewidth=3, zorder=3)
        ax.scatter(xs, ys, s=200, c='purple', zorder=4)
        ax.set_title(f'Z̄_{i}', fontsize=12)

    plt.suptitle(f'All {d} minimum-weight logical Z representatives', fontsize=14)
    plt.tight_layout()
    plt.savefig('all_logical_z.png', dpi=150, bbox_inches='tight')
    plt.show()


# Main execution
if __name__ == "__main__":
    print("=" * 60)
    print("Day 802: Logical Operators on Planar Codes")
    print("=" * 60)

    # Create analyzer
    analyzer = LogicalOperatorAnalyzer(5)

    # Visualize logical operators
    print("\n1. Visualizing logical operators...")
    fig, axes = analyzer.visualize_logical_operators()
    plt.savefig('logical_operators.png', dpi=150, bbox_inches='tight')
    plt.show()

    # Demonstrate anticommutation
    demonstrate_anticommutation()

    # Verify stabilizer commutation
    verify_stabilizer_commutation()

    # String deformation demo
    string_deformation_demo()

    # All representatives
    plot_all_representatives()

    print("\n" + "=" * 60)
    print("Lab complete.")
    print("=" * 60)
```

### Expected Output

```
============================================================
Day 802: Logical Operators on Planar Codes
============================================================

1. Visualizing logical operators...

============================================================
Logical Operator Anticommutation
============================================================

Distance 3:
  Logical Z: [1, 4, 7]
  Logical X: [3, 4, 5]
  Overlap: {4} (size = 1)
  Anticommute: True

Distance 5:
  Logical Z: [2, 7, 12, 17, 22]
  Logical X: [10, 11, 12, 13, 14]
  Overlap: {12} (size = 1)
  Anticommute: True

Distance 7:
  Logical Z: [3, 10, 17, 24, 31, 38, 45]
  Logical X: [21, 22, 23, 24, 25, 26, 27]
  Overlap: {24} (size = 1)
  Anticommute: True

============================================================
Stabilizer Commutation Verification
============================================================

Distance-5 surface code:
  X-stabilizers: 16
  Z-stabilizers: 20

Logical Z representatives:
  Z_0: [0, 5, 10, 15, 20] - Commutes with X-stabs: True
  Z_1: [1, 6, 11, 16, 21] - Commutes with X-stabs: True
  Z_2: [2, 7, 12, 17, 22] - Commutes with X-stabs: True
  Z_3: [3, 8, 13, 18, 23] - Commutes with X-stabs: True
  Z_4: [4, 9, 14, 19, 24] - Commutes with X-stabs: True

Logical X representatives:
  X_0: [0, 1, 2, 3, 4] - Commutes with Z-stabs: True
  X_1: [5, 6, 7, 8, 9] - Commutes with Z-stabs: True
  X_2: [10, 11, 12, 13, 14] - Commutes with Z-stabs: True
  X_3: [15, 16, 17, 18, 19] - Commutes with Z-stabs: True
  X_4: [20, 21, 22, 23, 24] - Commutes with Z-stabs: True

============================================================
Lab complete.
============================================================
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| Logical Z | $\bar{Z} = \prod_{q \in \text{rough→rough path}} Z_q$ |
| Logical X | $\bar{X} = \prod_{q \in \text{smooth→smooth path}} X_q$ |
| Code distance | $d = \min(\text{wt}(\bar{X}), \text{wt}(\bar{Z}))$ |
| Anticommutation | $\bar{X}\bar{Z} = -\bar{Z}\bar{X}$ (overlap = 1) |
| Equivalence | $\bar{Z} \sim \bar{Z}' \iff \bar{Z}\bar{Z}' \in \langle A_v \rangle$ |

### Key Takeaways

1. **Logical Z connects rough boundaries**: Vertical Z-string from top to bottom

2. **Logical X connects smooth boundaries**: Horizontal X-string from left to right

3. **Anticommutation from overlap**: Logical X and Z intersect at exactly one qubit, ensuring $\{\bar{X}, \bar{Z}\} = 0$

4. **String deformation preserves logical action**: Equivalent strings differ by stabilizers

5. **Code distance = minimum path length**: The shortest boundary-to-boundary path determines distance

6. **Topological protection**: Information encoded in non-local string structure

---

## Daily Checklist

Before moving to Day 803, verify you can:

- [ ] Draw logical X and Z operators on a surface code diagram
- [ ] Verify commutation with all stabilizers
- [ ] Prove anticommutation of logical operators
- [ ] Explain string deformation via stabilizers
- [ ] Calculate code distance from geometry
- [ ] Connect logical operators to anyon worldlines

---

## Preview: Day 803

Tomorrow we explore **defects and holes**:
- Twist defects (genons) as alternative qubit encodings
- Holes in the lattice as logical qubits
- Defect braiding for logical gates
- Comparison with lattice surgery approaches

---

## References

1. Dennis, E., et al. "Topological quantum memory." *Journal of Mathematical Physics* 43, 4452 (2002)
2. Fowler, A. G., et al. "Surface codes: Towards practical large-scale quantum computation." *Physical Review A* 86, 032324 (2012)
3. Bombin, H. "An introduction to topological quantum codes." arXiv:1311.0277 (2013)

---

*Day 802 reveals the geometric beauty of logical operators—information stored in the topology of strings spanning the code.*

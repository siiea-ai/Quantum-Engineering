# Day 687: Stabilizer Formalism Introduction

## Week 99: Three-Qubit Codes | Month 25: QEC Fundamentals I | Year 2

---

## Schedule Overview

| Block | Time | Duration | Focus |
|-------|------|----------|-------|
| **Morning** | 9:00 AM - 12:30 PM | 3.5 hrs | Stabilizer Theory |
| **Afternoon** | 2:00 PM - 4:30 PM | 2.5 hrs | Problem Solving |
| **Evening** | 7:00 PM - 8:00 PM | 1 hr | Computational Lab |

---

## Learning Objectives

By the end of Day 687, you will be able to:

1. **Define the n-qubit Pauli group** $\mathcal{P}_n$ and its structure
2. **Understand stabilizer subgroups** and their properties
3. **Construct code spaces** as joint +1 eigenspaces
4. **Work with stabilizer generators** and independence
5. **Apply the binary symplectic representation** for efficient computation
6. **Connect stabilizers to syndrome measurement** from Week 98

---

## From Three-Qubit Codes to General Theory

### What We Learned in Week 98

In the bit-flip and phase-flip codes, we defined:
- **Bit-flip stabilizers:** $Z_1Z_2$, $Z_2Z_3$
- **Phase-flip stabilizers:** $X_1X_2$, $X_2X_3$

These operators:
1. **Commute with each other**
2. **Have eigenvalue +1 on all codewords**
3. **Anticommute with correctable errors**

The **stabilizer formalism** generalizes this structure to define arbitrary quantum codes.

---

## The Pauli Group

### Single-Qubit Pauli Group $\mathcal{P}_1$

**Definition:**

$$\mathcal{P}_1 = \langle i, X, Y, Z \rangle = \{\pm I, \pm iI, \pm X, \pm iX, \pm Y, \pm iY, \pm Z, \pm iZ\}$$

This is the group generated by the Pauli matrices with all possible phases.

**Size:** $|\mathcal{P}_1| = 16$

**Group Properties:**
- **Closure:** Product of any two Paulis is a Pauli (with phase)
- **Identity:** $I$
- **Inverse:** Each element is its own inverse up to phase: $P^2 = \pm I$

### n-Qubit Pauli Group $\mathcal{P}_n$

**Definition:**

$$\boxed{\mathcal{P}_n = \{i^k P_1 \otimes P_2 \otimes \cdots \otimes P_n : P_j \in \{I, X, Y, Z\}, k \in \{0,1,2,3\}\}}$$

**Size:** $|\mathcal{P}_n| = 4 \cdot 4^n = 4^{n+1}$

**Example (n=2):**
$$\mathcal{P}_2 = \{I \otimes I, I \otimes X, I \otimes Y, I \otimes Z, X \otimes I, X \otimes X, \ldots\} \times \{1, i, -1, -i\}$$

### Key Properties of $\mathcal{P}_n$

**Property 1: Hermiticity**

Elements with phase $\pm 1$ are Hermitian: $P^\dagger = P$

Elements with phase $\pm i$ are anti-Hermitian: $P^\dagger = -P$

**Property 2: Eigenvalues**

Hermitian Paulis have eigenvalues $\pm 1$.

**Property 3: Commutation/Anticommutation**

For any $P, Q \in \mathcal{P}_n$ (ignoring phases):

$$\boxed{PQ = \pm QP}$$

Either $P$ and $Q$ commute or anticommute — no other options!

**Proof:** Each single-qubit Pauli either commutes or anticommutes:
- Same Paulis commute: $XX = XX$, $ZZ = ZZ$
- Different Paulis anticommute: $XZ = -ZX$

For tensor products, multiply the signs: $(-1)^{\text{number of anticommuting positions}}$.

---

## Stabilizer Subgroups

### Definition

**Definition (Stabilizer Group):**

A **stabilizer group** $\mathcal{S}$ is an abelian subgroup of $\mathcal{P}_n$ satisfying:
1. **Abelian:** All elements commute: $[S_1, S_2] = 0$ for all $S_1, S_2 \in \mathcal{S}$
2. **No $-I$:** The element $-I^{\otimes n}$ is not in $\mathcal{S}$

**Why exclude $-I$?**

If $-I \in \mathcal{S}$, then for any state $|\psi\rangle$ in the code space:
$$-I|\psi\rangle = +|\psi\rangle \Rightarrow |\psi\rangle = 0$$

The code space would be trivial!

### Stabilizer Generators

**Definition:**

A set $\{g_1, g_2, \ldots, g_r\}$ **generates** $\mathcal{S}$ if every element of $\mathcal{S}$ can be written as a product of generators:

$$\mathcal{S} = \langle g_1, g_2, \ldots, g_r \rangle$$

**Independence:** Generators are independent if no generator can be written as a product of others.

**Theorem:** If $\mathcal{S}$ has $r$ independent generators, then $|\mathcal{S}| = 2^r$.

---

## The Code Space

### Definition via Stabilizers

**Definition (Stabilizer Code Space):**

Given stabilizer group $\mathcal{S} \subseteq \mathcal{P}_n$, the **code space** is:

$$\boxed{\mathcal{C} = \{|\psi\rangle \in (\mathbb{C}^2)^{\otimes n} : S|\psi\rangle = |\psi\rangle \text{ for all } S \in \mathcal{S}\}}$$

The code space is the **joint +1 eigenspace** of all stabilizers.

### Code Dimension Theorem

**Theorem:** For an $n$-qubit stabilizer code with $r$ independent stabilizer generators:

$$\boxed{\dim(\mathcal{C}) = 2^{n-r} = 2^k}$$

where $k = n - r$ is the number of **logical qubits** encoded.

**Proof Sketch:**

Each independent generator $g_i$ has eigenvalues $\pm 1$, splitting the Hilbert space:
$$(\mathbb{C}^2)^{\otimes n} = V_{+1}^{(i)} \oplus V_{-1}^{(i)}$$

Since generators commute, we can simultaneously diagonalize. With $r$ generators:
$$\dim(\mathcal{C}) = \frac{2^n}{2^r} = 2^{n-r}$$

### Code Parameters

An $[[n, k, d]]$ stabilizer code has:
- $n$ physical qubits
- $k = n - r$ logical qubits (where $r$ = number of independent stabilizer generators)
- $d$ = code distance

**Examples:**
- Bit-flip [[3,1,1]]: $n=3$, $r=2$ generators, $k=1$ logical qubit
- Shor [[9,1,3]]: $n=9$, $r=8$ generators, $k=1$ logical qubit
- Steane [[7,1,3]]: $n=7$, $r=6$ generators, $k=1$ logical qubit

---

## Binary Symplectic Representation

### Efficient Encoding of Paulis

For computational efficiency, we represent Paulis using binary vectors.

**Single-Qubit Encoding:**

| Pauli | X-part | Z-part | Binary $(a|b)$ |
|-------|--------|--------|----------------|
| $I$ | 0 | 0 | $(0|0)$ |
| $X$ | 1 | 0 | $(1|0)$ |
| $Z$ | 0 | 1 | $(0|1)$ |
| $Y = iXZ$ | 1 | 1 | $(1|1)$ |

**n-Qubit Encoding:**

For $P = X^{a_1}Z^{b_1} \otimes \cdots \otimes X^{a_n}Z^{b_n}$:

$$P \mapsto (\mathbf{a}|\mathbf{b}) = (a_1, \ldots, a_n | b_1, \ldots, b_n) \in \mathbb{Z}_2^{2n}$$

**Example:**
$$X_1Z_2Y_3 = (X \otimes Z \otimes Y) \mapsto (1,0,1 | 0,1,1)$$

### Symplectic Inner Product

**Definition:**

For $\mathbf{u} = (\mathbf{a}|\mathbf{b})$ and $\mathbf{v} = (\mathbf{a}'|\mathbf{b}')$:

$$\boxed{\mathbf{u} \odot \mathbf{v} = \mathbf{a} \cdot \mathbf{b}' + \mathbf{a}' \cdot \mathbf{b} \pmod 2}$$

$$= \sum_{j=1}^{n} (a_j b'_j + a'_j b_j) \pmod 2$$

**Theorem (Commutation via Symplectic Product):**

$$PQ = (-1)^{\mathbf{u} \odot \mathbf{v}} QP$$

**Corollary:** $P$ and $Q$ commute if and only if $\mathbf{u} \odot \mathbf{v} = 0$.

### Stabilizer Parity-Check Matrix

The stabilizer generators can be arranged into a matrix:

$$H = \begin{pmatrix} \mathbf{a}_1 & \mathbf{b}_1 \\ \mathbf{a}_2 & \mathbf{b}_2 \\ \vdots & \vdots \\ \mathbf{a}_r & \mathbf{b}_r \end{pmatrix} = \begin{pmatrix} H_X & H_Z \end{pmatrix}$$

where row $i$ encodes generator $g_i$.

**Commutation Constraint:** For valid stabilizers:

$$\boxed{H_X H_Z^T + H_Z H_X^T = 0 \pmod 2}$$

(Each row must have even symplectic product with every other row.)

---

## Examples: Bit-Flip and Phase-Flip Codes

### Bit-Flip Code Revisited

**Stabilizer generators:**
- $g_1 = Z_1Z_2 = ZZI$
- $g_2 = Z_2Z_3 = IZZ$

**Binary representation:**
$$H = \begin{pmatrix} 0 & 0 & 0 & 1 & 1 & 0 \\ 0 & 0 & 0 & 0 & 1 & 1 \end{pmatrix} = \begin{pmatrix} H_X & H_Z \end{pmatrix} = \begin{pmatrix} 000 & 110 \\ 000 & 011 \end{pmatrix}$$

**Code parameters:** $[[3, 3-2, ?]] = [[3,1,?]]$

**Verify commutation:** $H_X H_Z^T + H_Z H_X^T = 0 + \begin{pmatrix} 110 \\ 011 \end{pmatrix} \begin{pmatrix} 1 & 0 \\ 1 & 1 \\ 0 & 1 \end{pmatrix} = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}$?

Wait, let me recalculate. $H_Z^T = \begin{pmatrix} 1 & 0 \\ 1 & 1 \\ 0 & 1 \end{pmatrix}$

$H_Z H_Z^T = \begin{pmatrix} 110 \\ 011 \end{pmatrix} \begin{pmatrix} 1 & 0 \\ 1 & 1 \\ 0 & 1 \end{pmatrix} = \begin{pmatrix} 1+1 & 0+1 \\ 0+1 & 1+1 \end{pmatrix} = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}$

Hmm, this isn't zero. But since $H_X = 0$, the constraint is just $H_Z H_Z^T + 0 = 0$, which requires the Z stabilizers to be mutually orthogonal under symplectic product.

Actually, for pure Z-type stabilizers, commutation is automatic: $[Z_iZ_j, Z_kZ_l] = 0$ always.

The parity-check matrix approach needs refinement for pure Z or pure X stabilizers. Let me present the full symplectic product calculation.

**Full symplectic check:**
- $g_1 = (000|110)$, $g_2 = (000|011)$
- $g_1 \odot g_2 = (000) \cdot (011) + (000) \cdot (110) = 0 + 0 = 0$ ✓

### Phase-Flip Code

**Stabilizer generators:**
- $g_1 = X_1X_2 = XXI$
- $g_2 = X_2X_3 = IXX$

**Binary representation:**
$$H = \begin{pmatrix} 110 & 000 \\ 011 & 000 \end{pmatrix}$$

**Symplectic check:**
- $g_1 \odot g_2 = (110) \cdot (000) + (000) \cdot (011) = 0$ ✓

---

## Syndrome Measurement Revisited

### Stabilizer Eigenvalues as Syndromes

For a state $|\psi\rangle$ (possibly with errors), measuring stabilizer $g$ gives:
- $+1$ if $g|\psi\rangle = +|\psi\rangle$
- $-1$ if $g|\psi\rangle = -|\psi\rangle$

**Syndrome:** The tuple of measurement outcomes $(s_1, s_2, \ldots, s_r)$ where $s_i = 0$ for $+1$ and $s_i = 1$ for $-1$.

### Error Detection via Anticommutation

**Theorem:** If error $E$ anticommutes with stabilizer $g$:
$$gE|\psi_L\rangle = -Eg|\psi_L\rangle = -E|\psi_L\rangle$$

The state $E|\psi_L\rangle$ has eigenvalue $-1$ under $g$.

**Syndrome interpretation:** The syndrome reveals which stabilizers anticommute with the error.

---

## Worked Examples

### Example 1: Verify Bit-Flip Stabilizers

**Problem:** Verify that $Z_1Z_2$ and $Z_2Z_3$ stabilize $|000\rangle$ and $|111\rangle$.

**Solution:**

For $|000\rangle$:
- $Z_1Z_2|000\rangle = (+1)(+1)|000\rangle = |000\rangle$ ✓
- $Z_2Z_3|000\rangle = (+1)(+1)|000\rangle = |000\rangle$ ✓

For $|111\rangle$:
- $Z_1Z_2|111\rangle = (-1)(-1)|111\rangle = |111\rangle$ ✓
- $Z_2Z_3|111\rangle = (-1)(-1)|111\rangle = |111\rangle$ ✓

Both generators have eigenvalue +1 on both codewords.

### Example 2: Syndrome from Anticommutation

**Problem:** Show that $X_2$ error on bit-flip code produces syndrome $(1,1)$.

**Solution:**

Binary representation: $X_2 = (010|000)$

Symplectic products with generators:
- $X_2 \odot g_1 = (010)(110) + (000)(000) = 0+1+0 = 1$ (anticommute)
- $X_2 \odot g_2 = (010)(011) + (000)(000) = 0+1+0 = 1$ (anticommute)

Syndrome: $(1, 1)$ ✓

### Example 3: Binary Symplectic Calculation

**Problem:** Do $X_1Z_2$ and $Z_1X_3$ commute?

**Solution:**

Binary representations:
- $X_1Z_2 = (100|010)$
- $Z_1X_3 = (001|100)$

Symplectic product:
$$\mathbf{u} \odot \mathbf{v} = (100)(100) + (001)(010) = 1 + 0 = 1$$

Since $\mathbf{u} \odot \mathbf{v} = 1 \neq 0$, they **anticommute**.

Verify: $X_1Z_2 \cdot Z_1X_3 = X_1Z_1 \otimes Z_2I \otimes IX_3 = -Z_1X_1 \otimes Z_2 \otimes X_3 = -(Z_1X_3)(X_1Z_2)$ ✓

---

## Practice Problems

### Problem Set A: Direct Application

**A.1** Write out all 16 elements of $\mathcal{P}_1$ (with phases).

**A.2** Convert $Y_1X_2Z_3$ to binary symplectic form.

**A.3** Using binary vectors, determine if $X_1X_2$ and $Z_2Z_3$ commute.

### Problem Set B: Intermediate

**B.1** Show that any stabilizer group $\mathcal{S}$ with $r$ generators has exactly $2^r$ elements.

**B.2** For the phase-flip code, write down the stabilizer parity-check matrix $H$ and verify the commutation constraint.

**B.3** Prove that if $-I \in \mathcal{S}$, then the code space is trivial (only contains the zero vector).

### Problem Set C: Challenging

**C.1** Prove that two n-qubit Paulis either commute or anticommute (no other possibility).

**C.2** Given stabilizer generators $g_1 = XZZXI$ and $g_2 = IXZZX$, find a third generator $g_3$ that commutes with both and is independent.

**C.3** Show that for an $[[n,k,d]]$ stabilizer code, the number of independent stabilizer generators is exactly $n-k$.

---

## Computational Lab: Stabilizer Framework

```python
"""
Day 687 Computational Lab: Stabilizer Formalism
===============================================

Implementing the mathematical framework for stabilizer codes.
"""

import numpy as np
from typing import List, Tuple, Set
from itertools import product

# =============================================================================
# Part 1: Pauli Group Implementation
# =============================================================================

# Pauli matrices
I = np.array([[1, 0], [0, 1]], dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)

PAULIS = {'I': I, 'X': X, 'Y': Y, 'Z': Z}

def tensor(*args):
    """Compute tensor product."""
    result = args[0]
    for arg in args[1:]:
        result = np.kron(result, arg)
    return result

print("=" * 65)
print("PART 1: Pauli Group Structure")
print("=" * 65)

# Verify Pauli commutation/anticommutation
print("\nPauli commutation table:")
print("    ", end="")
for p2 in ['I', 'X', 'Y', 'Z']:
    print(f"  {p2}  ", end="")
print()

for p1 in ['I', 'X', 'Y', 'Z']:
    print(f" {p1} ", end="")
    for p2 in ['I', 'X', 'Y', 'Z']:
        P1, P2 = PAULIS[p1], PAULIS[p2]
        comm = P1 @ P2 - P2 @ P1
        if np.allclose(comm, 0):
            print("  +  ", end="")  # commute
        else:
            print("  -  ", end="")  # anticommute
    print()

# =============================================================================
# Part 2: Binary Symplectic Representation
# =============================================================================

print("\n" + "=" * 65)
print("PART 2: Binary Symplectic Representation")
print("=" * 65)

class PauliBinary:
    """Binary symplectic representation of Pauli operators."""

    def __init__(self, x_part: np.ndarray, z_part: np.ndarray):
        """
        Initialize Pauli in binary form.
        x_part[i] = 1 if X acts on qubit i
        z_part[i] = 1 if Z acts on qubit i
        """
        self.x = np.array(x_part, dtype=int) % 2
        self.z = np.array(z_part, dtype=int) % 2
        self.n = len(self.x)

    @classmethod
    def from_string(cls, s: str):
        """Create from string like 'XZIY'."""
        n = len(s)
        x = np.zeros(n, dtype=int)
        z = np.zeros(n, dtype=int)
        for i, c in enumerate(s):
            if c == 'X':
                x[i] = 1
            elif c == 'Z':
                z[i] = 1
            elif c == 'Y':
                x[i] = 1
                z[i] = 1
        return cls(x, z)

    def to_string(self) -> str:
        """Convert to string representation."""
        result = ""
        for i in range(self.n):
            if self.x[i] == 0 and self.z[i] == 0:
                result += "I"
            elif self.x[i] == 1 and self.z[i] == 0:
                result += "X"
            elif self.x[i] == 0 and self.z[i] == 1:
                result += "Z"
            else:
                result += "Y"
        return result

    def symplectic_product(self, other: 'PauliBinary') -> int:
        """Compute symplectic inner product mod 2."""
        return (np.dot(self.x, other.z) + np.dot(other.x, self.z)) % 2

    def commutes_with(self, other: 'PauliBinary') -> bool:
        """Check if this Pauli commutes with another."""
        return self.symplectic_product(other) == 0

    def multiply(self, other: 'PauliBinary') -> 'PauliBinary':
        """Multiply two Paulis (ignoring phase)."""
        return PauliBinary(
            (self.x + other.x) % 2,
            (self.z + other.z) % 2
        )

    def weight(self) -> int:
        """Return weight (number of non-identity positions)."""
        return sum((self.x[i] | self.z[i]) for i in range(self.n))

    def to_matrix(self) -> np.ndarray:
        """Convert to matrix representation."""
        ops = []
        for i in range(self.n):
            if self.x[i] == 0 and self.z[i] == 0:
                ops.append(I)
            elif self.x[i] == 1 and self.z[i] == 0:
                ops.append(X)
            elif self.x[i] == 0 and self.z[i] == 1:
                ops.append(Z)
            else:
                ops.append(Y)
        return tensor(*ops) if ops else np.array([[1]])

    def __repr__(self):
        return f"PauliBinary({self.to_string()})"


# Test binary representation
print("\nTesting binary symplectic representation:")
p1 = PauliBinary.from_string("XZI")
p2 = PauliBinary.from_string("ZIX")

print(f"  P1 = {p1.to_string()}: x={p1.x}, z={p1.z}")
print(f"  P2 = {p2.to_string()}: x={p2.x}, z={p2.z}")
print(f"  Symplectic product: {p1.symplectic_product(p2)}")
print(f"  Commute: {p1.commutes_with(p2)}")

# Verify with matrix multiplication
M1 = p1.to_matrix()
M2 = p2.to_matrix()
comm = M1 @ M2 - M2 @ M1
print(f"  Matrix commutator zero: {np.allclose(comm, 0)}")

# =============================================================================
# Part 3: Stabilizer Group Class
# =============================================================================

print("\n" + "=" * 65)
print("PART 3: Stabilizer Group Implementation")
print("=" * 65)

class StabilizerGroup:
    """Represents a stabilizer group via its generators."""

    def __init__(self, generators: List[PauliBinary]):
        self.generators = generators
        self.n = generators[0].n if generators else 0
        self.r = len(generators)
        self._validate()

    def _validate(self):
        """Check that generators commute and don't generate -I."""
        for i, g1 in enumerate(self.generators):
            for j, g2 in enumerate(self.generators):
                if i < j:
                    if not g1.commutes_with(g2):
                        raise ValueError(f"Generators {i} and {j} don't commute!")

    def num_logical_qubits(self) -> int:
        """Return number of encoded logical qubits."""
        return self.n - self.r

    def get_syndrome(self, error: PauliBinary) -> Tuple[int, ...]:
        """Get syndrome for an error."""
        return tuple(g.symplectic_product(error) for g in self.generators)

    def parity_check_matrix(self) -> np.ndarray:
        """Return the stabilizer parity-check matrix [H_X | H_Z]."""
        H = np.zeros((self.r, 2 * self.n), dtype=int)
        for i, g in enumerate(self.generators):
            H[i, :self.n] = g.x
            H[i, self.n:] = g.z
        return H

    def __repr__(self):
        return f"StabilizerGroup({[g.to_string() for g in self.generators]})"


# Create bit-flip code stabilizer group
bf_g1 = PauliBinary.from_string("ZZI")
bf_g2 = PauliBinary.from_string("IZZ")
bit_flip_stab = StabilizerGroup([bf_g1, bf_g2])

print(f"\nBit-flip code stabilizers: {bit_flip_stab}")
print(f"  n = {bit_flip_stab.n}, r = {bit_flip_stab.r}")
print(f"  Logical qubits k = {bit_flip_stab.num_logical_qubits()}")
print(f"  Parity-check matrix H:")
print(f"    {bit_flip_stab.parity_check_matrix()}")

# Test syndromes
print("\n  Syndrome table:")
errors = ['III', 'XII', 'IXI', 'IIX']
for e_str in errors:
    e = PauliBinary.from_string(e_str)
    syn = bit_flip_stab.get_syndrome(e)
    print(f"    {e_str}: syndrome = {syn}")

# =============================================================================
# Part 4: Phase-Flip Code
# =============================================================================

print("\n" + "=" * 65)
print("PART 4: Phase-Flip Code Analysis")
print("=" * 65)

pf_g1 = PauliBinary.from_string("XXI")
pf_g2 = PauliBinary.from_string("IXX")
phase_flip_stab = StabilizerGroup([pf_g1, pf_g2])

print(f"Phase-flip code stabilizers: {phase_flip_stab}")
print(f"  Parity-check matrix H:")
print(f"    {phase_flip_stab.parity_check_matrix()}")

# Test Z error syndromes
print("\n  Z error syndrome table:")
errors = ['III', 'ZII', 'IZI', 'IIZ']
for e_str in errors:
    e = PauliBinary.from_string(e_str)
    syn = phase_flip_stab.get_syndrome(e)
    print(f"    {e_str}: syndrome = {syn}")

# =============================================================================
# Part 5: Shor Code Stabilizers
# =============================================================================

print("\n" + "=" * 65)
print("PART 5: Shor [[9,1,3]] Code Stabilizers")
print("=" * 65)

# Shor code has 8 generators
shor_generators = [
    # ZZ type within blocks (detect X errors)
    PauliBinary.from_string("ZZIIIIII"),   # Z1Z2
    PauliBinary.from_string("IZZIIIIII")[:9] if False else PauliBinary(
        np.array([0,0,0,0,0,0,0,0,0]),
        np.array([1,1,0,0,0,0,0,0,0])
    ),
]

# Let's build it more carefully
shor_gens_str = [
    "ZZIIIIIII",  # Z1Z2
    "IZZIIIIIII"[:9],  # Will fix
]

# Build Shor stabilizers properly
shor_g = []
# Block 1 ZZ
shor_g.append(PauliBinary(np.zeros(9,int), np.array([1,1,0,0,0,0,0,0,0])))
shor_g.append(PauliBinary(np.zeros(9,int), np.array([0,1,1,0,0,0,0,0,0])))
# Block 2 ZZ
shor_g.append(PauliBinary(np.zeros(9,int), np.array([0,0,0,1,1,0,0,0,0])))
shor_g.append(PauliBinary(np.zeros(9,int), np.array([0,0,0,0,1,1,0,0,0])))
# Block 3 ZZ
shor_g.append(PauliBinary(np.zeros(9,int), np.array([0,0,0,0,0,0,1,1,0])))
shor_g.append(PauliBinary(np.zeros(9,int), np.array([0,0,0,0,0,0,0,1,1])))
# XXX type across blocks
shor_g.append(PauliBinary(np.array([1,1,1,1,1,1,0,0,0]), np.zeros(9,int)))
shor_g.append(PauliBinary(np.array([0,0,0,1,1,1,1,1,1]), np.zeros(9,int)))

shor_code = StabilizerGroup(shor_g)

print(f"Shor code: n={shor_code.n}, r={shor_code.r}, k={shor_code.num_logical_qubits()}")
print("\nGenerators:")
for i, g in enumerate(shor_code.generators):
    print(f"  g{i+1} = {g.to_string()}")

# =============================================================================
# Part 6: Visualization
# =============================================================================

import matplotlib.pyplot as plt

fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Plot 1: Stabilizer framework diagram
ax1 = axes[0]
ax1.axis('off')

framework = """
┌──────────────────────────────────────────────────────────┐
│              STABILIZER FORMALISM                         │
├──────────────────────────────────────────────────────────┤
│                                                           │
│  Pauli Group P_n:                                         │
│    • 4^(n+1) elements                                     │
│    • All pairs commute OR anticommute                     │
│                                                           │
│  Stabilizer Group S ⊆ P_n:                               │
│    • Abelian (all elements commute)                       │
│    • Does not contain -I                                  │
│    • r independent generators → |S| = 2^r                │
│                                                           │
│  Code Space C:                                            │
│    • Joint +1 eigenspace of all S ∈ S                    │
│    • dim(C) = 2^(n-r) = 2^k                              │
│    • [[n, k, d]] notation                                 │
│                                                           │
│  Syndrome:                                                │
│    • Tuple of stabilizer eigenvalues                      │
│    • Error E anticommutes with g → flips g eigenvalue    │
│                                                           │
│  Binary Symplectic Form:                                  │
│    • P ↔ (x|z) ∈ Z_2^(2n)                                │
│    • Commute ⟺ x·z' + x'·z = 0 (mod 2)                  │
│                                                           │
└──────────────────────────────────────────────────────────┘
"""
ax1.text(0.02, 0.98, framework, transform=ax1.transAxes,
         fontsize=9, verticalalignment='top', fontfamily='monospace',
         bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.8))
ax1.set_title('Stabilizer Formalism Summary')

# Plot 2: Code comparison
ax2 = axes[1]

codes_data = {
    'Code': ['Bit-flip', 'Phase-flip', 'Shor', 'Steane'],
    'n': [3, 3, 9, 7],
    'k': [1, 1, 1, 1],
    'r': [2, 2, 8, 6],
}

x = np.arange(len(codes_data['Code']))
width = 0.25

bars1 = ax2.bar(x - width, codes_data['n'], width, label='n (physical)', color='steelblue')
bars2 = ax2.bar(x, codes_data['r'], width, label='r (generators)', color='coral')
bars3 = ax2.bar(x + width, codes_data['k'], width, label='k (logical)', color='seagreen')

ax2.set_xlabel('Code')
ax2.set_ylabel('Count')
ax2.set_title('Stabilizer Code Parameters')
ax2.set_xticks(x)
ax2.set_xticklabels(codes_data['Code'])
ax2.legend()
ax2.grid(True, alpha=0.3, axis='y')

# Add value labels
for bars in [bars1, bars2, bars3]:
    for bar in bars:
        height = bar.get_height()
        ax2.annotate(f'{int(height)}',
                    xy=(bar.get_x() + bar.get_width() / 2, height),
                    xytext=(0, 3), textcoords="offset points",
                    ha='center', va='bottom', fontsize=9)

plt.tight_layout()
plt.savefig('day_687_stabilizer_formalism.png', dpi=150, bbox_inches='tight')
plt.show()

print("\n" + "=" * 65)
print("Figure saved: day_687_stabilizer_formalism.png")

# =============================================================================
# Summary
# =============================================================================

print("\n" + "=" * 65)
print("SUMMARY")
print("=" * 65)

summary = """
┌────────────────────────────────────────────────────────────────┐
│             Day 687: Stabilizer Formalism Complete              │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│ KEY CONCEPTS:                                                   │
│ ✓ Pauli group P_n: 4^(n+1) elements, commute/anticommute       │
│ ✓ Stabilizer group S: abelian subgroup, no -I                  │
│ ✓ Code space: joint +1 eigenspace, dim = 2^(n-r)               │
│ ✓ Binary symplectic: P ↔ (x|z), efficient commutation check   │
│ ✓ Syndrome: stabilizer eigenvalues reveal error                │
│                                                                 │
│ FORMULAS:                                                       │
│ • Code dimension: dim(C) = 2^k where k = n - r                 │
│ • Symplectic product: u ⊙ v = x·z' + x'·z (mod 2)             │
│ • Commutation: [P,Q] = 0 ⟺ u ⊙ v = 0                          │
│                                                                 │
│ NEXT: Day 688 - Pauli Group Deep Dive                          │
└────────────────────────────────────────────────────────────────┘
"""
print(summary)

print("\n✅ Day 687 Lab Complete!")
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| Pauli group size | $\|\mathcal{P}_n\| = 4^{n+1}$ |
| Stabilizer group size | $\|\mathcal{S}\| = 2^r$ for $r$ independent generators |
| Code dimension | $\dim(\mathcal{C}) = 2^{n-r} = 2^k$ |
| Symplectic product | $\mathbf{u} \odot \mathbf{v} = \mathbf{a} \cdot \mathbf{b}' + \mathbf{a}' \cdot \mathbf{b} \pmod 2$ |
| Commutation criterion | $[P, Q] = 0 \iff \mathbf{u} \odot \mathbf{v} = 0$ |

### Main Takeaways

1. **Stabilizer formalism** generalizes the structure we saw in bit-flip and phase-flip codes
2. **Pauli group** elements either commute or anticommute — critical for code design
3. **Stabilizer generators** define the code space as joint +1 eigenspace
4. **Binary symplectic representation** enables efficient computation
5. **Syndromes** arise from anticommutation with errors

---

## Daily Checklist

- [ ] I can define the Pauli group $\mathcal{P}_n$
- [ ] I understand stabilizer groups and their properties
- [ ] I can compute code space dimension from generator count
- [ ] I can use binary symplectic representation
- [ ] I understand how syndromes relate to anticommutation

---

## Preview: Day 688

Tomorrow we go deeper into the Pauli group:
- Centralizer and normalizer
- Logical operators
- Weight and distance
- Gottesman-Knill theorem preview

---

**Day 687 Complete!** Week 99: 1/7 days (14%)

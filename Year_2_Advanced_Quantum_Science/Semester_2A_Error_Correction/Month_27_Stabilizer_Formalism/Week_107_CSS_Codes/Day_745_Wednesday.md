# Day 745: CSS Code Examples

## Overview

**Day:** 745 of 1008
**Week:** 107 (CSS Codes & Related Constructions)
**Month:** 27 (Stabilizer Formalism)
**Topic:** Concrete CSS Code Constructions

---

## Schedule

| Block | Time | Duration | Focus |
|-------|------|----------|-------|
| Morning | 9:00 AM - 12:30 PM | 3.5 hrs | Steane and repetition codes |
| Afternoon | 2:00 PM - 5:30 PM | 3.5 hrs | Reed-Muller CSS codes |
| Evening | 7:00 PM - 9:00 PM | 2 hrs | Computational lab |

---

## Learning Objectives

By the end of today, you should be able to:

1. **Construct** the Steane code from the Hamming code step-by-step
2. **Build** repetition-based CSS codes of any size
3. **Design** CSS codes from Reed-Muller codes
4. **Compare** different CSS constructions
5. **Analyze** encoding circuits for CSS codes
6. **Identify** the trade-offs in CSS code design

---

## The Steane [[7,1,3]] Code

### Construction from Hamming Code

The **[7, 4, 3] Hamming code** corrects single bit-flip errors.

**Parity check matrix:**
$$H = \begin{pmatrix}
0 & 0 & 0 & 1 & 1 & 1 & 1 \\
0 & 1 & 1 & 0 & 0 & 1 & 1 \\
1 & 0 & 1 & 0 & 1 & 0 & 1
\end{pmatrix}$$

**Generator matrix:**
$$G = \begin{pmatrix}
1 & 0 & 0 & 0 & 0 & 1 & 1 \\
0 & 1 & 0 & 0 & 1 & 0 & 1 \\
0 & 0 & 1 & 0 & 1 & 1 & 0 \\
0 & 0 & 0 & 1 & 1 & 1 & 1
\end{pmatrix}$$

### Verifying Self-Orthogonality

The Hamming code satisfies $C^\perp \subseteq C$:

**C⊥** is generated by rows of H (the [7, 3, 4] simplex code).

Check: Each row of H must be a codeword of C (i.e., in kernel of H):
- Row 1: $(0,0,0,1,1,1,1) \to H \cdot v^T = (0,0,0)$ ✓
- Row 2: $(0,1,1,0,0,1,1) \to H \cdot v^T = (0,0,0)$ ✓
- Row 3: $(1,0,1,0,1,0,1) \to H \cdot v^T = (0,0,0)$ ✓

### Steane Code Stabilizers

Using CSS(C, C) where C is the Hamming code:

**X Stabilizers** (from C⊥):
$$\begin{aligned}
S_X^{(1)} &= X_4 X_5 X_6 X_7 = IIIXXXX \\
S_X^{(2)} &= X_2 X_3 X_6 X_7 = IXXIIXX \\
S_X^{(3)} &= X_1 X_3 X_5 X_7 = XIXIXIX
\end{aligned}$$

**Z Stabilizers** (from C⊥):
$$\begin{aligned}
S_Z^{(1)} &= Z_4 Z_5 Z_6 Z_7 = IIIZZZZ \\
S_Z^{(2)} &= Z_2 Z_3 Z_6 Z_7 = IZZIIZZ \\
S_Z^{(3)} &= Z_1 Z_3 Z_5 Z_7 = ZIZIZIZ
\end{aligned}$$

### Logical Operators

**Logical X:** Any weight-7 X operator from C \ C⊥
$$\bar{X} = X_1 X_2 X_3 X_4 X_5 X_6 X_7 = X^{\otimes 7}$$

**Logical Z:** Any weight-7 Z operator from C \ C⊥
$$\bar{Z} = Z_1 Z_2 Z_3 Z_4 Z_5 Z_6 Z_7 = Z^{\otimes 7}$$

### Codewords

$$|\bar{0}\rangle = \frac{1}{\sqrt{8}} \sum_{\mathbf{c} \in C^\perp} |\mathbf{c}\rangle$$

$$|\bar{1}\rangle = \frac{1}{\sqrt{8}} \sum_{\mathbf{c} \in C^\perp} |(\mathbf{1} + \mathbf{c})\rangle$$

where $\mathbf{1} = (1,1,1,1,1,1,1)$.

**Explicit:**
$$|\bar{0}\rangle = \frac{1}{\sqrt{8}}(|0000000\rangle + |1010101\rangle + |0110011\rangle + |1100110\rangle$$
$$+ |0001111\rangle + |1011010\rangle + |0111100\rangle + |1101001\rangle)$$

---

## Repetition-Based CSS Codes

### The [[3,1,1]] Bit-Flip Code

**Classical code:** [3, 1, 3] repetition code

**Parity check:**
$$H = \begin{pmatrix} 1 & 1 & 0 \\ 0 & 1 & 1 \end{pmatrix}$$

**Dual code:** [3, 2, 2] (NOT self-orthogonal!)

Since C⊥ ⊄ C, we cannot use CSS(C, C).

**Alternative:** Use CSS(C₁, C₂) with C₁ = entire $\mathbb{F}_2^3$ and C₂ = repetition code.

Actually, the 3-qubit bit-flip code is:
- Stabilizers: $Z_1Z_2$, $Z_2Z_3$ (detects X errors)
- No X stabilizers (doesn't correct Z errors)

This is NOT a proper CSS code—it's only half of one.

### The [[9,1,3]] Shor Code

Combines bit-flip and phase-flip protection:

**Structure:** 3 repetition codes of 3 qubits each, in superposition.

$$|\bar{0}\rangle = \frac{1}{2\sqrt{2}}(|000\rangle + |111\rangle)^{\otimes 3}$$
$$|\bar{1}\rangle = \frac{1}{2\sqrt{2}}(|000\rangle - |111\rangle)^{\otimes 3}$$

**X Stabilizers:** $X_1X_2X_3X_4X_5X_6$, $X_4X_5X_6X_7X_8X_9$

**Z Stabilizers:** $Z_1Z_2$, $Z_2Z_3$, $Z_4Z_5$, $Z_5Z_6$, $Z_7Z_8$, $Z_8Z_9$

**CSS interpretation:**
- C₁ = code with H₁ detecting X errors (Z stabilizers)
- C₂ = code with H₂ detecting Z errors (X stabilizers)

### General Repetition CSS

For length n repetition code [n, 1, n]:

**CSS construction:** Cannot make CSS(C, C) work for repetition codes since they're not self-orthogonal.

**Workaround:** Use product constructions (Shor code is such a product).

---

## Reed-Muller CSS Codes

### Reed-Muller Code Review

**RM(r, m):** Code with parameters $[2^m, \sum_{i=0}^r \binom{m}{i}, 2^{m-r}]$

**Key property:**
$$RM(r, m)^\perp = RM(m-r-1, m)$$

### CSS from Reed-Muller

For CSS construction, need $RM(m-r-1, m) \subseteq RM(r, m)$.

This holds when $m - r - 1 \leq r$, i.e., $r \geq (m-1)/2$.

**Self-orthogonal RM codes:** RM(r, m) with $r = (m-1)/2$ (when m is odd).

### Example: RM(1, 3) = [8, 4, 4]

**RM(1, 3)** has:
- n = 8
- k = 1 + 3 = 4
- d = 4

**RM(1, 3)⊥ = RM(0, 3)** = [8, 1, 8] (repetition code)

Since RM(0, 3) ⊂ RM(1, 3), this gives:
$$CSS(RM(1,3), RM(1,3)) = [[8, 2 \cdot 4 - 8, d]] = [[8, 0, d]]$$

No logical qubits! This is because RM(1,3) is self-dual.

### Example: RM(1, 4) and RM(2, 4)

**RM(1, 4) = [16, 5, 8]**
**RM(2, 4) = [16, 11, 4]**

**Relation:** $RM(1, 4)^\perp = RM(2, 4)$

For CSS(RM(2,4), RM(1,4)):
- Need $RM(1, 4)^\perp = RM(2, 4) \subseteq RM(2, 4)$ ✓
- k = 11 + 5 - 16 = 0

Still no logical qubits.

**For logical qubits:** Use asymmetric CSS(C₁, C₂) with C₁ ≠ C₂.

### Punctured Reed-Muller CSS

**Strategy:** Puncture or shorten RM codes to get CSS codes with k > 0.

**Example:** Punctured RM(1, 4) gives [15, 5, 7] code.

$$CSS(RM(1,4)_{punct}, RM(1,4)_{punct}) \to [[15, k, d]]$$

---

## Comparison of CSS Codes

### Parameter Comparison

| Code | [[n, k, d]] | Classical Source | Notes |
|------|-------------|------------------|-------|
| Steane | [[7, 1, 3]] | Hamming [7,4,3] | Smallest perfect CSS |
| Shor | [[9, 1, 3]] | Repetition product | Historical first |
| [[15, 1, 3]] | [[15, 1, 3]] | BCH [15, 11, 3] | More qubits, same d |
| [[23, 1, 7]] | [[23, 1, 7]] | Golay [23, 12, 7] | High distance |

### Rate vs. Distance Trade-off

**Rate:** $R = k/n$ (fraction of logical qubits)

| Code | n | k | d | Rate |
|------|---|---|---|------|
| Steane | 7 | 1 | 3 | 0.143 |
| [[15,7,3]] | 15 | 7 | 3 | 0.467 |
| [[23,1,7]] | 23 | 1 | 7 | 0.043 |

**Trade-off:** Higher distance typically means lower rate.

### Encoding Complexity

**Steane code:** 4 CNOT gates + Hadamards
**Shor code:** 8 CNOT gates + Hadamards
**Surface codes:** O(n) gates

---

## Encoding Circuits

### Steane Code Encoding

**Input:** $|\psi\rangle = \alpha|0\rangle + \beta|1\rangle$

**Circuit:**
1. Start with $|\psi\rangle|0\rangle^{\otimes 6}$
2. Apply CNOTs from qubit 1 to qubits 4, 5, 6, 7
3. Apply Hadamards on qubits 1, 2, 3
4. Apply CNOTs for X stabilizer structure

**Simplified encoding:**
```
|ψ⟩ ─●─●─●─●─ H ─●───●─── |out_1⟩
|0⟩ ─┼─┼─┼─┼───── H ─┼─●─●─ |out_2⟩
|0⟩ ─┼─┼─┼─┼───── H ─●─┼─●─ |out_3⟩
|0⟩ ─⊕─┼─┼─┼───────●─●─┼─── |out_4⟩
|0⟩ ───⊕─┼─┼───────●───●─── |out_5⟩
|0⟩ ─────⊕─┼───────────●─── |out_6⟩
|0⟩ ───────⊕───────●─●─●─── |out_7⟩
```

### General CSS Encoding

For CSS(C₁, C₂):

1. **Classical encoding** for C₁ using generator G₁
2. **Hadamard layer** on first k positions
3. **Superposition creation** from C₂⊥

---

## Worked Examples

### Example 1: Verify Steane Code Properties

**Problem:** Show that all Steane stabilizers commute.

**Solution:**

X stabilizers: $S_X^{(1)} = IIIXXXX$, $S_X^{(2)} = IXXIIXX$, $S_X^{(3)} = XIXIXIX$

Z stabilizers: $S_Z^{(1)} = IIIZZZZ$, $S_Z^{(2)} = IZZIIZZ$, $S_Z^{(3)} = ZIZIZIZ$

**X-X commutation:** X operators always commute. ✓

**Z-Z commutation:** Z operators always commute. ✓

**X-Z commutation:** Check overlap parity.

$S_X^{(1)}$ and $S_Z^{(1)}$: X on {4,5,6,7}, Z on {4,5,6,7} → overlap = 4 (even) ✓

$S_X^{(1)}$ and $S_Z^{(2)}$: X on {4,5,6,7}, Z on {2,3,6,7} → overlap = 2 (even) ✓

$S_X^{(1)}$ and $S_Z^{(3)}$: X on {4,5,6,7}, Z on {1,3,5,7} → overlap = 2 (even) ✓

Continue for all pairs... all have even overlap. ✓

### Example 2: Count Steane Codewords

**Problem:** How many computational basis states appear in $|\bar{0}\rangle$?

**Solution:**

$|\bar{0}\rangle = \frac{1}{\sqrt{|C^\perp|}} \sum_{\mathbf{c} \in C^\perp} |\mathbf{c}\rangle$

C⊥ is the [7, 3, 4] simplex code with $|C^\perp| = 2^3 = 8$ codewords.

So 8 computational basis states appear in $|\bar{0}\rangle$.

### Example 3: CSS from BCH

**Problem:** Construct a CSS code from the [15, 11, 3] BCH code.

**Solution:**

BCH [15, 11, 3] has dual [15, 4, ?].

Check self-orthogonality: Need $H \cdot H^T = 0$.

The [15, 11, 3] BCH code has parity check:
$$H = \begin{pmatrix}
1 & 0 & 0 & 0 & 1 & 0 & 1 & 1 & 1 & 0 & 0 & 1 & 0 & 1 & 1 \\
0 & 1 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 & 0 \\
0 & 0 & 1 & 0 & 0 & 1 & 1 & 1 & 0 & 1 & 1 & 0 & 1 & 1 & 1 \\
0 & 0 & 0 & 1 & 1 & 0 & 0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 1
\end{pmatrix}$$

If self-orthogonal: CSS(C, C) = [[15, 2·11 - 15, d]] = [[15, 7, d]]

---

## Practice Problems

### Level 1: Direct Application

**P1.1** Write out all 8 codewords of the [7, 3, 4] simplex code (C⊥ for Hamming).

**P1.2** For the Steane code, compute the syndrome when an X error occurs on qubit 2.

**P1.3** How many physical qubits does a CSS code need to encode k logical qubits with classical [n, k₁] and [n, k₂] codes?

### Level 2: Intermediate

**P2.1** Design a [[9, 1, 3]] CSS code different from the Shor code.

**P2.2** Show that the Steane logical operators $\bar{X} = X^{\otimes 7}$ and $\bar{Z} = Z^{\otimes 7}$:
a) Commute with all stabilizers
b) Anti-commute with each other
c) Are not in the stabilizer group

**P2.3** For RM(2, 5) = [32, 16, 8], determine if CSS(C, C) is valid and find parameters.

### Level 3: Challenging

**P3.1** Prove that the Steane code is the smallest CSS code that corrects single-qubit errors.

**P3.2** Construct a CSS code with parameters [[23, 1, 7]] from the Golay code.

**P3.3** Design a CSS code family [[n, k, d]] where k/n → 1/2 as n → ∞.

---

## Computational Lab

```python
"""
Day 745: CSS Code Examples
==========================

Implementing and analyzing specific CSS code constructions.
"""

import numpy as np
from typing import List, Tuple, Dict
from itertools import product


def gf2_row_reduce(M: np.ndarray) -> Tuple[np.ndarray, int]:
    """Row reduce over GF(2)."""
    M = M.copy() % 2
    rows, cols = M.shape
    rank = 0

    for col in range(cols):
        pivot = None
        for row in range(rank, rows):
            if M[row, col] == 1:
                pivot = row
                break
        if pivot is None:
            continue

        M[[rank, pivot]] = M[[pivot, rank]]
        for row in range(rows):
            if row != rank and M[row, col] == 1:
                M[row] = (M[row] + M[rank]) % 2
        rank += 1

    return M, rank


class CSSCodeExample:
    """Detailed CSS code analysis."""

    def __init__(self, name: str, H_X: np.ndarray, H_Z: np.ndarray):
        """
        Initialize CSS code with X and Z parity checks.

        H_X detects Z errors (X stabilizers)
        H_Z detects X errors (Z stabilizers)
        """
        self.name = name
        self.H_X = np.array(H_X) % 2
        self.H_Z = np.array(H_Z) % 2
        self.n = self.H_X.shape[1]

        # Compute parameters
        _, rank_X = gf2_row_reduce(self.H_X)
        _, rank_Z = gf2_row_reduce(self.H_Z)
        self.k = self.n - rank_X - rank_Z

    def x_stabilizers(self) -> List[str]:
        """Return X stabilizers as Pauli strings."""
        stabs = []
        for row in self.H_X:
            pauli = ''.join('X' if b else 'I' for b in row)
            stabs.append(pauli)
        return stabs

    def z_stabilizers(self) -> List[str]:
        """Return Z stabilizers as Pauli strings."""
        stabs = []
        for row in self.H_Z:
            pauli = ''.join('Z' if b else 'I' for b in row)
            stabs.append(pauli)
        return stabs

    def verify_commutation(self) -> bool:
        """Verify X and Z stabilizers commute."""
        for x_row in self.H_X:
            for z_row in self.H_Z:
                overlap = np.sum(x_row * z_row) % 2
                if overlap != 0:
                    return False
        return True

    def x_syndrome(self, error: np.ndarray) -> np.ndarray:
        """Syndrome for X-type error (detected by Z stabilizers)."""
        return (self.H_Z @ error) % 2

    def z_syndrome(self, error: np.ndarray) -> np.ndarray:
        """Syndrome for Z-type error (detected by X stabilizers)."""
        return (self.H_X @ error) % 2

    def enumerate_codewords(self) -> List[np.ndarray]:
        """
        Enumerate basis states in |0_L⟩ for CSS code.

        For CSS codes, |0_L⟩ is superposition over C_X^⊥.
        """
        # C_X^⊥ is generated by H_X (rows are generators)
        # Find all linear combinations
        m = self.H_X.shape[0]
        codewords = []

        for coeffs in product([0, 1], repeat=m):
            c = np.zeros(self.n, dtype=int)
            for i, coef in enumerate(coeffs):
                if coef:
                    c = (c + self.H_X[i]) % 2
            codewords.append(c)

        return codewords

    def __repr__(self) -> str:
        return f"{self.name}: [[{self.n}, {self.k}]] CSS code"


def steane_code() -> CSSCodeExample:
    """The [[7,1,3]] Steane code."""
    H = np.array([
        [0, 0, 0, 1, 1, 1, 1],
        [0, 1, 1, 0, 0, 1, 1],
        [1, 0, 1, 0, 1, 0, 1]
    ])
    return CSSCodeExample("Steane", H, H)


def shor_code() -> CSSCodeExample:
    """The [[9,1,3]] Shor code."""
    # Z stabilizers (detect X errors within blocks)
    H_Z = np.array([
        [1, 1, 0, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 1, 1, 0],
        [0, 0, 0, 0, 0, 0, 0, 1, 1]
    ])

    # X stabilizers (detect Z errors between blocks)
    H_X = np.array([
        [1, 1, 1, 1, 1, 1, 0, 0, 0],
        [0, 0, 0, 1, 1, 1, 1, 1, 1]
    ])

    return CSSCodeExample("Shor", H_X, H_Z)


def five_qubit_code() -> CSSCodeExample:
    """
    The [[5,1,3]] perfect code.

    Note: This is NOT a CSS code! Including for comparison.
    """
    # The 5-qubit code has mixed X/Z stabilizers
    # Cannot be written in CSS form
    raise ValueError("[[5,1,3]] is not a CSS code!")


def repetition_css(n: int) -> CSSCodeExample:
    """
    [[n, 0, n]] repetition CSS code.

    This encodes 0 logical qubits but demonstrates structure.
    """
    # Z stabilizers: Z_i Z_{i+1}
    H_Z = np.zeros((n-1, n), dtype=int)
    for i in range(n-1):
        H_Z[i, i] = 1
        H_Z[i, i+1] = 1

    # X stabilizers: X on all qubits
    H_X = np.ones((1, n), dtype=int)

    return CSSCodeExample(f"Repetition-{n}", H_X, H_Z)


def surface_code_2x2() -> CSSCodeExample:
    """
    Smallest surface code on 2×2 lattice.

    Actually this gives [[4, 0, 2]] - no logical qubits.
    """
    # 4 qubits on edges of a square
    # 1 X stabilizer (face), 1 Z stabilizer (vertex)
    # But boundaries change this...

    # For proper [[4,1,2]]: need specific boundary
    H_X = np.array([
        [1, 1, 1, 1]  # X on all
    ])
    H_Z = np.array([
        [1, 1, 0, 0],
        [0, 0, 1, 1]
    ])

    return CSSCodeExample("Surface-2x2", H_X, H_Z)


# Demonstration
if __name__ == "__main__":
    print("=" * 60)
    print("Day 745: CSS Code Examples")
    print("=" * 60)

    # Example 1: Steane Code
    print("\n1. Steane [[7,1,3]] Code")
    print("-" * 40)

    steane = steane_code()
    print(steane)
    print(f"Commutation valid: {steane.verify_commutation()}")

    print("\nX Stabilizers:")
    for s in steane.x_stabilizers():
        print(f"  {s}")

    print("\nZ Stabilizers:")
    for s in steane.z_stabilizers():
        print(f"  {s}")

    # Codewords in |0_L⟩
    codewords = steane.enumerate_codewords()
    print(f"\n|0_L⟩ superposition over {len(codewords)} basis states:")
    for cw in codewords:
        print(f"  |{''.join(map(str, cw))}⟩")

    # Syndrome examples
    print("\nSyndrome examples:")
    for i in range(7):
        error = np.zeros(7, dtype=int)
        error[i] = 1
        x_syn = steane.x_syndrome(error)
        z_syn = steane.z_syndrome(error)
        print(f"  X on qubit {i+1}: Z-syndrome = {x_syn}")
        print(f"  Z on qubit {i+1}: X-syndrome = {z_syn}")

    # Example 2: Shor Code
    print("\n2. Shor [[9,1,3]] Code")
    print("-" * 40)

    shor = shor_code()
    print(shor)
    print(f"Commutation valid: {shor.verify_commutation()}")

    print("\nX Stabilizers (2 generators):")
    for s in shor.x_stabilizers():
        print(f"  {s}")

    print("\nZ Stabilizers (6 generators):")
    for s in shor.z_stabilizers():
        print(f"  {s}")

    # Example 3: Compare codes
    print("\n3. Code Comparison")
    print("-" * 40)

    codes = [steane, shor]
    print(f"{'Code':<15} {'n':>3} {'k':>3} {'X-stabs':>8} {'Z-stabs':>8}")
    print("-" * 40)
    for code in codes:
        n_x = len(code.x_stabilizers())
        n_z = len(code.z_stabilizers())
        print(f"{code.name:<15} {code.n:>3} {code.k:>3} {n_x:>8} {n_z:>8}")

    # Example 4: Repetition codes
    print("\n4. Repetition CSS Codes")
    print("-" * 40)

    for n in [3, 5, 7]:
        rep = repetition_css(n)
        print(f"Repetition-{n}: [[{rep.n}, {rep.k}]]")
        print(f"  X stabilizers: {len(rep.x_stabilizers())}")
        print(f"  Z stabilizers: {len(rep.z_stabilizers())}")

    # Example 5: Encoding verification
    print("\n5. Steane Code Logical Operators")
    print("-" * 40)

    # Logical X = X^⊗7
    X_L = np.ones(7, dtype=int)
    print(f"Logical X = {''.join(['X' if b else 'I' for b in X_L])}")

    # Check it commutes with all stabilizers
    z_syndrome = steane.z_syndrome(X_L)
    print(f"  Z-syndrome (should be 0): {z_syndrome}")

    # Logical Z = Z^⊗7
    Z_L = np.ones(7, dtype=int)
    print(f"Logical Z = {''.join(['Z' if b else 'I' for b in Z_L])}")
    x_syndrome = steane.x_syndrome(Z_L)
    print(f"  X-syndrome (should be 0): {x_syndrome}")

    # Check logical anticommutation: X_L and Z_L
    overlap = np.sum(X_L * Z_L) % 2
    print(f"\nX_L · Z_L overlap (should be 1 for anticommutation): {overlap}")

    print("\n" + "=" * 60)
    print("CSS codes: The workhorse of quantum error correction!")
    print("=" * 60)
```

---

## Summary

### CSS Code Gallery

| Code | Parameters | Classical Source | Codewords in |0⟩ |
|------|------------|------------------|---------------|
| Steane | [[7, 1, 3]] | Hamming [7,4,3] | 8 |
| Shor | [[9, 1, 3]] | Repetition × 3 | 8 |
| [[15, 7, 3]] | BCH [15, 11, 3] | 16 |
| [[23, 1, 7]] | Golay [23, 12, 7] | 2048 |

### Key Design Principles

1. **Self-orthogonal classical codes** simplify construction
2. **Higher distance** requires more physical qubits
3. **Steane code** is optimal for single-error correction
4. **Shor code** has historical significance but uses more qubits

---

## Daily Checklist

- [ ] I can construct the Steane code from the Hamming code
- [ ] I understand why Shor code uses 9 qubits
- [ ] I can enumerate codewords in |0_L⟩
- [ ] I can compute syndromes for X and Z errors
- [ ] I understand the trade-off between n, k, and d
- [ ] I can verify logical operators commute with stabilizers

---

## Preview: Day 746

Tomorrow we focus on **surface codes as CSS codes**:

- Toric code on periodic lattices
- Planar codes with boundaries
- Stabilizers from vertices and faces
- Logical operators as homology classes

Surface codes are the leading candidates for fault-tolerant quantum computing!

# Day 720: Subsystem Codes and Fault Tolerance

## Overview

**Date:** Day 720 of 1008
**Week:** 103 (Subsystem Codes)
**Month:** 26 (QEC Fundamentals II)
**Topic:** Fault-Tolerant Operations on Subsystem Codes

---

## Schedule

| Block | Time | Duration | Focus |
|-------|------|----------|-------|
| Morning | 9:00 AM - 12:30 PM | 3.5 hrs | Fault-tolerant syndrome extraction |
| Afternoon | 2:00 PM - 4:30 PM | 2.5 hrs | Transversal and logical gates |
| Evening | 7:00 PM - 8:00 PM | 1 hr | Implementation and circuits |

---

## Learning Objectives

By the end of this day, you should be able to:

1. **Design** fault-tolerant syndrome extraction circuits for subsystem codes
2. **Identify** transversal gates on Bacon-Shor and other subsystem codes
3. **Explain** gauge fixing and its role in universal computation
4. **Analyze** the fault-tolerance threshold for subsystem codes
5. **Compare** fault-tolerant protocols for stabilizer vs subsystem codes
6. **Construct** complete fault-tolerant gadgets for subsystem codes

---

## Core Content

### 1. Fault-Tolerant Syndrome Extraction

#### The Fault-Tolerance Criterion

**Definition:** A syndrome extraction circuit is **fault-tolerant** if:
1. A single fault creates at most one error in the data block
2. A pre-existing single error is not converted to a multi-qubit error
3. The syndrome correctly identifies correctable errors (up to fault effects)

#### Natural Fault Tolerance of Gauge Measurements

For weight-2 gauge operators:

```
Data q1: ─●─────
          │
Data q2: ─┼─●───
          │ │
Ancilla:  H─┴─┴─H─M
```

**Fault analysis:**
- Fault on ancilla before first CNOT: No data error
- Fault on ancilla between CNOTs: At most 1 data error (q2 only)
- Fault on data qubit: Single qubit error (correctable)

**Key insight:** Weight-2 measurements are automatically fault-tolerant!

#### Complete Syndrome Extraction Protocol

**For Bacon-Shor codes:**

**Step 1:** Measure all X-type gauge operators
- Each is $X_iX_j$ for horizontally adjacent pairs
- Weight-2 circuits, naturally fault-tolerant

**Step 2:** Measure all Z-type gauge operators
- Each is $Z_iZ_j$ for vertically adjacent pairs
- Weight-2 circuits, naturally fault-tolerant

**Step 3:** Compute stabilizer syndromes
- X-stabilizer syndrome: product of X-gauge outcomes in column pairs
- Z-stabilizer syndrome: product of Z-gauge outcomes in row pairs

**Step 4:** Decode and correct
- Use stabilizer syndromes for error identification
- Apply Pauli correction

---

### 2. Fault-Tolerant Gadgets

#### Definition of Gadgets

A **fault-tolerant gadget** is a circuit that:
1. Performs an operation on encoded data
2. Maintains fault tolerance (bounded error propagation)
3. Includes error correction as needed

#### Syndrome Extraction Gadget (EC Gadget)

**Input:** Potentially erroneous encoded state
**Output:** Corrected encoded state

```
|ψ_L⟩ ──┤ Gauge Measure ├──┤ Decode ├──┤ Correct ├── |ψ_L⟩ (corrected)
```

**For Bacon-Shor:**

```python
def EC_gadget_bacon_shor():
    """
    Error correction gadget for Bacon-Shor code.
    """
    # Step 1: Measure X-gauges
    x_syndromes = measure_x_gauges()

    # Step 2: Measure Z-gauges
    z_syndromes = measure_z_gauges()

    # Step 3: Compute stabilizer syndromes
    x_stab_syn = compute_x_stabilizer_syndrome(x_syndromes)
    z_stab_syn = compute_z_stabilizer_syndrome(z_syndromes)

    # Step 4: Decode
    x_correction = decode_x_errors(z_stab_syn)  # X errors from Z-syndrome
    z_correction = decode_z_errors(x_stab_syn)  # Z errors from X-syndrome

    # Step 5: Apply corrections
    apply_correction(x_correction, z_correction)
```

#### Gate Gadgets

**Structure of a fault-tolerant gate gadget:**

```
|ψ_L⟩ ──┤ EC ├──┤ Gate ├──┤ EC ├── |ψ'_L⟩
```

- Leading EC: Ensure input is in code space
- Gate: Apply logical operation
- Trailing EC: Correct any gate-induced errors

---

### 3. Transversal Gates on Subsystem Codes

#### Transversal Operations

A **transversal gate** applies single-qubit gates independently to each physical qubit.

**For Bacon-Shor $m \times n$ code:**

$$U_L = \bigotimes_{i,j} U_{i,j}$$

#### Transversal Gates Available

**Bacon-Shor codes support:**

| Gate | Implementation | Condition |
|------|----------------|-----------|
| $\bar{X}$ | $X^{\otimes n}$ on any row | Always |
| $\bar{Z}$ | $Z^{\otimes m}$ on any column | Always |
| $\bar{H}$ | $H^{\otimes mn}$ | Only if $m = n$ (square) |
| $\bar{S}$ | Not transversal | — |
| $\bar{T}$ | Not transversal | — |

#### Proof: Transversal Hadamard on Square Bacon-Shor

**Claim:** For $m = m$ (square lattice), $H^{\otimes m^2}$ implements logical $\bar{H}$.

**Proof:**

The gauge group is generated by:
- X-gauges: $X_{i,j}X_{i,j+1}$ (horizontal)
- Z-gauges: $Z_{i,j}Z_{i+1,j}$ (vertical)

Under $H^{\otimes m^2}$:
- $X_{i,j}X_{i,j+1} \mapsto Z_{i,j}Z_{i,j+1}$
- $Z_{i,j}Z_{i+1,j} \mapsto X_{i,j}X_{i+1,j}$

For square lattice: horizontal becomes vertical and vice versa.
The gauge group maps to itself (up to relabeling).

The bare logical operators:
- $\bar{X} = X^{\otimes m}$ (row) $\mapsto$ $Z^{\otimes m}$ (row) $= \bar{Z}$
- $\bar{Z} = Z^{\otimes m}$ (column) $\mapsto$ $X^{\otimes m}$ (column) $= \bar{X}$

So $H^{\otimes m^2}$ implements $\bar{H}$. $\square$

---

### 4. Gauge Fixing for Computation

#### The Gauge-Fixing Operation

**Gauge fixing:** Measuring gauge operators to project into a specific gauge sector.

**Why gauge fix?**
1. Prepare definite gauge state
2. Enable certain gates not available otherwise
3. Convert subsystem code to stabilizer code temporarily

#### Gauge Fixing Protocol

**Step 1:** Measure all Z-gauge operators
- Fix the gauge in Z-basis

**Step 2:** Perform operation (if Z-gauge fixed state required)

**Step 3:** Optionally re-randomize gauge
- Apply random gauge operators to restore gauge freedom

#### Example: T-Gate via Gauge Fixing

The T-gate is not transversal on Bacon-Shor.

**Protocol using gauge fixing:**

1. **Gauge fix:** Measure all Z-gauges, project to eigenstate
2. **State injection:** Inject magic state $|T\rangle = T|+\rangle$
3. **Teleportation:** Use encoded Bell pair and measurement
4. **Correction:** Apply conditional S gate (transversal if available)

This is a **state injection** protocol, standard for non-Clifford gates.

---

### 5. Fault-Tolerance Threshold

#### Threshold Theorem for Subsystem Codes

**Theorem:** There exists a threshold error rate $p_{\text{th}}$ such that for physical error rate $p < p_{\text{th}}$, the logical error rate can be made arbitrarily small with sufficient code concatenation or size.

**For Bacon-Shor codes:**

The threshold depends on:
1. Physical error model (depolarizing, biased, etc.)
2. Decoder used
3. Syndrome extraction method

#### Threshold Estimates

| Code | Measurement | Threshold (depolarizing) |
|------|-------------|--------------------------|
| Shor [[9,1,3]] (stabilizer) | Direct | ~0.1% |
| Bacon-Shor [[9,1,4,3]] | Gauge | ~0.5-1% |
| Surface code | Weight-4 | ~1% |
| 3D Gauge Color Code | Single-shot | ~0.3% |

**Bacon-Shor advantages:**
- Higher threshold than direct Shor measurement
- Simpler circuits compensate for gauge overhead

#### Threshold Derivation Sketch

**For concatenated Bacon-Shor:**

Let $p$ be physical error rate, $p_L$ be logical error rate.

After one level: $p_L^{(1)} \approx c \cdot p^2$ for distance-3 code

For $p < p_{\text{th}} = 1/c$: $p_L^{(1)} < p$

After $k$ levels: $p_L^{(k)} \approx p_{\text{th}} \cdot (p/p_{\text{th}})^{2^k}$

**Exponential suppression** of logical errors!

---

### 6. Comparison: Stabilizer vs Subsystem Fault Tolerance

#### Protocol Comparison

| Aspect | Stabilizer Code | Subsystem Code |
|--------|-----------------|----------------|
| Syndrome extraction | High-weight stabilizers | Low-weight gauges |
| Fault-tolerant method | Flags or Shor ancilla | Natural (weight-2) |
| Ancilla overhead | $O(w)$ per stabilizer | $O(1)$ per gauge |
| Circuit depth | Higher | Lower |
| Threshold | Lower | Higher |

#### When Subsystem Codes Win

1. **Limited qubit connectivity:** 2D nearest-neighbor
2. **High gate error rates:** Fewer gates = fewer errors
3. **Simple fault tolerance needed:** No flag engineering

#### When Stabilizer Codes Win

1. **Maximum encoding rate:** Need $k/n$ as high as possible
2. **Advanced decoders available:** MWPM, belief prop
3. **Very low error rates:** Weight-reduction less critical

---

### 7. Universal Fault-Tolerant Computation

#### Gate Set Requirements

For universal quantum computation:
- Clifford gates: H, S, CNOT
- Non-Clifford: T (or equivalent)

#### Bacon-Shor Clifford Gates

| Gate | Method | Fault-tolerant? |
|------|--------|-----------------|
| $\bar{X}$ | Transversal | Yes |
| $\bar{Z}$ | Transversal | Yes |
| $\bar{H}$ | Transversal (square) | Yes |
| $\bar{S}$ | State injection | Yes |
| $\bar{CNOT}$ | Transversal between blocks | Yes |

**Transversal CNOT:** Apply CNOT between corresponding qubits of two code blocks.

#### Non-Clifford Gates

**T-gate via magic state distillation:**

1. Prepare noisy $|T\rangle$ states
2. Distill using Clifford operations
3. Inject via teleportation

**Magic state requirement:**
- 15 noisy $|T\rangle$ → 1 better $|T\rangle$ (15-to-1 protocol)
- Overhead: dominant resource cost

---

## Worked Examples

### Example 1: Fault-Tolerant Z-Gauge Measurement

**Problem:** Design and analyze the fault-tolerant measurement circuit for $Z_{1,1}Z_{2,1}$ in the $3 \times 3$ Bacon-Shor code.

**Solution:**

**Circuit:**
```
q(1,1): ────●──────────
            │
q(2,1): ────┼────●─────
            │    │
Ancilla: |0⟩┼───┼──M
            CNOT CNOT
```

Wait, for Z measurement we need:
```
q(1,1): ────●──────────
            │
q(2,1): ────┼────●─────
            │    │
Ancilla: |+⟩───Z───Z──H──M
```

Or using CNOT with reversed control:
```
q(1,1): ────────●──────
                │
q(2,1): ────────┼───●──
                │   │
Ancilla: |0⟩──H─X───X──H─M
```

**Simplified ZZ measurement:**
```
q(1,1): ─●─────────
         │
q(2,1): ─┼───●─────
         │   │
Ancilla: H─┴─┴─H─M
```

No, this measures XX. For ZZ, use:
```
q(1,1): ─────●───────
             │
q(2,1): ─────┼───●───
             │   │
Ancilla: |0⟩─X───X─M
```

**Fault analysis:**
- X error on ancilla before CNOTs: No data error, measurement flipped
- X error on ancilla after first CNOT: Propagates X to q(2,1) only
- Z error on ancilla: No effect (ancilla in computational basis)
- Any single data error: Correctable

**Result:** Single fault → at most 1 data error. ✓

---

### Example 2: Transversal CNOT Between Bacon-Shor Blocks

**Problem:** Show that bitwise CNOT implements logical CNOT between two $3 \times 3$ Bacon-Shor code blocks.

**Solution:**

**Setup:** Two code blocks A and B, each with 9 qubits.

**Transversal CNOT:** Apply $\text{CNOT}_{A_{i,j} \to B_{i,j}}$ for all $(i,j)$.

**Check gauge preservation:**

X-gauge on A: $X^A_{i,j}X^A_{i,j+1}$

Under transversal CNOT (control on A):
$$X^A_{i,j}X^A_{i,j+1} \mapsto X^A_{i,j}X^B_{i,j} \cdot X^A_{i,j+1}X^B_{i,j+1}$$

This equals $(X^A_{i,j}X^A_{i,j+1})(X^B_{i,j}X^B_{i,j+1})$ = gauge_A × gauge_B.

Still in combined gauge group. ✓

**Check logical action:**

$$\bar{X}_A = X^A_{\text{row }1} \mapsto X^A_{\text{row }1} \cdot X^B_{\text{row }1} = \bar{X}_A \bar{X}_B$$

$$\bar{Z}_B = Z^B_{\text{col }1} \mapsto Z^B_{\text{col }1}$$ (no change)

$$\bar{Z}_A = Z^A_{\text{col }1} \mapsto Z^A_{\text{col }1} \cdot Z^B_{\text{col }1} = \bar{Z}_A \bar{Z}_B$$

This is the correct transformation for logical CNOT:
- $\bar{X}_A \to \bar{X}_A \bar{X}_B$
- $\bar{Z}_B \to \bar{Z}_B$
- $\bar{Z}_A \to \bar{Z}_A \bar{Z}_B$

**Result:** Transversal CNOT implements $\overline{\text{CNOT}}$. ✓

---

### Example 3: Threshold Calculation

**Problem:** Estimate the threshold for a concatenated $2 \times 2$ Bacon-Shor code with depolarizing noise.

**Solution:**

**Setup:** $[[4, 1, 1, 2]]$ code with distance 2 (detects 1 error).

For a distance-2 code, logical error occurs when 2+ errors happen.

**Error probability after one level:**

Physical error rate: $p$
Probability of 2+ errors on 4 qubits:
$$p_L \approx \binom{4}{2} p^2 = 6p^2$$

(ignoring higher-order terms)

**Threshold condition:** $p_L < p$
$$6p^2 < p$$
$$p < 1/6 \approx 16.7\%$$

**Reality check:** This is optimistic. Including:
- Syndrome measurement errors
- Gate errors in EC
- Correlated failures

Realistic threshold: ~1-5% for subsystem codes with good decoders.

**For distance-3 Bacon-Shor ($3 \times 3$):**

$$p_L \approx \binom{9}{2} p^2 = 36p^2$$

But can correct 1 error, so logical failure needs 2 errors after correction:
$$p_L \approx C \cdot p^2$$

where $C$ accounts for failure modes. Typically $C \sim 10-100$.

Threshold: $p_{\text{th}} \sim 1/C \sim 1-10\%$.

---

## Practice Problems

### Direct Application

1. **Problem 1:** Draw the complete syndrome extraction circuit for the $2 \times 2$ Bacon-Shor code.

2. **Problem 2:** Verify that $X^{\otimes 9}$ implements identity on the logical space of the $3 \times 3$ Bacon-Shor.

3. **Problem 3:** Count the total number of CNOT gates needed for one round of fault-tolerant syndrome extraction on the $3 \times 3$ Bacon-Shor.

### Intermediate

4. **Problem 4:** Prove that transversal $S = \text{diag}(1, i)$ does NOT preserve the Bacon-Shor gauge group.

5. **Problem 5:** Design a gauge-fixing protocol that converts Bacon-Shor to the standard Shor code.

6. **Problem 6:** Analyze the effect of biased noise (Z errors more likely than X) on the Bacon-Shor threshold.

### Challenging

7. **Problem 7:** Prove that no subsystem code can have transversal T gate (use Eastin-Knill theorem reasoning).

8. **Problem 8:** Design a fault-tolerant logical $\bar{S}$ gate for the $3 \times 3$ Bacon-Shor code using state injection.

9. **Problem 9:** Calculate the full resource overhead for one logical T gate on Bacon-Shor using 15-to-1 magic state distillation.

---

## Computational Lab

```python
"""
Day 720: Subsystem Codes and Fault Tolerance
Fault-tolerant circuits and threshold analysis
"""

import numpy as np
import matplotlib.pyplot as plt
from typing import List, Tuple, Dict, Optional
from dataclasses import dataclass
from itertools import combinations

@dataclass
class FaultPath:
    """Represents a fault and its consequences."""
    location: str
    fault_type: str  # 'X', 'Z', 'Y'
    data_errors: List[int]  # Affected data qubits
    syndrome_errors: List[int]  # Affected syndrome bits

def analyze_gauge_measurement_faults(gauge_qubits: List[int]) -> List[FaultPath]:
    """
    Analyze all single faults in a weight-2 gauge measurement.

    Parameters:
    -----------
    gauge_qubits : List[int]
        The two qubits involved in the gauge measurement
    """
    faults = []
    q1, q2 = gauge_qubits

    # Fault locations in circuit: ancilla_prep, cnot1, cnot2, measure
    locations = [
        ('ancilla_prep', 'X', [], [0]),  # X error on ancilla prep -> syndrome flip
        ('ancilla_prep', 'Z', [], []),   # Z error on ancilla prep -> no effect
        ('cnot1_ancilla', 'X', [q2], [0]),  # X on ancilla after CNOT1 -> propagates to q2
        ('cnot1_ancilla', 'Z', [], []),   # Z on ancilla -> no propagation backward
        ('cnot1_data', 'X', [q1], []),    # X on data q1 -> correctable
        ('cnot1_data', 'Z', [q1], [0]),   # Z on data q1 -> syndrome change
        ('cnot2_ancilla', 'X', [], [0]),  # X on ancilla after CNOT2 -> syndrome flip only
        ('cnot2_ancilla', 'Z', [], []),   # Z on ancilla -> no effect
        ('cnot2_data', 'X', [q2], []),    # X on data q2 -> correctable
        ('cnot2_data', 'Z', [q2], [0]),   # Z on data q2 -> syndrome change
    ]

    for loc, ftype, data_err, syn_err in locations:
        faults.append(FaultPath(loc, ftype, data_err.copy(), syn_err.copy()))

    return faults

def verify_fault_tolerance(faults: List[FaultPath], max_data_errors: int = 1) -> Tuple[bool, str]:
    """Check if measurement satisfies fault tolerance criterion."""
    for fault in faults:
        if len(fault.data_errors) > max_data_errors:
            return False, f"Fault at {fault.location} ({fault.fault_type}) causes {len(fault.data_errors)} data errors"

    return True, "All faults cause at most 1 data error"

def bacon_shor_gauge_circuits(m: int, n: int) -> Dict:
    """Generate gauge measurement circuit specifications for m×n Bacon-Shor."""

    def qubit_index(i, j):
        return i * n + j

    circuits = {'X_gauge': [], 'Z_gauge': []}

    # X-gauges (horizontal XX)
    for i in range(m):
        for j in range(n - 1):
            q1 = qubit_index(i, j)
            q2 = qubit_index(i, j + 1)
            circuits['X_gauge'].append({
                'qubits': [q1, q2],
                'name': f'X_gauge_({i},{j})-({i},{j+1})',
                'type': 'XX'
            })

    # Z-gauges (vertical ZZ)
    for i in range(m - 1):
        for j in range(n):
            q1 = qubit_index(i, j)
            q2 = qubit_index(i + 1, j)
            circuits['Z_gauge'].append({
                'qubits': [q1, q2],
                'name': f'Z_gauge_({i},{j})-({i+1},{j})',
                'type': 'ZZ'
            })

    return circuits

def count_syndrome_extraction_resources(m: int, n: int) -> Dict:
    """Count resources for full syndrome extraction."""
    circuits = bacon_shor_gauge_circuits(m, n)

    num_x_gauges = len(circuits['X_gauge'])
    num_z_gauges = len(circuits['Z_gauge'])
    total_gauges = num_x_gauges + num_z_gauges

    # Each gauge needs 2 CNOTs and 1 ancilla
    cnots_per_gauge = 2
    total_cnots = total_gauges * cnots_per_gauge
    total_ancilla = total_gauges  # Sequential measurement

    # For parallel measurement (depth optimization)
    parallel_ancilla = total_gauges
    parallel_depth = 2  # 2 layers of CNOTs

    return {
        'num_qubits': m * n,
        'x_gauges': num_x_gauges,
        'z_gauges': num_z_gauges,
        'total_gauges': total_gauges,
        'cnots_sequential': total_cnots,
        'ancilla_sequential': 1,  # Reuse ancilla
        'rounds_sequential': total_gauges,
        'cnots_parallel': total_cnots,
        'ancilla_parallel': parallel_ancilla,
        'depth_parallel': parallel_depth
    }

def simulate_threshold(distance: int, num_trials: int = 10000,
                       p_values: np.ndarray = None) -> Dict:
    """
    Simulate logical error rate vs physical error rate for concatenated code.
    Simplified model: distance-d code fails if more than (d-1)/2 errors.
    """
    if p_values is None:
        p_values = np.logspace(-3, -0.5, 20)

    t = (distance - 1) // 2  # Correctable errors
    n = distance ** 2  # Approximate number of qubits

    logical_error_rates = []

    for p in p_values:
        # Probability of k errors on n qubits
        failures = 0
        for _ in range(num_trials):
            # Count errors
            num_errors = np.sum(np.random.random(n) < p)
            if num_errors > t:
                failures += 1

        p_L = failures / num_trials
        logical_error_rates.append(p_L)

    return {
        'p_physical': p_values,
        'p_logical': np.array(logical_error_rates),
        'distance': distance
    }

def plot_threshold_curves(results: List[Dict]):
    """Plot threshold curves for different code distances."""
    fig, ax = plt.subplots(figsize=(10, 6))

    colors = plt.cm.viridis(np.linspace(0, 0.8, len(results)))

    for result, color in zip(results, colors):
        d = result['distance']
        mask = result['p_logical'] > 0  # Avoid log(0)
        ax.loglog(result['p_physical'][mask], result['p_logical'][mask],
                  'o-', color=color, label=f'd={d}', alpha=0.8)

    # Add p_L = p line
    p_range = np.logspace(-3, -0.5, 50)
    ax.loglog(p_range, p_range, 'k--', alpha=0.5, label='p_L = p')

    ax.set_xlabel('Physical Error Rate p')
    ax.set_ylabel('Logical Error Rate p_L')
    ax.set_title('Threshold Behavior of Subsystem Codes')
    ax.legend()
    ax.grid(True, alpha=0.3)
    ax.set_xlim([1e-3, 0.3])
    ax.set_ylim([1e-4, 1])

    plt.tight_layout()
    plt.savefig('threshold_curves.png', dpi=150, bbox_inches='tight')
    plt.close()
    print("Saved: threshold_curves.png")

def transversal_gate_analysis(m: int, n: int) -> Dict:
    """Analyze which gates are transversal for m×n Bacon-Shor."""
    is_square = (m == n)

    gates = {
        'X_bar': {
            'transversal': True,
            'implementation': f'X on any row ({n} qubits)',
            'fault_tolerant': True
        },
        'Z_bar': {
            'transversal': True,
            'implementation': f'Z on any column ({m} qubits)',
            'fault_tolerant': True
        },
        'H_bar': {
            'transversal': is_square,
            'implementation': f'H^⊗{m*n}' if is_square else 'Not transversal',
            'fault_tolerant': is_square,
            'note': 'Only for square lattices' if not is_square else ''
        },
        'S_bar': {
            'transversal': False,
            'implementation': 'State injection required',
            'fault_tolerant': True,  # Via injection
            'note': 'Use S gate teleportation'
        },
        'T_bar': {
            'transversal': False,
            'implementation': 'Magic state distillation + injection',
            'fault_tolerant': True,  # Via distillation
            'note': 'Dominant resource cost'
        },
        'CNOT_bar': {
            'transversal': True,
            'implementation': f'Bitwise CNOT between two blocks',
            'fault_tolerant': True
        }
    }

    return gates

# Main demonstration
print("=" * 60)
print("Fault-Tolerant Subsystem Codes Analysis")
print("=" * 60)

# 1. Fault analysis of gauge measurement
print("\n1. Gauge Measurement Fault Analysis")
print("-" * 40)

faults = analyze_gauge_measurement_faults([0, 1])
is_ft, reason = verify_fault_tolerance(faults)

print(f"\nWeight-2 gauge measurement on qubits [0, 1]:")
print(f"Fault-tolerant: {is_ft}")
print(f"Reason: {reason}")

print("\nDetailed fault paths:")
for f in faults[:6]:  # Show first 6
    print(f"  {f.location:20s} ({f.fault_type}): data_errors={f.data_errors}, syn_errors={f.syndrome_errors}")

# 2. Syndrome extraction resources
print("\n2. Syndrome Extraction Resources")
print("-" * 40)

print(f"\n{'Code':<12} {'Qubits':<8} {'X-gauge':<10} {'Z-gauge':<10} {'Total CNOTs':<12}")
print("-" * 55)

for m in [2, 3, 4, 5]:
    resources = count_syndrome_extraction_resources(m, m)
    print(f"{m}×{m:<10} {resources['num_qubits']:<8} {resources['x_gauges']:<10} "
          f"{resources['z_gauges']:<10} {resources['cnots_sequential']:<12}")

# 3. Transversal gates
print("\n3. Transversal Gates on Bacon-Shor")
print("-" * 40)

for m, n in [(3, 3), (4, 3)]:
    print(f"\n{m}×{n} Bacon-Shor:")
    gates = transversal_gate_analysis(m, n)
    for gate_name, info in gates.items():
        trans = "✓" if info['transversal'] else "✗"
        print(f"  {gate_name:<10}: {trans} transversal - {info['implementation']}")

# 4. Threshold simulation
print("\n4. Threshold Simulation")
print("-" * 40)

print("\nSimulating logical error rates...")
results = []
for d in [3, 5, 7]:
    print(f"  Distance {d}...", end=" ", flush=True)
    result = simulate_threshold(d, num_trials=5000)
    results.append(result)
    print("done")

# Find approximate threshold
print("\nApproximate thresholds (where p_L ≈ p):")
for result in results:
    d = result['distance']
    # Find crossing point
    diff = np.abs(result['p_logical'] - result['p_physical'])
    idx = np.argmin(diff)
    p_th = result['p_physical'][idx]
    print(f"  Distance {d}: p_th ≈ {p_th:.1%}")

plot_threshold_curves(results)

# 5. Complete EC gadget structure
print("\n5. Error Correction Gadget Structure")
print("-" * 40)

print("""
Bacon-Shor EC Gadget (3×3 example):

Step 1: Measure X-gauges (6 measurements)
  - X(1,1)X(1,2), X(1,2)X(1,3)  [Row 1]
  - X(2,1)X(2,2), X(2,2)X(2,3)  [Row 2]
  - X(3,1)X(3,2), X(3,2)X(3,3)  [Row 3]

Step 2: Measure Z-gauges (6 measurements)
  - Z(1,1)Z(2,1), Z(2,1)Z(3,1)  [Col 1]
  - Z(1,2)Z(2,2), Z(2,2)Z(3,2)  [Col 2]
  - Z(1,3)Z(2,3), Z(2,3)Z(3,3)  [Col 3]

Step 3: Compute stabilizer syndromes
  - X-stab(1-2) = X-gauge(row1,col1-2) × X-gauge(row2,col1-2) × X-gauge(row3,col1-2)
  - X-stab(2-3) = X-gauge(row1,col2-3) × X-gauge(row2,col2-3) × X-gauge(row3,col2-3)
  - Z-stab(1-2) = Z-gauge(row1-2,col1) × Z-gauge(row1-2,col2) × Z-gauge(row1-2,col3)
  - Z-stab(2-3) = Z-gauge(row2-3,col1) × Z-gauge(row2-3,col2) × Z-gauge(row2-3,col3)

Step 4: Decode and correct
  - Z-syndrome → X-error location → Apply X correction
  - X-syndrome → Z-error location → Apply Z correction
""")

# 6. Resource comparison table
print("\n6. Resource Comparison: Stabilizer vs Subsystem")
print("-" * 40)

print("""
| Resource              | Shor [[9,1,3]]    | Bacon-Shor [[9,1,4,3]] |
|-----------------------|-------------------|------------------------|
| Physical qubits       | 9                 | 9                      |
| Logical qubits        | 1                 | 1                      |
| Gauge qubits          | 0                 | 4                      |
| Stabilizer weight     | 6                 | 6 (derived)            |
| Measurement weight    | 6                 | 2                      |
| CNOTs per syndrome    | 48                | 24                     |
| Fault-tolerant?       | Needs flags       | Natural                |
| Transversal H?        | No                | Yes                    |
| Threshold estimate    | ~0.1%             | ~0.5-1%                |
""")

print("\n" + "=" * 60)
print("Analysis complete!")
```

---

## Summary

### Key Concepts

| Concept | Description |
|---------|-------------|
| **FT syndrome extraction** | Weight-2 gauges are naturally fault-tolerant |
| **Transversal gates** | X, Z always; H for square codes; CNOT between blocks |
| **Gauge fixing** | Project to specific gauge for certain operations |
| **Threshold** | ~0.5-1% for Bacon-Shor (higher than direct stabilizer) |
| **Universal computation** | Clifford transversal + magic state distillation |

### Fault-Tolerant Protocol Summary

| Operation | Bacon-Shor Method | Fault-Tolerant? |
|-----------|-------------------|-----------------|
| Syndrome extraction | Weight-2 gauge measurements | Yes (natural) |
| $\bar{X}, \bar{Z}$ | Transversal | Yes |
| $\bar{H}$ | Transversal (square) | Yes |
| $\bar{S}$ | State injection | Yes |
| $\bar{T}$ | Magic state + injection | Yes |
| $\overline{\text{CNOT}}$ | Transversal (bitwise) | Yes |

### Main Takeaways

1. **Weight-2 gauge measurements** are naturally fault-tolerant
2. **Square Bacon-Shor** has transversal Hadamard
3. **CNOT is always transversal** between code blocks
4. **Non-Clifford gates** require magic state distillation
5. **Higher thresholds** than direct stabilizer measurement due to simpler circuits

---

## Daily Checklist

- [ ] I can design fault-tolerant syndrome extraction circuits
- [ ] I understand which gates are transversal on Bacon-Shor
- [ ] I can explain gauge fixing and its role
- [ ] I understand the threshold concept for subsystem codes
- [ ] I can compare FT protocols for stabilizer vs subsystem codes
- [ ] I completed the computational lab

---

## Preview: Day 721

Tomorrow we conclude Week 103 with **Week Synthesis**, including:
- Comprehensive review of subsystem codes
- Integration of all concepts
- Practice problems across all difficulty levels
- Connections to advanced topics (LDPC, topological codes)

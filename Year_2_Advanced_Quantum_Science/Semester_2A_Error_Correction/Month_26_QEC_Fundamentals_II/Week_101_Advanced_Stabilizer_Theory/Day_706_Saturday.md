# Day 706: Normalizer Structure and Clifford Circuit Synthesis

## Overview

**Date:** Day 706 of 1008
**Week:** 101 (Advanced Stabilizer Theory)
**Month:** 26 (QEC Fundamentals II)
**Topic:** Group Structure and Circuit Compilation for Clifford Operations

---

## Schedule

| Block | Time | Duration | Focus |
|-------|------|----------|-------|
| Morning | 9:00 AM - 12:30 PM | 3.5 hrs | Clifford group structure and generators |
| Afternoon | 2:00 PM - 4:30 PM | 2.5 hrs | Circuit synthesis and optimization |
| Evening | 7:00 PM - 8:00 PM | 1 hr | Computational implementation |

---

## Learning Objectives

By the end of this day, you should be able to:

1. **Characterize the Clifford group** as the normalizer of the Pauli group
2. **Decompose Cliffords** as a semidirect product $\mathcal{C}_n = \mathcal{P}_n \rtimes Sp(2n, \mathbb{F}_2)$
3. **Compute minimal generating sets** for the Clifford group
4. **Apply the Bruhat decomposition** to Clifford unitaries
5. **Synthesize efficient Clifford circuits** from tableaux
6. **Optimize Clifford circuits** via gate cancellation and reordering

---

## Core Content

### 1. The Clifford Group as a Normalizer

#### Definition Revisited

The Clifford group is the **normalizer** of the Pauli group in $U(2^n)$:

$$\boxed{\mathcal{C}_n = \{U \in U(2^n) : U \mathcal{P}_n U^\dagger = \mathcal{P}_n\}}$$

This means: $C \in \mathcal{C}_n$ iff for every Pauli $P$, $CPC^\dagger$ is also a Pauli.

#### Automorphisms of the Pauli Group

Each Clifford $C$ induces an **automorphism** $\phi_C$ on $\mathcal{P}_n$:

$$\phi_C(P) = CPC^\dagger$$

**Properties of $\phi_C$:**
1. **Bijective:** Each Pauli maps to unique Pauli
2. **Preserves multiplication:** $\phi_C(PQ) = \phi_C(P)\phi_C(Q)$
3. **Preserves commutation:** $[P, Q] = 0 \Leftrightarrow [\phi_C(P), \phi_C(Q)] = 0$

---

### 2. Semidirect Product Structure

#### The Decomposition

The Clifford group decomposes as:

$$\boxed{\mathcal{C}_n \cong \mathcal{P}_n \rtimes Sp(2n, \mathbb{F}_2)}$$

**Components:**
- **$\mathcal{P}_n$:** Normal subgroup (Pauli operators)
- **$Sp(2n, \mathbb{F}_2)$:** Symplectic group (action on Paulis)
- **$\rtimes$:** Semidirect product (twisted multiplication)

#### What This Means

Any Clifford $C$ can be written as:

$$C = P \cdot U_M$$

where:
- $P \in \mathcal{P}_n$ is a Pauli
- $U_M$ is a Clifford implementing symplectic transformation $M$

**Multiplication rule:**

$$(P_1 U_{M_1})(P_2 U_{M_2}) = P_1 (U_{M_1} P_2 U_{M_1}^\dagger) U_{M_1} U_{M_2} = P_1 M_1(P_2) U_{M_1 M_2}$$

---

### 3. Size of the Clifford Group

#### Counting Formula

$$\boxed{|\mathcal{C}_n| = 2^{n^2 + 2n + 1} \cdot \prod_{j=1}^{n}(4^j - 1)}$$

**Derivation:**
- $|\mathcal{P}_n| = 4^n \cdot 2 = 2^{2n+1}$ (including phases)
- $|Sp(2n, \mathbb{F}_2)| = 2^{n^2} \prod_{j=1}^{n}(4^j - 1)$
- $|\mathcal{C}_n| = |\mathcal{P}_n| \cdot |Sp(2n, \mathbb{F}_2)|$

**Values:**

| $n$ | $\|\mathcal{C}_n\|$ |
|-----|---------------------|
| 1 | 192 |
| 2 | 92,160 |
| 3 | 743,178,240 |

#### Projective Clifford Group

Modding out global phases:

$$|\mathcal{C}_n / U(1)| = 2^{n^2 + 2n} \cdot \prod_{j=1}^{n}(4^j - 1)$$

---

### 4. Generating Sets

#### Minimal Generators

**Theorem:** The $n$-qubit Clifford group is generated by:
1. **Hadamard gate** $H$ on any qubit
2. **Phase gate** $S$ on any qubit
3. **CNOT** between any pair of qubits

**Alternative generating set:**
- $H, S, CZ$ (controlled-Z instead of CNOT)

#### Single-Qubit Cliffords

The 24 single-qubit Cliffords form the **octahedral group** (symmetries of the octahedron):

$$|\mathcal{C}_1 / \mathcal{P}_1| = |Sp(2, \mathbb{F}_2)| = 6$$
$$|\mathcal{C}_1| = 4 \cdot 2 \cdot 6 = 48 \quad \text{(including global phase)}$$
$$|\mathcal{C}_1 / U(1)| = 24$$

**Correspondence:**
- 6 faces of octahedron ↔ 6 eigenstates of $X, Y, Z$
- 24 rotations ↔ 24 single-qubit Cliffords

#### Canonical Single-Qubit Decomposition

Any single-qubit Clifford can be written as:

$$C = \omega \cdot H^a S^b H^c S^d H^e$$

where $a, c, e \in \{0, 1\}$, $b, d \in \{0, 1, 2, 3\}$, $\omega$ is a phase.

---

### 5. Bruhat Decomposition

#### For Symplectic Matrices

The symplectic group has a **Bruhat decomposition**:

$$Sp(2n, \mathbb{F}_2) = BWB$$

where:
- $B$ = upper triangular symplectic matrices
- $W$ = Weyl group (permutations + sign changes)

#### Application to Clifford Synthesis

Any Clifford can be decomposed into "layers":

$$C = C_{\text{diag}} \cdot C_{\text{CNOT}} \cdot C_{\text{local}}$$

where:
- $C_{\text{local}}$: single-qubit Cliffords only
- $C_{\text{CNOT}}$: CNOT gates only
- $C_{\text{diag}}$: Diagonal Cliffords (products of $S, CZ$)

---

### 6. Clifford Circuit Synthesis Algorithms

#### From Tableau to Circuit

**Input:** Stabilizer tableau $T$ (target state or gate)
**Output:** Circuit of $\{H, S, \text{CNOT}\}$ implementing $T$

**Algorithm (Aaronson-Gottesman):**

```
1. Initialize: T = target tableau, circuit = []

2. While T ≠ identity:
   a. Find pivot in X or Z part
   b. Use CNOT row operations to isolate pivot
   c. Use H to swap X↔Z if needed
   d. Use S to clear unwanted Z entries
   e. Record inverse gates to circuit

3. Reverse circuit for forward implementation
```

**Complexity:** $O(n^2 / \log n)$ gates (optimal for generic Cliffords)

#### Optimized Synthesis

**Koenig-Smolin Algorithm:**
- Optimal CNOT count for 2-qubit Cliffords
- At most 3 CNOTs for any 2-qubit Clifford

**Maslov et al.:**
- Linear reversible circuits (CNOT only): $O(n^2 / \log n)$ optimal
- Full Clifford: currently best known is $O(n^2)$

---

### 7. Circuit Optimization

#### Gate Cancellation Rules

Adjacent gates that cancel:

| Pattern | Simplification |
|---------|----------------|
| $H \cdot H$ | $I$ |
| $S \cdot S \cdot S \cdot S$ | $I$ |
| $\text{CNOT}_{ab} \cdot \text{CNOT}_{ab}$ | $I$ |
| $S^\dagger \cdot S$ | $I$ |

#### Commutation Rules

Gates that commute (can be reordered):

| Gate 1 | Gate 2 | Commute? |
|--------|--------|----------|
| $H_a$ | $H_b$ ($a \neq b$) | ✓ |
| $S_a$ | $S_b$ ($a \neq b$) | ✓ |
| $\text{CNOT}_{ab}$ | $H_c$ ($c \neq a, b$) | ✓ |
| $\text{CNOT}_{ab}$ | $\text{CNOT}_{cd}$ (disjoint) | ✓ |
| $S_a$ | $\text{CNOT}_{ab}$ | ✗ (target) |
| $S_a$ | $\text{CNOT}_{ba}$ | ✓ (control) |

#### Conjugation Identities

Useful for moving gates:

$$\text{CNOT}_{12} \cdot (H_1 \otimes I) = (H_1 \otimes H_2) \cdot CZ_{12} \cdot (I \otimes H_2)$$

$$\text{CNOT}_{12} \cdot (S_1 \otimes I) \cdot \text{CNOT}_{12} = CZ_{12} \cdot (S_1 \otimes S_2^\dagger)$$

---

### 8. Applications

#### State Preparation

To prepare stabilizer state $|\psi\rangle$ from $|0\rangle^{\otimes n}$:

1. Compute tableau for $|\psi\rangle$
2. Synthesize circuit $C$ such that $C|0\rangle^{\otimes n} = |\psi\rangle$

#### Encoding Circuits

For stabilizer code $[[n, k, d]]$:
- Input: $k$ logical qubits + $n-k$ ancillas
- Output: $n$ physical qubits in code space
- Encoding circuit is Clifford!

#### Basis Changes

To transform between stabilizer bases:
- $|0_L\rangle \to |+_L\rangle$: Find Clifford that maps stabilizers appropriately

---

## Worked Examples

### Example 1: Decompose a 2-Qubit Clifford

**Problem:** Find a circuit for the Clifford $C$ with tableau:

| | $x_1$ | $x_2$ | $z_1$ | $z_2$ |
|---|---|---|---|---|
| Stab 1 | 1 | 1 | 0 | 1 |
| Stab 2 | 0 | 1 | 1 | 0 |

**Solution:**

Target stabilizers: $X_1 X_2 Z_2$ and $X_2 Z_1$

**Work backwards from $|00\rangle$ (stabilizers $Z_1, Z_2$):**

We need:
- $Z_1 \to X_1 X_2 Z_2$
- $Z_2 \to X_2 Z_1$

**Step 1:** $H_1$: $Z_1 \to X_1$

Now: $X_1, Z_2$

**Step 2:** $\text{CNOT}_{12}$: $X_1 \to X_1 X_2$

Now: $X_1 X_2, Z_1 Z_2$ (CNOT also transforms $Z_2 \to Z_1 Z_2$)

**Step 3:** $H_2$: $Z_1 Z_2 \to Z_1 X_2$

Now: $X_1 X_2, Z_1 X_2$

**Step 4:** $S_2$: $X_2 \to Y_2 = X_2 Z_2$

$X_1 X_2 \to X_1 Y_2 = X_1 X_2 Z_2$ ✓
$Z_1 X_2 \to Z_1 Y_2 = Z_1 X_2 Z_2$ (not quite right...)

Let me reconsider...

**Better approach:** Use tableau row operations.

Final circuit: $S_2 \cdot \text{CNOT}_{21} \cdot H_1 \cdot H_2$

Verify by checking transformation of $Z_1, Z_2$.

---

### Example 2: Count Single-Qubit Cliffords

**Problem:** Enumerate all 24 single-qubit Cliffords.

**Solution:**

**Method 1: Orbit of $|0\rangle$**

24 Cliffords map $|0\rangle$ to 6 states (eigenstates of $X, Y, Z$) with 4 phases each... but phases don't change the state.

Actually, 24 Cliffords correspond to:
- 6 choices for where $|0\rangle$ goes
- 4 choices for the phase relationship

**Method 2: Explicit enumeration**

Using $\{H, S\}$:

| Clifford | Circuit | Maps $Z$ to |
|----------|---------|-------------|
| $I$ | $I$ | $Z$ |
| $S$ | $S$ | $Z$ |
| $S^2$ | $SS$ | $Z$ |
| $S^3$ | $SSS$ | $Z$ |
| $H$ | $H$ | $X$ |
| $HS$ | $HS$ | $Y$ |
| ... | ... | ... |

All 24 can be written as products of at most 3 generators from $\{H, S\}$.

---

### Example 3: CNOT Circuit Optimization

**Problem:** Simplify the circuit $\text{CNOT}_{12} \cdot \text{CNOT}_{21} \cdot \text{CNOT}_{12}$.

**Solution:**

This is actually a **SWAP** gate!

$$\text{SWAP} = \text{CNOT}_{12} \cdot \text{CNOT}_{21} \cdot \text{CNOT}_{12}$$

**Verify by tracking basis states:**
- $|00\rangle \to |00\rangle \to |00\rangle \to |00\rangle$
- $|01\rangle \to |01\rangle \to |11\rangle \to |10\rangle$ ✓
- $|10\rangle \to |11\rangle \to |01\rangle \to |01\rangle$ ✓
- $|11\rangle \to |10\rangle \to |10\rangle \to |11\rangle$

SWAP achieved with 3 CNOTs (optimal for this decomposition).

---

## Practice Problems

### Direct Application

1. **Problem 1:** Compute $|\mathcal{C}_2|$ using the formula.

2. **Problem 2:** Express the CZ gate as a product of H and CNOT gates.

3. **Problem 3:** Find a minimal circuit (H, S, CNOT) implementing the SWAP gate (aside from 3 CNOTs).

### Intermediate

4. **Problem 4:** Prove that $\{H, S, \text{CNOT}\}$ generates the Clifford group by showing any symplectic matrix can be realized.

5. **Problem 5:** Derive the gate count formula $O(n^2 / \log n)$ for generic $n$-qubit Cliffords.

6. **Problem 6:** Show that single-qubit Cliffords form the symmetric group $S_4$ (octahedral symmetry).

### Challenging

7. **Problem 7:** Implement an optimal 2-qubit Clifford synthesizer using at most 3 CNOTs.

8. **Problem 8:** Prove the semidirect product structure $\mathcal{C}_n = \mathcal{P}_n \rtimes Sp(2n, \mathbb{F}_2)$.

9. **Problem 9:** Design an algorithm to decompose an $n$-qubit Clifford into layers: local → CNOT → local → CNOT → local.

---

## Computational Lab

```python
"""
Day 706: Normalizer Structure and Clifford Circuit Synthesis
Week 101: Advanced Stabilizer Theory

Implements Clifford group analysis and circuit synthesis.
"""

import numpy as np
from typing import List, Tuple, Optional
from itertools import product
from collections import defaultdict

class CliffordGroupAnalysis:
    """Analysis of Clifford group structure."""

    @staticmethod
    def clifford_group_size(n: int) -> int:
        """Compute |C_n| for n qubits."""
        # |C_n| = 2^(n^2 + 2n + 1) * prod_{j=1}^n (4^j - 1)
        power_of_2 = 2 ** (n*n + 2*n + 1)

        product_term = 1
        for j in range(1, n + 1):
            product_term *= (4**j - 1)

        return power_of_2 * product_term

    @staticmethod
    def symplectic_group_size(n: int) -> int:
        """Compute |Sp(2n, F_2)|."""
        # |Sp(2n, F_2)| = 2^(n^2) * prod_{j=1}^n (4^j - 1)
        power_of_2 = 2 ** (n*n)

        product_term = 1
        for j in range(1, n + 1):
            product_term *= (4**j - 1)

        return power_of_2 * product_term


class SingleQubitCliffords:
    """Enumerate and analyze single-qubit Cliffords."""

    # Pauli matrices
    I = np.array([[1, 0], [0, 1]], dtype=complex)
    X = np.array([[0, 1], [1, 0]], dtype=complex)
    Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
    Z = np.array([[1, 0], [0, -1]], dtype=complex)

    # Clifford generators
    H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
    S = np.array([[1, 0], [0, 1j]], dtype=complex)

    def __init__(self):
        """Generate all 24 single-qubit Cliffords."""
        self.cliffords = []
        self.labels = []
        self._generate_cliffords()

    def _generate_cliffords(self):
        """Generate by composing H and S."""
        # Maximum depth needed is 5 (HSHSH pattern)
        generated = {}

        def add_clifford(U, label):
            """Add if not equivalent to existing (up to global phase)."""
            for existing_U, existing_label in generated.items():
                if self._equivalent(U, existing_U):
                    return
            generated[tuple(U.flatten())] = label

        # Start with identity
        add_clifford(self.I, "I")

        # Generate by applying H and S
        queue = [(self.I, "I")]
        visited = {tuple(self.I.flatten())}

        while queue and len(generated) < 24:
            U, label = queue.pop(0)

            for gate, gate_name in [(self.H, "H"), (self.S, "S")]:
                new_U = gate @ U
                new_label = gate_name + label if label != "I" else gate_name

                key = tuple(new_U.flatten())
                if key not in visited:
                    visited.add(key)
                    add_clifford(new_U, new_label)
                    queue.append((new_U, new_label))

        self.cliffords = list(generated.keys())
        self.labels = list(generated.values())

    def _equivalent(self, U1, U2):
        """Check if U1 = e^(i*theta) * U2."""
        # Find ratio of first nonzero elements
        for i in range(4):
            if abs(U1.flatten()[i]) > 1e-10:
                ratio = U2.flatten()[i] / U1.flatten()[i]
                break
        else:
            return False

        # Check if all ratios are the same
        U2_normalized = U2 / ratio
        return np.allclose(U1, U2_normalized)

    def get_clifford_table(self) -> List[Tuple[str, str]]:
        """Return table of Cliffords with their action on Z."""
        table = []
        for i, label in enumerate(self.labels):
            U = np.array(self.cliffords[i]).reshape(2, 2)
            # Compute U Z U†
            UZUd = U @ self.Z @ U.conj().T

            # Identify result
            for name, P in [("X", self.X), ("Y", self.Y), ("Z", self.Z),
                            ("-X", -self.X), ("-Y", -self.Y), ("-Z", -self.Z)]:
                if np.allclose(UZUd, P):
                    table.append((label, name))
                    break

        return table


class CliffordSynthesis:
    """Synthesize Clifford circuits from tableaux."""

    def __init__(self, n_qubits: int):
        self.n = n_qubits

    def tableau_to_circuit(self, x_part: np.ndarray, z_part: np.ndarray) -> List[str]:
        """
        Convert tableau to circuit.

        Uses Gaussian elimination on the symplectic matrix.
        Returns list of gate strings.
        """
        n = self.n
        circuit = []

        # Work on copies
        x = x_part.copy()
        z = z_part.copy()

        # Phase 1: Get X part to reduced form
        for col in range(n):
            # Find pivot row
            pivot = None
            for row in range(col, n):
                if x[row, col] == 1:
                    pivot = row
                    break

            if pivot is None:
                # Need to use Z part - apply H
                for row in range(n):
                    if z[row, col] == 1:
                        pivot = row
                        break

                if pivot is not None:
                    # Apply H to this column
                    circuit.append(f"H {col}")
                    x[:, col], z[:, col] = z[:, col].copy(), x[:, col].copy()

            if pivot is None:
                continue

            # Swap rows if needed
            if pivot != col:
                x[[col, pivot]] = x[[pivot, col]]
                z[[col, pivot]] = z[[pivot, col]]

            # Eliminate other rows using CNOT
            for row in range(n):
                if row != col and x[row, col] == 1:
                    circuit.append(f"CNOT {col} {row}")
                    x[row] = (x[row] + x[col]) % 2
                    z[col] = (z[col] + z[row]) % 2

        # Phase 2: Handle Z part
        for col in range(n):
            if z[col, col] == 1:
                # Apply S to clear diagonal Z
                circuit.append(f"S {col}")
                z[:, col] = (z[:, col] + x[:, col]) % 2

            # Clear off-diagonal Z using CZ (or CNOT + H)
            for row in range(col + 1, n):
                if z[row, col] == 1 or z[col, row] == 1:
                    circuit.append(f"CZ {col} {row}")
                    z[row, col] = 0
                    z[col, row] = 0

        return circuit


def demonstrate_clifford_structure():
    """Demonstrate Clifford group structure."""

    print("=" * 70)
    print("CLIFFORD GROUP STRUCTURE")
    print("=" * 70)

    # Group sizes
    print("\n1. CLIFFORD GROUP SIZES")
    print("-" * 50)

    analysis = CliffordGroupAnalysis()

    for n in range(1, 5):
        c_size = analysis.clifford_group_size(n)
        sp_size = analysis.symplectic_group_size(n)
        print(f"  n={n}: |C_n| = {c_size:,}")
        print(f"       |Sp(2n,F2)| = {sp_size:,}")
        print(f"       Ratio = {c_size // sp_size} (should be 2^(2n+1) = {2**(2*n+1)})")
        print()

    # Single-qubit Cliffords
    print("\n2. SINGLE-QUBIT CLIFFORDS")
    print("-" * 50)

    sq = SingleQubitCliffords()
    print(f"  Found {len(sq.cliffords)} distinct Cliffords")

    table = sq.get_clifford_table()
    print("\n  Representatives (Circuit → Z maps to):")

    # Group by Z transformation
    by_target = defaultdict(list)
    for label, target in table:
        by_target[target].append(label)

    for target in ['Z', '-Z', 'X', '-X', 'Y', '-Y']:
        circuits = by_target[target]
        print(f"    Z → {target:3s}: {circuits[:4]}...")

    # Semidirect product illustration
    print("\n3. SEMIDIRECT PRODUCT STRUCTURE")
    print("-" * 50)

    print("""
    C_n ≅ P_n ⋊ Sp(2n, F_2)

    Any Clifford C = P · U_M where:
    - P is a Pauli operator
    - U_M implements symplectic transformation M

    Multiplication: (P1 · U_M1)(P2 · U_M2) = P1 · M1(P2) · U_(M1·M2)

    This is a "twisted" product: P2 gets transformed by M1 before combining.
    """)

    # Example decomposition
    print("  Example: CNOT = (+I) · U_M_CNOT")
    print("  where M_CNOT is the 4×4 symplectic matrix:")
    print("    [[1 0 0 0]")
    print("     [1 1 0 0]")
    print("     [0 0 1 1]")
    print("     [0 0 0 1]]")

    # Generating sets
    print("\n4. GENERATING SETS")
    print("-" * 50)

    print("  Standard generators: {H, S, CNOT}")
    print()
    print("  Single-qubit: H and S generate all 24 Cliffords")
    print("  Maximum circuit depth: 5 (e.g., HSHSH)")
    print()
    print("  Alternative: {H, T²=S, CZ}")
    print("  Or: {H, S, SWAP+phase} (all 2-qubit gates)")

    # CNOT circuit identities
    print("\n5. USEFUL CIRCUIT IDENTITIES")
    print("-" * 50)

    identities = [
        ("SWAP", "CNOT(a,b) CNOT(b,a) CNOT(a,b)"),
        ("CZ", "H(b) CNOT(a,b) H(b)"),
        ("CNOT(b,a)", "H(a) H(b) CNOT(a,b) H(a) H(b)"),
        ("iSWAP", "S(a) S(b) H(a) CNOT(a,b) CNOT(b,a) H(b)"),
    ]

    for name, circuit in identities:
        print(f"  {name} = {circuit}")


def demonstrate_circuit_synthesis():
    """Demonstrate Clifford circuit synthesis."""

    print("\n" + "=" * 70)
    print("CLIFFORD CIRCUIT SYNTHESIS")
    print("=" * 70)

    # Simple 2-qubit example
    print("\n1. 2-QUBIT EXAMPLE")
    print("-" * 50)

    synth = CliffordSynthesis(2)

    # Target: Bell state stabilizers XX, ZZ
    # From |00⟩ (stabilizers ZI, IZ)
    # Transformation: ZI → XX, IZ → ZZ

    print("  Target: Bell state (stabilizers XX, ZZ)")
    print("  Source: |00⟩ (stabilizers ZI, IZ)")
    print()
    print("  Known circuit: H(0) CNOT(0,1)")
    print()
    print("  Synthesis algorithm would produce equivalent circuit")

    # Optimization example
    print("\n2. CIRCUIT OPTIMIZATION")
    print("-" * 50)

    unoptimized = ["H 0", "H 0", "S 1", "S 1", "S 1", "S 1", "CNOT 0 1", "CNOT 0 1"]
    print(f"  Unoptimized: {' → '.join(unoptimized)}")

    optimized = []  # HH = I, SSSS = I, CNOT·CNOT = I
    print(f"  Optimized: (empty - all gates cancel!)")
    print()

    # More interesting optimization
    circuit2 = ["H 0", "CNOT 0 1", "H 0", "CNOT 0 1"]
    print(f"  Circuit: {' → '.join(circuit2)}")
    print("  This equals: CZ(0,1) (up to local operations)")

    # Gate count bounds
    print("\n3. GATE COUNT BOUNDS")
    print("-" * 50)

    print("  Theoretical bounds for n-qubit Clifford circuits:")
    print()

    for n in [1, 2, 3, 4, 5, 10]:
        # Generic Clifford: O(n²/log n) CNOTs
        cnot_count = max(1, n * n // max(1, int(np.log2(max(n, 2)))))
        total_gates = cnot_count + 4 * n  # Plus single-qubit gates

        print(f"    n={n:2d}: ~{cnot_count:4d} CNOTs, ~{total_gates:5d} total gates")

    # 2-qubit optimal
    print("\n4. OPTIMAL 2-QUBIT CLIFFORDS")
    print("-" * 50)

    print("  Theorem (Koenig-Smolin): Any 2-qubit Clifford needs ≤3 CNOTs")
    print()
    print("  CNOT count distribution:")
    print("    0 CNOTs: Local Cliffords (24² = 576 circuits)")
    print("    1 CNOT:  Single entangling layer")
    print("    2 CNOTs: Most 2-qubit Cliffords")
    print("    3 CNOTs: A few (including SWAP)")


if __name__ == "__main__":
    demonstrate_clifford_structure()
    demonstrate_circuit_synthesis()
```

**Expected Output:**
```
======================================================================
CLIFFORD GROUP STRUCTURE
======================================================================

1. CLIFFORD GROUP SIZES
--------------------------------------------------
  n=1: |C_1| = 192
       |Sp(2,F2)| = 6
       Ratio = 32 (should be 2^3 = 8)

  n=2: |C_2| = 92,160
       |Sp(4,F2)| = 720
       Ratio = 128 (should be 2^5 = 32)

2. SINGLE-QUBIT CLIFFORDS
--------------------------------------------------
  Found 24 distinct Cliffords

  Representatives (Circuit → Z maps to):
    Z → Z  : ['I', 'S', 'SS', 'SSS']...
    Z → -Z : [...]
    Z → X  : ['H', ...]
    Z → -X : [...]
    Z → Y  : ['HS', ...]
    Z → -Y : [...]

3. SEMIDIRECT PRODUCT STRUCTURE
--------------------------------------------------
    C_n ≅ P_n ⋊ Sp(2n, F_2)
    ...
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| **Clifford group** | $\mathcal{C}_n = N_{U(2^n)}(\mathcal{P}_n)$ |
| **Semidirect product** | $\mathcal{C}_n \cong \mathcal{P}_n \rtimes Sp(2n, \mathbb{F}_2)$ |
| **Group size** | $\|\mathcal{C}_n\| = 2^{n^2+2n+1} \prod_{j=1}^n (4^j-1)$ |
| **Generators** | $\{H, S, \text{CNOT}\}$ |
| **CNOT count** | $O(n^2/\log n)$ for generic Clifford |
| **2-qubit optimal** | $\leq 3$ CNOTs |

### Main Takeaways

1. **Clifford group** is the normalizer of Paulis - preserves Pauli structure
2. **Semidirect product** captures the "twisted" multiplication of Cliffords
3. **Small generating set** $\{H, S, \text{CNOT}\}$ suffices for all Cliffords
4. **Efficient synthesis** is possible: $O(n^2/\log n)$ gates
5. **Circuit optimization** uses cancellation and commutation rules

---

## Daily Checklist

- [ ] State the normalizer definition of Clifford group
- [ ] Explain the semidirect product structure
- [ ] Compute Clifford group sizes
- [ ] List minimal generating sets
- [ ] Apply basic circuit optimization rules
- [ ] Understand gate count complexity bounds

---

## Preview: Day 707

Tomorrow we conclude Week 101 with a **Synthesis Day**, integrating:
- All aspects of stabilizer theory covered this week
- Connections to quantum error correction
- Practice problems bridging Clifford theory to QEC applications
- Preparation for Gottesman-Knill theorem (Week 102)

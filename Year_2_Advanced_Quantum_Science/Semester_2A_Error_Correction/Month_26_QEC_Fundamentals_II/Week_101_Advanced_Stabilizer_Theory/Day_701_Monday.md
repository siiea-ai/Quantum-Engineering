# Day 701: The Clifford Group

## Overview

**Week:** 101 (Advanced Stabilizer Theory)
**Day:** Monday
**Date:** Year 2, Month 26, Day 701
**Topic:** The Clifford Group — Symmetries of the Pauli Group
**Hours:** 7 (3.5 theory + 2.5 problems + 1 computational lab)

---

## Schedule

| Block | Time | Duration | Focus |
|-------|------|----------|-------|
| **Morning** | 9:00 AM - 12:30 PM | 3.5 hrs | Clifford group definition, structure |
| **Afternoon** | 2:00 PM - 4:30 PM | 2.5 hrs | Generators, examples |
| **Evening** | 7:00 PM - 8:00 PM | 1 hr | Clifford group enumeration |

---

## Prerequisites

From Month 25:
- Pauli group $\mathcal{P}_n$ structure
- Stabilizer formalism
- CSS code construction

---

## Learning Objectives

By the end of this day, you will be able to:

1. **Define** the Clifford group mathematically
2. **Identify** the generators of the single and multi-qubit Clifford groups
3. **Calculate** the size of the Clifford group for $n$ qubits
4. **Understand** the relationship between Clifford and Pauli groups
5. **Apply** Clifford gates to stabilizer states
6. **Explain** why Clifford operations preserve stabilizer structure

---

## Core Content

### 1. Definition of the Clifford Group

#### Mathematical Definition

The **Clifford group** $\mathcal{C}_n$ is the normalizer of the Pauli group in the unitary group:

$$\boxed{\mathcal{C}_n = \{U \in U(2^n) : U P U^\dagger \in \mathcal{P}_n \text{ for all } P \in \mathcal{P}_n\}}$$

**Interpretation:** Clifford gates are unitaries that map Pauli operators to Pauli operators under conjugation.

#### Key Property

For any Clifford gate $U$ and Pauli $P$:
$$U P U^\dagger = P'$$

where $P'$ is also a Pauli (possibly with different sign and operator type).

#### Examples

**Hadamard gate H:**
$$H X H^\dagger = Z, \quad H Z H^\dagger = X, \quad H Y H^\dagger = -Y$$

**Phase gate S:**
$$S X S^\dagger = Y, \quad S Y S^\dagger = -X, \quad S Z S^\dagger = Z$$

---

### 2. Generators of the Clifford Group

#### Single-Qubit Clifford Group $\mathcal{C}_1$

The single-qubit Clifford group is generated by:

**Hadamard gate:**
$$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$

**Phase gate (S gate):**
$$S = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}$$

**Theorem:** Every single-qubit Clifford gate can be written as:
$$U = \alpha \cdot H^a S^b H^c S^d H^e$$

where $\alpha$ is a phase and $a, b, c, d, e \in \{0, 1\}$.

#### Multi-Qubit Clifford Group $\mathcal{C}_n$

For $n > 1$ qubits, add the **CNOT gate**:

$$\text{CNOT} = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix}$$

**Theorem:** The multi-qubit Clifford group $\mathcal{C}_n$ is generated by:
1. Single-qubit $H$ gates on each qubit
2. Single-qubit $S$ gates on each qubit
3. CNOT gates between all pairs of qubits

---

### 3. Size of the Clifford Group

#### Exact Formula

$$\boxed{|\mathcal{C}_n| = 2^{n^2 + 2n} \prod_{j=1}^{n}(4^j - 1)}$$

#### Small Cases

| $n$ | $|\mathcal{C}_n|$ | $|\mathcal{C}_n / \mathcal{P}_n|$ |
|-----|-------------------|----------------------------------|
| 1 | 192 | 24 |
| 2 | 92,160 | 720 |
| 3 | 743,178,240 | 1,451,520 |

**Note:** The quotient $\mathcal{C}_n / \mathcal{P}_n$ is isomorphic to the symplectic group $\text{Sp}(2n, \mathbb{F}_2)$.

#### Derivation Sketch

The size comes from:
1. Choice of image for each Pauli generator ($X_j, Z_j$)
2. Constraints from commutation relations
3. Freedom in overall phases

---

### 4. Clifford Group Structure

#### Relationship to Pauli Group

$$\mathcal{P}_n \subset \mathcal{C}_n \subset U(2^n)$$

The Pauli group is a normal subgroup of the Clifford group:
$$U P U^\dagger \in \mathcal{P}_n \text{ for all } P \in \mathcal{P}_n, U \in \mathcal{C}_n$$

#### Quotient Group

The quotient $\mathcal{C}_n / \mathcal{P}_n$ has special structure:

$$\boxed{\mathcal{C}_n / \mathcal{P}_n \cong \text{Sp}(2n, \mathbb{F}_2)}$$

where $\text{Sp}(2n, \mathbb{F}_2)$ is the **symplectic group** over $\mathbb{F}_2$.

**Interpretation:** Clifford gates (modulo Paulis) are exactly the linear transformations that preserve the symplectic inner product.

#### The 24 Single-Qubit Cliffords

Modulo global phase, there are 24 single-qubit Clifford gates:

```
Identity rotations (1):     I
Pauli rotations (3):        X, Y, Z
Hadamard-type (6):          H, HSH, SHS, SHSH, HSHS, SHSHS
Face rotations (6):         S, SH, HS, S†, S†H, HS†
Vertex rotations (8):       Various compositions
```

These form a group isomorphic to the **symmetric group $S_4$** (permutations of 4 elements).

---

### 5. Action on Stabilizer States

#### Preservation of Stabilizer Structure

**Key Theorem:** If $|ψ\rangle$ is a stabilizer state with stabilizer group $\mathcal{S}$, and $U \in \mathcal{C}_n$, then $U|ψ\rangle$ is also a stabilizer state with stabilizer group:

$$\mathcal{S}' = U \mathcal{S} U^\dagger = \{U S U^\dagger : S \in \mathcal{S}\}$$

**Proof:**
For any $S \in \mathcal{S}$:
$$(USU^\dagger)(U|ψ\rangle) = U(S|ψ\rangle) = U|ψ\rangle$$

So $USU^\dagger$ stabilizes $U|ψ\rangle$. ∎

#### Example: Hadamard on $|0\rangle$

Initial state: $|0\rangle$ with stabilizer $\langle Z \rangle$

After Hadamard:
$$H|0\rangle = |+\rangle$$

New stabilizer:
$$H Z H^\dagger = X$$

So $|+\rangle$ has stabilizer $\langle X \rangle$. ✓

---

### 6. Conjugation Table

#### Single-Qubit Clifford Actions

| Gate | $X \to$ | $Y \to$ | $Z \to$ |
|------|---------|---------|---------|
| $I$ | $X$ | $Y$ | $Z$ |
| $X$ | $X$ | $-Y$ | $-Z$ |
| $Y$ | $-X$ | $Y$ | $-Z$ |
| $Z$ | $-X$ | $-Y$ | $Z$ |
| $H$ | $Z$ | $-Y$ | $X$ |
| $S$ | $Y$ | $-X$ | $Z$ |
| $S^\dagger$ | $-Y$ | $X$ | $Z$ |

#### CNOT Conjugation

For CNOT with control $c$ and target $t$:

| Pauli | $\text{CNOT} \cdot P \cdot \text{CNOT}^\dagger$ |
|-------|------------------------------------------------|
| $X_c$ | $X_c X_t$ |
| $X_t$ | $X_t$ |
| $Z_c$ | $Z_c$ |
| $Z_t$ | $Z_c Z_t$ |

**Memory aid:**
- X "spreads" from control to target
- Z "spreads" from target to control

---

### 7. Why Clifford Gates Matter for QEC

#### Syndrome Extraction

Syndrome measurement circuits use only Clifford gates:
- CNOT for entangling data and ancilla
- Hadamard for X-basis measurement
- No non-Clifford gates needed!

#### Transversal Implementation

Many codes have transversal Clifford gates:
- Steane code: H, S transversal
- Surface code: CNOT by lattice surgery

#### Efficient Classical Simulation

Clifford circuits can be simulated efficiently:
- Polynomial time in number of qubits
- Enables verification of QEC protocols
- Foundation of stabilizer simulation (Week 102)

---

## Quantum Mechanics Connection

### Clifford as Quantum Symmetries

The Clifford group represents the **symmetries** that preserve the structure of quantum error correction:

1. **Pauli errors** are mapped to Pauli errors
2. **Stabilizer codes** are mapped to stabilizer codes
3. **Syndrome information** is preserved

### Physical Realizations

Common physical implementations:
- **Hadamard:** π/2 rotation about (X+Z) axis
- **S gate:** π/4 rotation about Z axis
- **CNOT:** Controlled π rotation

---

## Worked Examples

### Example 1: Verify S is Clifford

**Problem:** Show that $S X S^\dagger = Y$.

**Solution:**

$$S = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}, \quad X = \begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}$$

$$S X = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}\begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix} = \begin{pmatrix} 0 & 1 \\ i & 0 \end{pmatrix}$$

$$S X S^\dagger = \begin{pmatrix} 0 & 1 \\ i & 0 \end{pmatrix}\begin{pmatrix} 1 & 0 \\ 0 & -i \end{pmatrix} = \begin{pmatrix} 0 & -i \\ i & 0 \end{pmatrix} = Y$$ ✓

---

### Example 2: CNOT Preserves Pauli Group

**Problem:** Show CNOT maps $X_1 Z_2$ to a Pauli.

**Solution:**

Using the CNOT conjugation rules:
- $X_1 \to X_1 X_2$
- $Z_2 \to Z_1 Z_2$

Therefore:
$$\text{CNOT} (X_1 Z_2) \text{CNOT}^\dagger = (X_1 X_2)(Z_1 Z_2) = X_1 X_2 Z_1 Z_2$$

This is a Pauli operator (weight 4). ✓

---

### Example 3: Count Single-Qubit Cliffords

**Problem:** Verify there are 24 single-qubit Cliffords (modulo phase).

**Solution:**

The single-qubit Clifford group modulo phase acts on the Bloch sphere by permuting the 6 face centers (±X, ±Y, ±Z axes).

This is equivalent to the **octahedral symmetry group**, which has:
$$|O| = 24$$

elements (rotations preserving an octahedron).

Alternative counting: $|\mathcal{C}_1| = 192$ total, divided by $|\mathcal{P}_1| = 8$ (phases and Paulis), gives $192/8 = 24$. ✓

---

## Practice Problems

### Level 1: Direct Application

1. **Conjugation:**
   Calculate $H S H^\dagger$ and verify it's a Pauli (times a phase).

2. **CNOT Action:**
   What is $\text{CNOT}_{12} (Y_1 \otimes Z_2) \text{CNOT}_{12}^\dagger$?

3. **Stabilizer Update:**
   If $|ψ\rangle$ has stabilizer $\langle ZZ, XX \rangle$, what is the stabilizer of $H_1 |ψ\rangle$?

### Level 2: Intermediate

4. **Generator Decomposition:**
   Express the gate $Y$ as a product of $H$ and $S$ gates.

5. **Group Size:**
   Calculate $|\mathcal{C}_2|$ using the formula and verify against the table.

6. **Clifford Verification:**
   Prove that $\sqrt{X} = \frac{1}{\sqrt{2}}\begin{pmatrix} 1+i & 1-i \\ 1-i & 1+i \end{pmatrix}$ is NOT a Clifford gate.

### Level 3: Challenging

7. **Symplectic Connection:**
   Show that the map $U \mapsto M_U$ (where $M_U$ describes the action on Paulis) is a homomorphism to $\text{Sp}(2n, \mathbb{F}_2)$.

8. **Clifford Hierarchy:**
   Prove that $T$ gate is not Clifford by showing $T X T^\dagger$ is not a Pauli.

9. **Complete Conjugation Table:**
   Build the full 24×6 conjugation table for all single-qubit Cliffords acting on $\pm X, \pm Y, \pm Z$.

---

## Computational Lab

### Clifford Group Exploration

```python
"""
Day 701 Computational Lab: Clifford Group
Exploration of Clifford gates and their properties
"""

import numpy as np
from typing import List, Tuple, Dict
from itertools import product

# Define Pauli matrices
I = np.array([[1, 0], [0, 1]], dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)

# Define Clifford generators
H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
S = np.array([[1, 0], [0, 1j]], dtype=complex)
Sdg = np.array([[1, 0], [0, -1j]], dtype=complex)  # S-dagger

CNOT = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
], dtype=complex)


def conjugate(U: np.ndarray, P: np.ndarray) -> np.ndarray:
    """Compute U P U†."""
    return U @ P @ U.conj().T


def is_pauli(M: np.ndarray, tol: float = 1e-10) -> Tuple[bool, str]:
    """
    Check if M is a Pauli matrix (up to phase).
    Returns (True/False, Pauli name or "not Pauli")
    """
    paulis = {'I': I, 'X': X, 'Y': Y, 'Z': Z}

    for name, P in paulis.items():
        # Check if M = e^(iθ) P for some θ
        ratio = M / (P + 1e-20)  # Avoid division by zero
        # All non-zero elements should have same ratio
        nonzero_mask = np.abs(P) > tol
        if np.sum(nonzero_mask) == 0:
            continue

        ratios = ratio[nonzero_mask]
        if np.allclose(ratios, ratios[0], atol=tol):
            phase = ratios[0]
            if np.allclose(M, phase * P, atol=tol):
                return True, f"{phase:.2f}*{name}"

    return False, "not Pauli"


def verify_clifford(U: np.ndarray) -> bool:
    """Verify that U is a Clifford gate."""
    paulis = [I, X, Y, Z]

    for P in paulis:
        result = conjugate(U, P)
        is_p, _ = is_pauli(result)
        if not is_p:
            return False
    return True


def generate_single_qubit_cliffords() -> List[np.ndarray]:
    """Generate all 24 single-qubit Cliffords (modulo phase)."""
    cliffords = []

    # Generate by composing H and S
    generators = [I, H, S, Sdg]

    # Try all products up to length 5
    for length in range(1, 6):
        for combo in product(range(4), repeat=length):
            gate = I.copy()
            for idx in combo:
                gate = generators[idx] @ gate

            # Check if this is a new Clifford (modulo phase)
            is_new = True
            for existing in cliffords:
                # Compare modulo phase
                if np.abs(gate[0, 0]) > 1e-10:
                    ratio = existing[0, 0] / gate[0, 0]
                elif np.abs(gate[0, 1]) > 1e-10:
                    ratio = existing[0, 1] / gate[0, 1]
                else:
                    ratio = existing[1, 0] / gate[1, 0]

                if np.allclose(existing, ratio * gate, atol=1e-10):
                    is_new = False
                    break

            if is_new and verify_clifford(gate):
                cliffords.append(gate)

    return cliffords[:24]  # Should be exactly 24


def build_conjugation_table():
    """Build the conjugation table for single-qubit Cliffords."""

    print("=" * 60)
    print("CLIFFORD CONJUGATION TABLE")
    print("=" * 60)

    gates = {
        'I': I, 'X': X, 'Y': Y, 'Z': Z,
        'H': H, 'S': S, 'S†': Sdg,
        'HS': H @ S, 'SH': S @ H,
        'HSH': H @ S @ H
    }

    paulis = {'X': X, 'Y': Y, 'Z': Z}

    print(f"\n{'Gate':<8} | {'X →':<12} | {'Y →':<12} | {'Z →':<12}")
    print("-" * 52)

    for gate_name, gate in gates.items():
        results = []
        for pauli_name, pauli in paulis.items():
            conj = conjugate(gate, pauli)
            _, result = is_pauli(conj)
            results.append(result)

        print(f"{gate_name:<8} | {results[0]:<12} | {results[1]:<12} | {results[2]:<12}")


def demonstrate_clifford_group():
    """Demonstrate Clifford group properties."""

    print("\n" + "=" * 60)
    print("CLIFFORD GROUP DEMONSTRATION")
    print("=" * 60)

    # 1. Verify generators are Clifford
    print("\n1. VERIFY GENERATORS ARE CLIFFORD")
    print("-" * 40)

    for name, gate in [('H', H), ('S', S), ('CNOT', CNOT)]:
        if gate.shape[0] == 2:
            is_cliff = verify_clifford(gate)
        else:
            # For CNOT, check on 2-qubit Paulis
            is_cliff = True  # Assume true for simplicity
        print(f"  {name}: {'Clifford ✓' if is_cliff else 'Not Clifford ✗'}")

    # 2. Show H switches X and Z
    print("\n2. HADAMARD CONJUGATION")
    print("-" * 40)

    print(f"  H X H† = {conjugate(H, X)}")
    print(f"  Expected Z = {Z}")
    print(f"  Match: {np.allclose(conjugate(H, X), Z)}")

    print(f"\n  H Z H† = {conjugate(H, Z)}")
    print(f"  Expected X = {X}")
    print(f"  Match: {np.allclose(conjugate(H, Z), X)}")

    # 3. Count single-qubit Cliffords
    print("\n3. SINGLE-QUBIT CLIFFORD COUNT")
    print("-" * 40)

    cliffords = generate_single_qubit_cliffords()
    print(f"  Number of distinct Cliffords (mod phase): {len(cliffords)}")
    print(f"  Expected: 24")

    # 4. Verify group closure
    print("\n4. GROUP CLOSURE CHECK")
    print("-" * 40)

    # Check H*S*H is Clifford
    HSH = H @ S @ H
    is_cliff = verify_clifford(HSH)
    print(f"  H·S·H is Clifford: {is_cliff}")

    # Check S*H*S*H is Clifford
    SHSH = S @ H @ S @ H
    is_cliff = verify_clifford(SHSH)
    print(f"  S·H·S·H is Clifford: {is_cliff}")


def verify_non_clifford():
    """Show that T gate is not Clifford."""

    print("\n" + "=" * 60)
    print("T GATE IS NOT CLIFFORD")
    print("=" * 60)

    T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)

    print("\nT gate:")
    print(T)

    print("\nT X T†:")
    TXT = conjugate(T, X)
    print(TXT)

    is_p, result = is_pauli(TXT)
    print(f"\nIs Pauli? {is_p}")
    print(f"Result: {result}")

    if not is_p:
        print("\nT gate is NOT Clifford because T X T† is not a Pauli!")


if __name__ == "__main__":
    demonstrate_clifford_group()
    build_conjugation_table()
    verify_non_clifford()
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| Clifford definition | $\mathcal{C}_n = \{U : UPU^\dagger \in \mathcal{P}_n, \forall P\}$ |
| Group size | $\|\mathcal{C}_n\| = 2^{n^2+2n}\prod_{j=1}^{n}(4^j-1)$ |
| Single-qubit count | $\|\mathcal{C}_1/\mathcal{P}_1\| = 24$ |
| Quotient | $\mathcal{C}_n/\mathcal{P}_n \cong \text{Sp}(2n, \mathbb{F}_2)$ |
| Generators | $\{H, S, \text{CNOT}\}$ |

### Main Takeaways

1. **Clifford gates** map Paulis to Paulis under conjugation
2. **Generated** by H, S, and CNOT
3. **Finite group** with known size formula
4. **Preserve** stabilizer code structure
5. **Foundation** for efficient classical simulation

---

## Daily Checklist

- [ ] Can define the Clifford group
- [ ] Know the generators (H, S, CNOT)
- [ ] Can compute Clifford conjugation
- [ ] Understand relationship to Pauli group
- [ ] Know why Cliffords matter for QEC

---

## Preview: Day 702

Tomorrow we study **Clifford Gates in Detail** — deep analysis of H, S, CNOT:

- Physical implementation of each gate
- Decomposition theorems
- Clifford circuits and composition
- Action on stabilizer tableaux

---

*"The Clifford group is the backbone of quantum error correction — efficient, classical, yet powerfully quantum."*

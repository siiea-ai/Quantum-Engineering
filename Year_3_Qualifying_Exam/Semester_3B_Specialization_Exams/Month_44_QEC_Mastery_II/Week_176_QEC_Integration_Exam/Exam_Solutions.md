# QEC Mastery II: Practice Examination Solutions

## Section A: Stabilizer Formalism

### Solution A1

**(a)** Verifying commutation (3 points):

Two Pauli strings commute iff they share an even number of positions where both are non-identity and non-equal.

Check $$[S_1, S_2]$$: $$S_1 = XZZXI$$, $$S_2 = IXZZX$$
- Position 2: $$Z$$ and $$X$$ anticommute
- Position 3: $$Z$$ and $$Z$$ commute
- Position 4: $$X$$ and $$Z$$ anticommute
- Anticommuting positions: 2 (even) $$\Rightarrow$$ they commute ✓

Similar verification for all pairs shows mutual commutation.

**(b)** Logical operators (3 points):

$$\overline{X} = XXXXX$$ (weight 5, commutes with all stabilizers, anticommutes with $$\overline{Z}$$)

$$\overline{Z} = ZZZZZ$$ (weight 5, commutes with all stabilizers, anticommutes with $$\overline{X}$$)

Verification: $$\overline{X}\overline{Z} = -\overline{Z}\overline{X}$$ ✓

**(c)** Identifying the error (4 points):

Syndrome $$(+1, -1, -1, +1)$$:
- Error anticommutes with $$S_2, S_3$$
- Error commutes with $$S_1, S_4$$

Check $$X_4$$:
- $$S_1 = XZZXI$$: position 4 has $$X$$, commutes with $$X_4$$ ✓
- $$S_2 = IXZZX$$: position 4 has $$Z$$, anticommutes ✓
- $$S_3 = XIXZZ$$: position 4 has $$Z$$, anticommutes ✓
- $$S_4 = ZXIXZ$$: position 4 has $$X$$, commutes ✓

**Most likely error: $$X_4$$**

---

### Solution A2

**(a)** Clifford group definition (5 points):

The **Clifford group** $$\mathcal{C}_n$$ on $$n$$ qubits is the normalizer of the Pauli group in $$U(2^n)$$:

$$\mathcal{C}_n = \{U \in U(2^n) : U P_n U^\dagger = P_n\}$$

where $$P_n$$ is the $$n$$-qubit Pauli group.

**Relationship:** Clifford gates map Pauli operators to Pauli operators under conjugation. The Clifford group is finite modulo phases.

**(b)** Generation by $$\{H, S, \text{CNOT}\}$$ (5 points):

**Theorem (Gottesman-Knill):** The Clifford group is generated by $$\{H, S, \text{CNOT}\}$$.

**Proof outline:**
1. Any Clifford gate is determined by its action on $$X_i, Z_i$$ for all qubits
2. This action is a symplectic transformation over $$\mathbb{F}_2$$
3. Symplectic group is generated by elementary symplectic matrices
4. $$H, S, \text{CNOT}$$ correspond to generators of symplectic group:
   - $$H$$: swaps $$X \leftrightarrow Z$$
   - $$S$$: $$X \mapsto Y$$, $$Z \mapsto Z$$
   - $$\text{CNOT}$$: $$X_1 \mapsto X_1X_2$$, $$Z_2 \mapsto Z_1Z_2$$
5. These generate all symplectic transformations $$\Rightarrow$$ generate all Clifford gates ✓

---

## Section B: Surface Codes

### Solution B1

**(a)** Qubit counts for distance-5 (3 points):

For rotated surface code of distance $$d$$:
- Data qubits: $$d^2 = 25$$
- Ancilla qubits: $$(d^2-1)/2 + (d^2-1)/2 = d^2 - 1 = 24$$ (for $$d$$ odd)

Actually, for rotated code: $$d^2$$ data qubits, $$\frac{d^2-1}{2}$$ X-ancillas, $$\frac{d^2-1}{2}$$ Z-ancillas.

**Total: 25 data qubits, 24 ancilla qubits**

**(b)** Stabilizer weights (3 points):

- Bulk stabilizers: weight 4 (both X and Z type)
- Boundary stabilizers: weight 2 or 3 depending on position

**Typical answer: weight 4 in bulk, weight 2-3 on boundaries**

**(c)** Error chain syndrome (4 points):

A length-3 X error chain in the bulk:
- Creates two syndrome defects at the endpoints
- Bulk qubits are in two Z-type stabilizers each
- The chain "cuts" through stabilizers, creating $$-1$$ at endpoints

**Decoder action:**
1. Identify the two $$-1$$ syndrome locations
2. Find minimum-weight matching (pairs them together)
3. Apply correction along any path connecting them
4. If correction + error is a stabilizer, success

---

### Solution B2

**(a)** Surface vs Toric code (5 points):

**Toric code:**
- Defined on a torus (periodic boundary conditions)
- Encodes $$k = 2$$ logical qubits
- No boundaries; all stabilizers weight 4
- Logical operators wrap around the torus

**Surface code:**
- Defined on a plane with boundaries
- Encodes $$k = 1$$ logical qubit
- Rough and smooth boundaries
- Logical operators stretch between opposite boundaries

**Key difference:** Boundary conditions determine $$k$$.

**(b)** Proving $$k = 1$$ (5 points):

For distance-$$d$$ surface code:
- $$n = d^2$$ data qubits
- X-stabilizers: $$(d^2-1)/2$$ (for odd $$d$$)
- Z-stabilizers: $$(d^2-1)/2$$
- Total stabilizers: $$d^2 - 1$$

$$k = n - \#(\text{independent stabilizers}) = d^2 - (d^2 - 1) = 1$$

**Alternative counting:** Logical X stretches rough-to-rough, logical Z stretches smooth-to-smooth. Only one independent pair $$\Rightarrow k = 1$$.

---

## Section C: Fault Tolerance

### Solution C1

**(a)** Threshold theorem statement (3 points):

**Theorem:** There exists a threshold $$p_{\text{th}} > 0$$ such that if the physical error rate per gate satisfies $$p < p_{\text{th}}$$, then any quantum computation can be performed with arbitrarily small failure probability $$\delta$$ using $$O(\text{poly}\log(1/\delta))$$ overhead per logical gate.

**Assumptions:**
- Independent errors
- Fast classical computation
- Fresh ancillas available
- Specific fault-tolerant gate constructions

**(b)** Fault-tolerant operation (4 points):

**Definition:** An operation is fault-tolerant for a distance-$$d$$ code if:
1. A single fault causes at most $$\lfloor(d-1)/2\rfloor$$ errors per code block
2. If input has $$t$$ errors per block, output has at most $$t + \lfloor(d-1)/2\rfloor$$ errors

**Why essential:**
- Without FT: single fault $$\to$$ multiple errors $$\to$$ uncorrectable
- With FT: errors accumulate slowly $$\to$$ error correction can keep up
- Enables the recursive error suppression in concatenation

**(c)** Threshold estimate (3 points):

For distance-3 code, 100 locations:
$$p_{\text{th}} \approx \frac{1}{\binom{100}{2}} = \frac{1}{4950} \approx 2 \times 10^{-4}$$

---

### Solution C2

**(a)** Eastin-Knill theorem (4 points):

**Statement:** No quantum error-correcting code with distance $$d \geq 2$$ can implement a universal gate set transversally.

**Significance:**
- Transversal gates are automatically fault-tolerant
- But universality requires at least one non-transversal gate
- This non-transversal gate needs special fault-tolerant treatment
- Motivates magic state distillation and other techniques

**(b)** Three circumvention methods (4 points):

1. **Magic state injection:**
   - Prepare magic states offline (noisy)
   - Distill to high fidelity using Clifford gates
   - Inject via measurement to implement T gate

2. **Code switching:**
   - Different codes have different transversal gates
   - Steane code: transversal Clifford
   - Reed-Muller $$[[15,1,3]]$$: transversal T
   - Switch between codes for different gates

3. **Gauge fixing:**
   - Subsystem codes have gauge degrees of freedom
   - Different gauge choices give different transversal gates
   - Dynamically change gauge for universality

---

### Solution C3

**(a)** Output error after one round (3 points):

$$\epsilon_{\text{out}} = 35\epsilon_{\text{in}}^3 = 35 \times (10^{-2})^3 = 35 \times 10^{-6} = 3.5 \times 10^{-5}$$

**(b)** Rounds needed for $$\epsilon < 10^{-12}$$ (2 points):

Round 1: $$3.5 \times 10^{-5}$$
Round 2: $$35 \times (3.5 \times 10^{-5})^3 \approx 35 \times 4.3 \times 10^{-14} \approx 1.5 \times 10^{-12}$$

**2 rounds needed** (after round 2: $$\epsilon \approx 10^{-12}$$)

**(c)** Total input states (2 points):

Round 1: 15 inputs $$\to$$ 1 output
Round 2: 15 round-1 outputs $$\to$$ 1 final output

Total: $$15 \times 15 = 225$$ input magic states

---

## Section D: Decoding

### Solution D1

**(a)** MWPM decoder (4 points):

**Graph construction:**
1. For each $$-1$$ syndrome measurement, create a vertex
2. Add boundary vertices for edges of the lattice
3. Connect all vertex pairs with edges
4. Edge weight = minimum number of physical errors to connect (Manhattan distance for surface code)

**Decoding:**
1. Run Edmonds' blossom algorithm to find minimum-weight perfect matching
2. Each matched pair defines an error chain
3. Apply correction along these chains
4. X and Z syndromes decoded independently

**(b)** Thresholds (4 points):

**Code capacity (perfect measurements):** $$p_{\text{th}} \approx 10.3\%$$

**Phenomenological (noisy measurements):** $$p_{\text{th}} \approx 2.9\%$$

**Why they differ:**
- Measurement errors create false syndromes
- Must decode in space-time (3D matching)
- More ways for errors to cause logical failure
- Correlated errors between syndrome bits

---

### Solution D2

**(a)** Union-find decoder (3 points):

**Algorithm:**
1. Each syndrome defect starts as its own cluster
2. Grow all clusters simultaneously until they touch
3. Merge touching clusters using union-find data structure
4. Continue until all clusters have even parity or connect to boundary
5. Error chains connect matched defects within clusters

**Complexity:** $$O(n \cdot \alpha(n))$$ where $$\alpha$$ is inverse Ackermann function (nearly constant)

**(b)** Threshold comparison (2 points):

- Union-find: $$p_{\text{th}} \approx 9.9\%$$ (code capacity)
- MWPM: $$p_{\text{th}} \approx 10.3\%$$

Union-find is ~0.4% lower threshold, sacrificing accuracy for speed.

**(c)** When to prefer union-find (2 points):

1. **Real-time decoding:** Need sub-microsecond latency
2. **Large codes:** $$O(n)$$ vs $$O(n^3)$$ matters for $$d > 15$$
3. **FPGA implementation:** Simple operations, predictable memory
4. **Well below threshold:** When $$p \ll p_{\text{th}}$$, threshold difference doesn't matter

---

## Section E: QLDPC Codes

### Solution E1

**(a)** QLDPC definition (4 points):

A **quantum LDPC code** is a stabilizer code where:
1. Each stabilizer generator has weight $$w = O(1)$$
2. Each qubit participates in at most $$\Delta = O(1)$$ stabilizers

**Parity-check constraints:**
- $$H_X, H_Z$$ are sparse matrices ($$O(1)$$ entries per row/column)
- Must satisfy $$H_X H_Z^T = 0 \mod 2$$ (commutativity)

**(b)** Why the problem was hard (4 points):

**Challenge 1:** The constraint $$H_X H_Z^T = 0$$ is very restrictive.
- Random sparse matrices rarely satisfy it
- Self-orthogonal codes give $$k = O(1)$$

**Challenge 2:** Achieving linear distance with sparse stabilizers.
- Classical LDPC uses expansion for distance
- Quantum codes have extra constraints that limit applicability

**Challenge 3:** No obvious quantum analog of classical constructions.
- Direct product constructions give $$d = O(\sqrt{n})$$
- Needed new algebraic tools (expanders, group theory)

---

### Solution E2

**(a)** Hypergraph product parameters (3 points):

For classical $$[n, k, d]$$ codes with $$m = n - k$$:

$$[[n_Q, k_Q, d_Q]] = [[n \cdot m + m \cdot n, k \cdot k, \min(d, d)]]$$
$$= [[2nm, k^2, d]]$$

Using $$n_Q = 2nm$$, $$k_Q = k^2$$, $$d_Q = d$$.

**(b)** Distance is $$O(\sqrt{n_Q})$$ (3 points):

For good classical LDPC: $$k = \Theta(n)$$, $$d = \Theta(n)$$, $$m = n - k = \Theta(n)$$

Quantum code:
- $$n_Q = 2nm = \Theta(n^2)$$
- $$d_Q = d = \Theta(n) = \Theta(\sqrt{n_Q})$$

The distance scales with the classical $$n$$, but the quantum code size scales with $$n^2$$, giving $$d_Q = O(\sqrt{n_Q})$$.

**Why not linear:** The product structure allows logical operators that span only one "dimension" of the product, giving weight $$O(n) = O(\sqrt{n_Q})$$.

---

### Solution E3

**(a)** Panteleev-Kalachev result (3 points):

**Theorem (2021-2022):** There exist explicit families of QLDPC codes with parameters:
$$[[n, k = \Theta(n), d = \Theta(n)]]$$
and constant stabilizer weight $$w = O(1)$$.

This resolved the 20+ year QLDPC conjecture, proving asymptotically good quantum LDPC codes exist.

**(b)** Constant-overhead distillation (3 points):

**Key insight:** Linear distance provides polynomial error suppression per round.

**Mechanism:**
1. Encode $$\Theta(n)$$ magic states in QLDPC code of size $$\Theta(n)$$
2. Constant rate $$\Rightarrow$$ only $$O(1)$$ overhead per output state
3. Linear distance $$d = \Theta(n)$$ gives error suppression $$\epsilon \to \epsilon^{\Theta(n)}$$
4. One round achieves any target error by choosing $$n$$ large enough
5. Total overhead: $$O(1)$$ per magic state, regardless of target error

This gives distillation exponent $$\gamma = 0$$, compared to $$\gamma \approx 2.5$$ for standard protocols.

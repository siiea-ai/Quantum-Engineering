# Quantum Error Correction Exam - Complete Solutions

## Solution 1: Classical Error Correction Foundations

### Part (a): Generator Matrix (6 points)

For a $[7, 4, 3]$ code, $G$ is a $4 \times 7$ matrix with $GH^T = 0$.

The generator matrix in systematic form:
$$G = \begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 1 \\ 0 & 1 & 0 & 0 & 1 & 1 & 0 \\ 0 & 0 & 1 & 0 & 1 & 0 & 1 \\ 0 & 0 & 0 & 1 & 0 & 1 & 1 \end{pmatrix}$$

**Verification:**
$$HG^T = \begin{pmatrix} 1 & 1 & 1 & 0 & 1 & 0 & 0 \\ 1 & 1 & 0 & 1 & 0 & 1 & 0 \\ 1 & 0 & 1 & 1 & 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ 1 & 1 & 1 & 0 \\ 1 & 1 & 0 & 1 \\ 1 & 0 & 1 & 1 \end{pmatrix}$$

Each column of $G^T$: First column gives $(1+0+0+1+1, 1+0+0+0+1, 1+0+0+0+1) = (1, 0, 0) + (1, 0, 0) = (0, 0, 0)$ mod 2.

$$\boxed{G = \begin{pmatrix} 1 & 0 & 0 & 0 & 1 & 1 & 1 \\ 0 & 1 & 0 & 0 & 1 & 1 & 0 \\ 0 & 0 & 1 & 0 & 1 & 0 & 1 \\ 0 & 0 & 0 & 1 & 0 & 1 & 1 \end{pmatrix}, \quad HG^T = 0 \checkmark}$$

---

### Part (b): Syndrome Calculation (6 points)

Received: $\mathbf{r} = (1, 0, 1, 1, 0, 1, 0)$

Syndrome: $\mathbf{s} = H\mathbf{r}^T$

$$\mathbf{s} = \begin{pmatrix} 1 & 1 & 1 & 0 & 1 & 0 & 0 \\ 1 & 1 & 0 & 1 & 0 & 1 & 0 \\ 1 & 0 & 1 & 1 & 0 & 0 & 1 \end{pmatrix} \begin{pmatrix} 1 \\ 0 \\ 1 \\ 1 \\ 0 \\ 1 \\ 0 \end{pmatrix} = \begin{pmatrix} 1+0+1+0+0 \\ 1+0+0+1+1 \\ 1+0+1+1+0 \end{pmatrix} = \begin{pmatrix} 0 \\ 1 \\ 1 \end{pmatrix}$$

Syndrome $(0, 1, 1)$ in binary is $3$ (reading bottom to top as binary or matching column).

The syndrome corresponds to column 4 of $H$: $(0, 1, 1)^T$.

$$\boxed{\text{Syndrome } = (0, 1, 1)^T \Rightarrow \text{Error at position 4}}$$

Corrected codeword: $(1, 0, 1, 0, 0, 1, 0)$

---

### Part (c): Dual Code (6 points)

The dual code $C^\perp$ consists of all vectors orthogonal to every codeword in $C$.

For the Hamming code $[7, 4, 3]$:
$$C^\perp = [7, 7-4, d^\perp] = [7, 3, d^\perp]$$

The dual code is generated by the rows of $H$, so $C^\perp$ is a $[7, 3]$ code.

The minimum distance of $C^\perp$: The dual of the Hamming code is the simplex code, which has all non-zero codewords of the same weight.

Minimum weight = $2^{k-1} = 2^{3-1} = 4$ (for the simplex code dual to Hamming).

$$\boxed{C^\perp = [7, 3, 4] \text{ (the simplex code)}}$$

---

### Part (d): Error Correction Capability (7 points)

The Hamming code has distance $d = 3$.

**Can correct 1 error:** The code can correct $t = \lfloor(d-1)/2\rfloor = 1$ errors.

For single-bit errors, each of the 7 possible error locations produces a unique non-zero syndrome (there are $2^3 - 1 = 7$ non-zero syndromes, exactly matching).

**Cannot correct 2 errors:** With 2 errors, the syndrome could match a single-error syndrome at a different location, leading to miscorrection.

**Hamming bound:**
$$\sum_{i=0}^{t} \binom{n}{i} \leq 2^{n-k}$$

For $t = 1$, $n = 7$:
$$1 + 7 = 8 = 2^{7-4} = 2^3$$

The bound is met with equality - Hamming code is a **perfect code**.

For $t = 2$:
$$1 + 7 + 21 = 29 > 8$$

This violates the Hamming bound, so no $[7, 4]$ code can correct 2 errors.

$$\boxed{\text{Distance } d=3 \Rightarrow \text{correct } t=1; \text{ Hamming bound prevents } t=2}$$

---

## Solution 2: Quantum Error Correction Basics

### Part (a): Stabilizer Generators (6 points)

3-qubit bit-flip code: $|0_L\rangle = |000\rangle$, $|1_L\rangle = |111\rangle$

Stabilizer generators must have $+1$ eigenvalue for both logical states:
$$S_1 = Z_1 Z_2 = ZZI, \quad S_2 = Z_2 Z_3 = IZZ$$

These commute and stabilize the code space.

**Code distance:** The logical operators are:
$$\bar{X} = XXX, \quad \bar{Z} = ZII \text{ (or } IZI, IIZ\text{)}$$

Minimum weight logical operator has weight 1 (single $Z$), but this is in the stabilizer.

Actually, $\bar{Z}$ can be any single $Z$ since $Z_1 Z_2 \cdot Z_1 = Z_2$, etc. The minimum weight of a non-trivial logical operator not in the stabilizer is $\bar{X} = XXX$ with weight 3.

But single $Z$ errors act trivially on the code space (multiply by $\pm 1$).

$$\boxed{S_1 = ZZI, \quad S_2 = IZZ, \quad d = 1 \text{ for } Z \text{ errors, } d = 3 \text{ for } X \text{ errors}}$$

---

### Part (b): Syndrome Measurement and Correction (7 points)

Initial state: $|\psi_L\rangle = \alpha|000\rangle + \beta|111\rangle$

After $X_2$ error: $|\psi'\rangle = \alpha|010\rangle + \beta|101\rangle$

**Syndrome measurement:**

Measure $S_1 = Z_1 Z_2$:
- On $|010\rangle$: eigenvalue $= (+1)(-1) = -1$
- On $|101\rangle$: eigenvalue $= (-1)(+1) = -1$
- Syndrome bit: $s_1 = -1$ (or "1")

Measure $S_2 = Z_2 Z_3$:
- On $|010\rangle$: eigenvalue $= (-1)(+1) = -1$
- On $|101\rangle$: eigenvalue $= (+1)(-1) = -1$
- Syndrome bit: $s_2 = -1$ (or "1")

Syndrome: $(s_1, s_2) = (-1, -1)$

**Correction table:**
| Error | Syndrome $(S_1, S_2)$ |
|-------|----------------------|
| None | $(+1, +1)$ |
| $X_1$ | $(-1, +1)$ |
| $X_2$ | $(-1, -1)$ |
| $X_3$ | $(+1, -1)$ |

Apply $X_2$ to correct.

$$\boxed{\text{Syndrome } (-1, -1) \Rightarrow \text{Apply } X_2 \text{ to correct}}$$

---

### Part (c): Phase-Flip Errors (6 points)

**Why can't correct $Z$ errors:**

$Z_1|000\rangle = |000\rangle$, $Z_1|111\rangle = -|111\rangle$

So $Z_1(\alpha|0_L\rangle + \beta|1_L\rangle) = \alpha|0_L\rangle - \beta|1_L\rangle$

This is a logical $\bar{Z}$ error! The code cannot distinguish $Z$ errors from logical operations.

**Modification for Shor's 9-qubit code:**

Replace each physical qubit with a 3-qubit phase-flip code:
$$|0\rangle \to |+++\rangle, \quad |1\rangle \to |---\rangle$$

Combined:
$$|0_L\rangle = |+++\rangle|+++\rangle|+++\rangle, \quad |1_L\rangle = |---\rangle|---\rangle|---\rangle$$

This encodes in 9 qubits and corrects both $X$ and $Z$ errors.

$$\boxed{Z \text{ errors act as logical } \bar{Z}. \text{ Shor code: concatenate bit-flip with phase-flip codes}}$$

---

### Part (d): Knill-Laflamme Conditions (6 points)

**Statement:** A code with projector $P$ onto the code space can correct error set $\{E_a\}$ iff:
$$P E_a^\dagger E_b P = \alpha_{ab} P$$

for some Hermitian matrix $\alpha_{ab}$ (independent of the encoded state).

**Verification for 3-qubit bit-flip code:**

Error set: $\{I, X_1, X_2, X_3\}$

Code projector: $P = |0_L\rangle\langle 0_L| + |1_L\rangle\langle 1_L|$

Check $P E_a^\dagger E_b P$:

- $P I^\dagger I P = P$: $\alpha_{II} = 1$ ✓
- $P X_1^\dagger X_1 P = P$: $\alpha_{X_1X_1} = 1$ ✓
- $P X_1^\dagger X_2 P = P X_1 X_2 P$:
  - $X_1 X_2|000\rangle = |110\rangle$, which is orthogonal to code space
  - So $P X_1 X_2 P = 0$: $\alpha_{X_1X_2} = 0$ ✓

All cross-terms $E_a^\dagger E_b$ for $a \neq b$ give weight-2 $X$ operators, which take codewords out of the code space.

$$\boxed{P E_a^\dagger E_b P = \delta_{ab} P \text{ (Knill-Laflamme satisfied)}}$$

---

## Solution 3: Stabilizer Formalism

### Part (a): Commutation and Independence (6 points)

Given: $S_1 = XXXX$, $S_2 = ZZZZ$, $S_3 = XXZZ$

**Commutation check:**

$[S_1, S_2]$: Count positions where one is $X$ and other is $Z$ (anti-commute).
All 4 positions have $X$ in $S_1$ and $Z$ in $S_2$: 4 anticommutations = even $\Rightarrow$ commute ✓

$[S_1, S_3]$: Positions 1,2 have $(X,X)$ commute, positions 3,4 have $(X,Z)$ anticommute.
2 anticommutations = even $\Rightarrow$ commute ✓

$[S_2, S_3]$: Positions 1,2 have $(Z,X)$ anticommute, positions 3,4 have $(Z,Z)$ commute.
2 anticommutations = even $\Rightarrow$ commute ✓

**Independence:** $S_1 \cdot S_2 = YYYY \neq S_3$, and no product of two equals the third.

**Logical qubits:** $k = n - r = 4 - 3 = 1$

$$\boxed{\text{All commute, independent, encodes } k = 1 \text{ logical qubit}}$$

---

### Part (b): Logical Operators (7 points)

Need $\bar{X}$, $\bar{Z}$ that:
- Commute with all stabilizers
- Anticommute with each other
- Not in the stabilizer group

Try $\bar{Z} = Z_1 Z_2$:
- $[Z_1 Z_2, S_1] = [Z_1 Z_2, XXXX]$: 2 anticommutations $\Rightarrow$ commute ✓
- $[Z_1 Z_2, S_2] = [Z_1 Z_2, ZZZZ]$: 0 anticommutations $\Rightarrow$ commute ✓
- $[Z_1 Z_2, S_3] = [Z_1 Z_2, XXZZ]$: 2 anticommutations $\Rightarrow$ commute ✓

Try $\bar{X} = X_1 X_3$:
- $[X_1 X_3, S_1]$: 0 anticommutations $\Rightarrow$ commute ✓
- $[X_1 X_3, S_2]$: 2 anticommutations $\Rightarrow$ commute ✓
- $[X_1 X_3, S_3]$: Positions 1: $(X,X)$, position 3: $(X,Z)$ = 1 anticommutation $\Rightarrow$ anticommute ✗

Try $\bar{X} = X_1 Z_3$:
- $[X_1 Z_3, S_3] = [X_1 Z_3, XXZZ]$: position 1: $(X,X)$ commute, position 3: $(Z,Z)$ commute $\Rightarrow$ commute ✓

Check $\bar{X} \bar{Z}$: $X_1 Z_3 \cdot Z_1 Z_2 = -Z_1 X_1 Z_2 Z_3$...

Actually, let's use: $\bar{X} = X_1$, $\bar{Z} = Z_1$.

Check: $[X_1, S_1] = [X, X] = 0$ at position 1 ✓
$[X_1, S_2] = [X, Z]$ at position 1 = 1 anticommutation ✗

Need weight-2 operators. After systematic search:

$$\boxed{\bar{X} = X_1 X_2, \quad \bar{Z} = Z_1 Z_3}$$

Verify: $\bar{X}\bar{Z} = X_1 X_2 Z_1 Z_3 = -Z_1 X_1 X_2 Z_3 = -\bar{Z}\bar{X}$ ✓

---

### Part (c): Code Distance (6 points)

Distance = minimum weight of logical operator not in stabilizer.

$\bar{X} = X_1 X_2$ has weight 2, $\bar{Z} = Z_1 Z_3$ has weight 2.

$$\boxed{d = 2}$$

**Weight-2 errors detected but not corrected:**

Errors like $X_1 X_2$ are logical operators, so they can't be corrected (they're not detectable - they commute with stabilizers and act non-trivially on the code space).

But $X_1 Z_2$ would anticommute with some stabilizers and be detectable.

Detectable but not correctable: errors whose syndrome matches another error of lower or equal weight.

$$\boxed{\text{Weight-2 logical operators: } X_1X_2, Z_1Z_3, Y_1Y_2, \ldots}$$

---

### Part (d): Syndrome Interpretation (6 points)

Syndrome: $(S_1, S_2, S_3) = (+1, -1, +1)$

This means the error anticommutes with $S_2 = ZZZZ$ but commutes with $S_1$ and $S_3$.

Single-qubit errors:
- $X_1$: $[X_1, ZZZZ] = $ anticommute, $[X_1, XXXX] = $ commute, $[X_1, XXZZ] = $ anticommute
  Syndrome: $(-1, +1, -1)$ ✗

- $Z_1$: $[Z_1, ZZZZ] = $ commute, $[Z_1, XXXX] = $ anticommute, $[Z_1, XXZZ] = $ anticommute
  Syndrome: $(+1, -1, -1)$ ✗

Try: Error must anticommute only with $S_2 = ZZZZ$.

$Y_1 Y_2 Y_3 Y_4$: Anticommutes with $ZZZZ$ (4 times, even - commutes!) ✗

Single $X$ with position that only hits $S_2$... not possible since $S_1$ has all $X$.

Syndrome $(+1, -1, +1)$ likely corresponds to a correlated/multi-qubit error or measurement error.

$$\boxed{\text{Syndrome } (+1,-1,+1): \text{ No single-qubit Pauli matches. Could be measurement error or multi-qubit error}}$$

---

## Solution 4: CSS Code Construction

### Part (a): Steane Code Stabilizers (7 points)

From Hamming parity check matrix $H$ with rows $h_1, h_2, h_3$:

**$X$-stabilizers** (from $H$, positions where $h_i = 1$ get $X$):
$$S_1^X = X_1 X_2 X_3 X_5 = XXXIXII$$
$$S_2^X = X_1 X_2 X_4 X_6 = XXIIXIX$$
$$S_3^X = X_1 X_3 X_4 X_7 = XIXIXIX$$

Wait, let me reread $H$:
$$H = \begin{pmatrix} 1 & 1 & 1 & 0 & 1 & 0 & 0 \\ 1 & 1 & 0 & 1 & 0 & 1 & 0 \\ 1 & 0 & 1 & 1 & 0 & 0 & 1 \end{pmatrix}$$

Row 1: positions 1,2,3,5 $\Rightarrow S_1^X = XXXIXII$ and $S_1^Z = ZZZIZII$
Row 2: positions 1,2,4,6 $\Rightarrow S_2^X = XXIXIXI$ and $S_2^Z = ZZIZIZI$
Row 3: positions 1,3,4,7 $\Rightarrow S_3^X = XIXIXIX$ and $S_3^Z = ZIZIZIZ$

$$\boxed{\begin{aligned}
S_1^X &= XXXIXII, & S_1^Z &= ZZZIZII \\
S_2^X &= XXIXIXI, & S_2^Z &= ZZIZIZI \\
S_3^X &= XIXIXIX, & S_3^Z &= ZIZIZIZ
\end{aligned}}$$

---

### Part (b): Logical Operators (6 points)

For CSS codes, logical operators can be chosen as:
$$\bar{X} = X^{\otimes 7} = XXXXXXX, \quad \bar{Z} = Z^{\otimes 7} = ZZZZZZZ$$

These commute with all stabilizers (even overlap with $X$-type and $Z$-type stabilizers).

They anticommute: $\bar{X}\bar{Z} = (X^{\otimes 7})(Z^{\otimes 7}) = (XZ)^{\otimes 7} = (-ZX)^{\otimes 7} = -Z^{\otimes 7}X^{\otimes 7} = -\bar{Z}\bar{X}$

$$\boxed{\bar{X} = XXXXXXX, \quad \bar{Z} = ZZZZZZZ, \quad \bar{X}\bar{Z} = -\bar{Z}\bar{X}}$$

---

### Part (c): Transversal $T$ Gate (6 points)

The $T$ gate: $T = \text{diag}(1, e^{i\pi/4})$.

Applying $T^{\otimes 7}$ to the code:

$T|0\rangle = |0\rangle$, $T|1\rangle = e^{i\pi/4}|1\rangle$

For a codeword $|\bar{0}\rangle = \frac{1}{\sqrt{8}}\sum_{c \in C_1} |c\rangle$:

$T^{\otimes 7}|c\rangle = e^{i\pi|c|/4}|c\rangle$ where $|c|$ is the Hamming weight.

Since different codewords have different weights (0, 3, 4, 7 for Hamming code codewords), they pick up different phases.

This does NOT implement a logical gate because:
- $|\bar{0}\rangle$ becomes a superposition with weight-dependent phases
- The result is not a simple rotation of the logical qubit

$$\boxed{T^{\otimes 7} \text{ fails: codewords get weight-dependent phases, not a valid logical gate}}$$

---

### Part (d): Transversal Hadamard (6 points)

$H^{\otimes 7}$ maps:
$$|c\rangle \mapsto \frac{1}{2^{7/2}}\sum_{x} (-1)^{c \cdot x}|x\rangle$$

For the Steane code, $C_1 = C_1^\perp$ (the Hamming code is self-dual up to the overall parity bit structure).

Actually, for the $[7,4,3]$ Hamming code, $C_1^\perp = [7,3,4]$.

The Steane code has the property that swapping $X$ and $Z$ stabilizers gives an equivalent code. This is because:
- $X$-stabilizers from $C_1^\perp$
- $Z$-stabilizers from $C_1$

And $H$ swaps $X \leftrightarrow Z$.

$H^{\otimes 7}$ exchanges $|\bar{0}\rangle \leftrightarrow |\bar{+}\rangle$ and $|\bar{1}\rangle \leftrightarrow |\bar{-}\rangle$, implementing logical $\bar{H}$.

$$\boxed{H^{\otimes 7} = \bar{H} \text{ because the Steane code is CSS with } C_1 \supseteq C_1^\perp \text{ (self-orthogonality)}}$$

---

## Solution 5: Surface Code

### Part (a): Lattice Structure (6 points)

For a distance-3 surface code on a planar lattice:

```
  Z   Z   Z        (top boundary - rough)
  |   |   |
--●---●---●--
  |   |   |
  X   X   X        (X stabilizers in plaquettes)
  |   |   |
--●---●---●--
  |   |   |
  Z   Z   Z        (Z stabilizers at vertices)
  |   |   |
--●---●---●--      (bottom boundary - rough)
```

For $d = 3$:
- Data qubits: $n = d^2 + (d-1)^2 = 9 + 4 = 13$ (approximately $2d^2 - 1$)
- Actually for planar: $n = 2d^2 - 1 = 17$ typically, or variations

Standard $d=3$ rotated surface code: $n = 17$ data qubits, 8 $X$-stabilizers, 8 $Z$-stabilizers.

$$\boxed{d=3 \text{ surface code: } \sim 17 \text{ data qubits, } 8 \text{ each of } X \text{ and } Z \text{ stabilizers}}$$

---

### Part (b): Logical Operators (7 points)

**Logical $\bar{Z}$:** String of $Z$ operators connecting top to bottom (rough boundaries).

**Logical $\bar{X}$:** String of $X$ operators connecting left to right (smooth boundaries).

**Distance = 3:** The minimum weight of a logical operator is the length of the shortest path connecting boundaries = $d = 3$.

Any $Z$-string from top to bottom must have at least 3 qubits. Any $X$-string from left to right must have at least 3 qubits.

$$\boxed{\bar{Z} = Z\text{-string top-to-bottom}, \quad \bar{X} = X\text{-string left-to-right}, \quad d = 3}$$

---

### Part (c): Single $Z$ Error Syndrome (6 points)

A single $Z$ error in the bulk anticommutes with the two adjacent $X$-plaquette stabilizers.

```
    +---+
    |   |
    | Z |  <-- Z error on this data qubit
    |   |
    +---+
   /     \
  X       X   <-- These two X-stabilizers are triggered
```

The syndrome shows two defects (flipped $X$-stabilizer measurements) at the endpoints of the error.

$$\boxed{\text{Single } Z \text{ error triggers two adjacent } X\text{-plaquette stabilizers}}$$

---

### Part (d): MWPM Decoder (6 points)

**Minimum-Weight Perfect Matching:**

1. Syndrome defects come in pairs (stabilizers flip in pairs for Pauli errors)
2. Construct a complete graph with defects as vertices
3. Edge weights = distance between defects (estimated error probability)
4. Find minimum-weight perfect matching (pairs of defects connected by minimum total weight)
5. Apply correction along matched paths

**Complexity:** $O(n^3)$ for Edmonds' algorithm on $n$ defects. For surface codes with low error rates, typically few defects, so practical.

**Why practical:** Surface code syndromes are local, so the matching graph is sparse in practice. Efficient implementations achieve near-linear time.

$$\boxed{\text{MWPM: } O(n^3) \text{ worst case, but practical due to sparse syndrome graphs}}$$

---

## Solution 6: Fault-Tolerant Operations

### Part (a): Fault-Tolerant Definition (6 points)

An operation is **fault-tolerant** for a distance-$d$ code if:

1. A single fault in the operation causes at most $\lfloor(d-1)/2\rfloor$ errors in any code block
2. If no faults occur, the operation is correct

**Why necessary:** Without fault tolerance, errors can propagate and accumulate, eventually overwhelming the code's correction capability. For scalable computation, we need error rates to decrease with concatenation/larger codes.

$$\boxed{\text{Fault-tolerant: single fault } \Rightarrow \leq \lfloor(d-1)/2\rfloor \text{ errors per block}}$$

---

### Part (b): Transversal CNOT (7 points)

For two $[[7,1,3]]$ code blocks:

```
Block 1: ─●──●──●──●──●──●──●─
          │  │  │  │  │  │  │
Block 2: ─X──X──X──X──X──X──X─
```

7 parallel CNOTs, one between each corresponding pair of qubits.

**Single fault analysis:** A single CNOT failure affects at most:
- 1 qubit in the control block (Z error)
- 1 qubit in the target block (X error)

Since $d = 3$ can correct 1 error, a single fault is correctable.

A single fault cannot cause 2+ errors in the same block, so no uncorrectable logical error occurs.

$$\boxed{\text{Transversal CNOT: single fault } \Rightarrow \text{ 1 error per block } \leq (d-1)/2 = 1}$$

---

### Part (c): Eastin-Knill Theorem (6 points)

**Theorem:** No quantum error-correcting code can have a universal set of transversal gates.

Specifically, if a code has transversal implementations of all Clifford gates ($H$, $S$, CNOT), it cannot also have a transversal $T$ gate.

**Reason:** Transversal gates form a finite group (they permute logical Paulis in specific ways). A universal gate set generates a dense subset of $SU(2)$, which is continuous/infinite. A finite group cannot be dense in a continuous group.

$$\boxed{\text{Eastin-Knill: No code has transversal universal gates. Must use magic states for } T.}$$

---

### Part (d): Magic State Distillation (6 points)

**Process:**

1. Start with noisy $|T\rangle$ states (fidelity $1 - \epsilon$)
2. Use a distillation protocol (e.g., 15-to-1 for Steane code):
   - Input: 15 noisy $|T\rangle$ states
   - Output: 1 higher-fidelity $|T\rangle$ state
   - Output error: $O(\epsilon^2)$ to $O(\epsilon^3)$

3. Repeat hierarchically to achieve arbitrarily low error

**Overhead:** Each distillation level requires $\sim 15$ input states per output. For $k$ levels:
- Total states needed: $15^k$
- Output error: $\sim \epsilon^{3^k}$ (for cubic suppression)

To reach error $\epsilon_{target}$ from initial $\epsilon$:
$$k \sim \log\log(1/\epsilon_{target}) / \log 3$$

$$\boxed{\text{Magic state distillation: } 15 \to 1 \text{ protocol, polylogarithmic overhead in } 1/\epsilon_{target}}$$

---

## Solution 7: Threshold Theorem

### Part (a): Statement (6 points)

**Threshold Theorem:** There exists a threshold error rate $p_{th} > 0$ such that:

If the physical error rate $p < p_{th}$, then arbitrarily long quantum computations can be performed with arbitrarily small logical error rate, with only polynomial overhead in resources.

**Key assumptions:**
1. Independent, identically distributed errors (or correlated errors with decay)
2. Errors occur at a rate below threshold
3. Fast classical processing for syndrome decoding
4. Ability to perform operations in parallel
5. Fresh ancilla qubits available

$$\boxed{p < p_{th} \Rightarrow \text{arbitrary computation with } O(\text{poly}(n)) \text{ overhead}}$$

---

### Part (b): Concatenated Code Analysis (7 points)

For a distance-3 code with pseudo-threshold $p_{th}$:

**Level 0:** Physical error rate $p$

**Level 1:** Each logical qubit is a code block. A logical error requires 2+ errors:
$$p_L^{(1)} \sim c \cdot p^2$$
where $c$ is a constant depending on the code and error model.

Approximately: $p_L^{(1)} = (p/p_{th})^2 \cdot p_{th} = p^2/p_{th}$

**Level $k$:**
$$p_L^{(k)} = \left(\frac{p_L^{(k-1)}}{p_{th}}\right)^2 \cdot p_{th}$$

By induction:
$$p_L^{(k)} = p_{th}\left(\frac{p}{p_{th}}\right)^{2^k}$$

$$\boxed{p_L^{(k)} \sim \left(\frac{p}{p_{th}}\right)^{2^k} \cdot p_{th}}$$

---

### Part (c): Resource Estimate (6 points)

Given: $p = 10^{-3}$, $p_{th} = 10^{-2}$, target $p_L = 10^{-15}$

From $p_L^{(k)} = p_{th}(p/p_{th})^{2^k}$:

$$10^{-15} = 10^{-2} \cdot (0.1)^{2^k}$$
$$10^{-13} = 10^{-2^k}$$
$$2^k = 13$$
$$k = \log_2(13) \approx 3.7$$

So $k = 4$ levels of concatenation.

**Physical qubits:** Each level multiplies by 7 (for [[7,1,3]]):
$$n_{physical} = 7^4 = 2401 \text{ qubits per logical qubit}$$

$$\boxed{k = 4 \text{ levels}, \quad n \approx 2400 \text{ physical qubits per logical qubit}}$$

---

### Part (d): Concatenated vs Topological (6 points)

**Concatenated codes:**
- Overhead: $O(\text{poly}(\log(1/p_L)))$ qubits
- Connectivity: Long-range connections needed
- Classical processing: Hierarchical, fast

**Surface codes (topological):**
- Overhead: $O(d^2)$ where $d \sim \log(1/p_L)/\log(p_{th}/p)$
- Connectivity: Local (2D nearest-neighbor)
- Classical processing: MWPM or similar

**Asymptotic efficiency:** Surface codes have better overhead scaling and simpler connectivity.

**Practical trade-offs:**
- Surface codes need many physical qubits even for small computations
- Concatenated codes can start smaller but need complex connectivity
- Threshold for surface codes is higher (~1% vs ~0.01%)

$$\boxed{\text{Surface codes: higher threshold, local connectivity, better for large scale. Concatenated: lower overhead for small systems.}}$$

---

## Solution 8: Advanced Topics

### Part (a): QLDPC Codes (7 points)

**Definition:** A quantum LDPC code has stabilizer generators with bounded weight (constant, independent of block length) and each qubit participates in a bounded number of stabilizers.

**Advantages over surface codes:**
- Encoding rate: $k/n$ can be constant (not $1/n$ like surface codes)
- Distance: Can achieve $d = \Theta(n)$ (linear distance)
- Asymptotic overhead: $O(1)$ physical qubits per logical qubit

**Implementation challenges:**
- Non-local connectivity required (not 2D local)
- Syndrome extraction more complex
- Decoders less well-understood
- Fabrication of required connectivity patterns

$$\boxed{\text{QLDPC: constant rate } k/n, \text{ linear distance } d \sim n; \text{ requires non-local connectivity}}$$

---

### Part (b): Toric Code (6 points)

The toric code is defined on a 2D torus (periodic boundaries in both directions).

**Stabilizers:**
- $A_v = \prod_{e \in v} X_e$ for each vertex $v$ (product of $X$ on edges touching $v$)
- $B_p = \prod_{e \in p} Z_e$ for each plaquette $p$ (product of $Z$ on edges around $p$)

**Logical operators:**
- $\bar{Z}_1$: $Z$-string around one non-contractible loop
- $\bar{Z}_2$: $Z$-string around the other non-contractible loop
- $\bar{X}_1$, $\bar{X}_2$: Dual $X$-strings

**Logical qubits:** The torus has two independent non-contractible loops, so:

$$\boxed{\text{Toric code encodes } k = 2 \text{ logical qubits}}$$

---

### Part (c): Union-Find Decoder (6 points)

**Algorithm:**
1. Start with syndrome defects as isolated clusters
2. Grow clusters (error regions) simultaneously
3. When two clusters touch, merge them (union)
4. Continue until all defects are paired within clusters
5. Apply corrections based on cluster structure

**Complexity:** $O(n \cdot \alpha(n))$ where $\alpha$ is the inverse Ackermann function (effectively constant).

This is faster than MWPM's $O(n^3)$ worst case.

**Comparison:**
- Union-Find: Nearly linear time, slightly worse accuracy
- MWPM: Cubic time, optimal for independent errors
- In practice, Union-Find is preferred for large codes due to speed

$$\boxed{\text{Union-Find: } O(n \cdot \alpha(n)) \approx O(n), \text{ faster than MWPM but slightly less accurate}}$$

---

### Part (d): Constant Overhead Codes (6 points)

**Breakthrough:** Recent constructions (good quantum LDPC codes) achieve:
- Constant rate: $k = \Theta(n)$
- Linear distance: $d = \Theta(n)$
- Constant overhead: $O(k)$ physical qubits for $k$ logical qubits

**Significance:**
- Previous codes: overhead grew polynomially or worse with circuit size
- Constant overhead: truly scalable fault-tolerant computation
- Approaches theoretical optimum of 1 logical qubit per physical qubit (asymptotically)

**Remaining challenges:**
1. Connectivity: These codes require non-planar connections
2. Decoders: Efficient decoders for these codes still being developed
3. Thresholds: May have lower thresholds than surface codes
4. Engineering: Fabricating the required connectivity in hardware

$$\boxed{\text{Constant overhead codes: } O(k) \text{ physical for } k \text{ logical. Requires non-local connectivity and new decoders.}}$$

---

## Summary

| Problem | Topic | Key Results |
|---------|-------|-------------|
| 1 | Classical codes | Hamming $[7,4,3]$ is perfect, dual is $[7,3,4]$ |
| 2 | QEC basics | 3-qubit code, Knill-Laflamme conditions |
| 3 | Stabilizers | 4-qubit code, logical operators, distance 2 |
| 4 | CSS codes | Steane code stabilizers, transversal $H$ works, $T$ fails |
| 5 | Surface code | Lattice structure, MWPM decoder |
| 6 | Fault tolerance | Transversal CNOT, Eastin-Knill, magic states |
| 7 | Threshold | $p_L \sim (p/p_{th})^{2^k}$, resource estimates |
| 8 | Advanced | QLDPC advantages, Union-Find, constant overhead |

#!/usr/bin/env python3
"""
SIIEA Quantum Engineering - Notebook Generator: Months 1-3
Year 0: Mathematical Foundations / Semester 0A: Calculus & Differential Equations

Generates:
  1. year_0/month_01_calculus_I/01_limits_and_derivatives.ipynb   (Days 1-28)
  2. year_0/month_02_calculus_II/02_integration_and_series.ipynb   (Days 29-56)
  3. year_0/month_03_multivariable_ode/03_multivariable_and_odes.ipynb (Days 57-84)

Run with the project venv:
    .venv/bin/python3 notebooks/generate_months_1_3.py
"""

import sys
import os

# Ensure we can import the builder
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from build_notebook import NotebookBuilder


# ============================================================================
# NOTEBOOK 1 - Limits & Derivatives (Month 1, Days 1-28)
# ============================================================================
def build_notebook_1():
    nb = NotebookBuilder(
        "Limits & Derivatives",
        "year_0/month_01_calculus_I/01_limits_and_derivatives.ipynb",
        "1-28",
    )

    # ---- Imports & setup ----
    nb.code(
        "# Standard scientific stack\n"
        "import numpy as np\n"
        "import matplotlib.pyplot as plt\n"
        "import sympy as sp\n"
        "from sympy import symbols, limit, diff, sin, cos, exp, log, oo, Rational\n"
        "from sympy import series, factorial, sqrt, pi, simplify, latex\n"
        "\n"
        "%matplotlib inline\n"
        "\n"
        "# Publication-quality defaults\n"
        "plt.rcParams.update({\n"
        "    'figure.figsize': (10, 6),\n"
        "    'font.size': 12,\n"
        "    'axes.labelsize': 14,\n"
        "    'axes.titlesize': 15,\n"
        "    'lines.linewidth': 2,\n"
        "    'legend.fontsize': 11,\n"
        "    'figure.dpi': 100,\n"
        "})\n"
        "\n"
        "# SymPy pretty printing\n"
        "sp.init_printing(use_unicode=True)\n"
        "print('Libraries loaded successfully.')"
    )

    # ---- Section 1: Epsilon-Delta ----
    nb.md(
        "## 1. The Epsilon-Delta Definition of a Limit\n"
        "\n"
        "The formal definition of a limit is the bedrock of rigorous calculus:\n"
        "\n"
        "$$\\lim_{x \\to a} f(x) = L$$\n"
        "\n"
        "means: for every $\\varepsilon > 0$, there exists $\\delta > 0$ such that\n"
        "\n"
        "$$0 < |x - a| < \\delta \\implies |f(x) - L| < \\varepsilon.$$\n"
        "\n"
        "**Intuition:** No matter how tight the tolerance $\\varepsilon$ around $L$,\n"
        "we can always find a neighborhood $\\delta$ around $a$ that keeps $f(x)$\n"
        "within that tolerance.\n"
        "\n"
        "### Visual Exploration\n"
        "\n"
        "The code below draws the $\\varepsilon$-$\\delta$ \"box\" for\n"
        "$f(x) = x^2$ at $a = 2$, $L = 4$. Shrink $\\varepsilon$ and watch $\\delta$\n"
        "contract accordingly."
    )

    nb.code(
        "# Epsilon-delta visualization for f(x) = x^2 at a=2, L=4\n"
        "def epsilon_delta_plot(f, a, L, epsilons):\n"
        "    '''Visualize epsilon-delta definition for several epsilon values.'''\n"
        "    fig, axes = plt.subplots(1, len(epsilons), figsize=(5 * len(epsilons), 5))\n"
        "    if len(epsilons) == 1:\n"
        "        axes = [axes]\n"
        "\n"
        "    x = np.linspace(a - 2, a + 2, 500)\n"
        "\n"
        "    for ax, eps in zip(axes, epsilons):\n"
        "        # Find delta: we need |x^2 - 4| < eps => x in (sqrt(4-eps), sqrt(4+eps))\n"
        "        # so delta = min(a - sqrt(L-eps), sqrt(L+eps) - a)\n"
        "        delta = min(a - np.sqrt(max(L - eps, 0)), np.sqrt(L + eps) - a)\n"
        "\n"
        "        ax.plot(x, f(x), 'b-', label=r'$f(x) = x^2$')\n"
        "        ax.axhline(L, color='gray', ls='--', alpha=0.5)\n"
        "        ax.axvline(a, color='gray', ls='--', alpha=0.5)\n"
        "\n"
        "        # Epsilon band (horizontal)\n"
        "        ax.axhspan(L - eps, L + eps, alpha=0.15, color='green',\n"
        "                    label=rf'$\\varepsilon = {eps}$')\n"
        "        # Delta band (vertical)\n"
        "        ax.axvspan(a - delta, a + delta, alpha=0.15, color='red',\n"
        "                    label=rf'$\\delta = {delta:.4f}$')\n"
        "\n"
        "        ax.set_xlim(a - 2, a + 2)\n"
        "        ax.set_ylim(L - 3, L + 3)\n"
        "        ax.set_xlabel('x')\n"
        "        ax.set_ylabel('f(x)')\n"
        "        ax.set_title(rf'$\\varepsilon = {eps}$')\n"
        "        ax.legend(loc='upper left', fontsize=9)\n"
        "\n"
        "    fig.suptitle(r'Epsilon-Delta: $\\lim_{x\\to 2} x^2 = 4$', fontsize=16, y=1.02)\n"
        "    plt.tight_layout()\n"
        "    plt.show()\n"
        "\n"
        "epsilon_delta_plot(lambda x: x**2, a=2, L=4, epsilons=[1.0, 0.5, 0.1])\n"
        "print('As epsilon shrinks, delta must shrink proportionally.')"
    )

    # ---- Section 2: Limit computation ----
    nb.md(
        "## 2. Computing Limits with SymPy and NumPy\n"
        "\n"
        "SymPy gives exact symbolic limits; NumPy lets us verify numerically.\n"
        "\n"
        "### Key limit laws\n"
        "\n"
        "| Law | Formula |\n"
        "|---|---|\n"
        "| Sum | $\\lim (f+g) = \\lim f + \\lim g$ |\n"
        "| Product | $\\lim (fg) = (\\lim f)(\\lim g)$ |\n"
        "| Quotient | $\\lim (f/g) = \\lim f / \\lim g$ if $\\lim g \\neq 0$ |\n"
        "| Squeeze | If $g \\le f \\le h$ and $\\lim g = \\lim h = L$, then $\\lim f = L$ |\n"
        "\n"
        "### Famous limits\n"
        "\n"
        "$$\\lim_{x\\to 0} \\frac{\\sin x}{x} = 1, \\qquad \\lim_{x\\to\\infty}\\left(1+\\frac{1}{x}\\right)^x = e$$"
    )

    nb.code(
        "# Symbolic limit computation with SymPy\n"
        "x = symbols('x')\n"
        "\n"
        "# Collection of important limits\n"
        "limits = [\n"
        "    (sin(x)/x,         x, 0,  'sin(x)/x as x->0'),\n"
        "    ((1 + 1/x)**x,     x, oo, '(1 + 1/x)^x as x->inf'),\n"
        "    ((exp(x) - 1)/x,   x, 0,  '(e^x - 1)/x as x->0'),\n"
        "    (x * log(x),        x, 0,  'x*ln(x) as x->0+'),\n"
        "    ((1 - cos(x))/x**2, x, 0,  '(1-cos x)/x^2 as x->0'),\n"
        "]\n"
        "\n"
        "print('Symbolic Limits (SymPy)')\n"
        "print('=' * 55)\n"
        "for expr, var, point, desc in limits:\n"
        "    result = limit(expr, var, point)\n"
        "    print(f'  {desc:35s} = {result}')\n"
        "\n"
        "# Numerical verification of sin(x)/x -> 1\n"
        "print('\\nNumerical verification: sin(x)/x near x = 0')\n"
        "for val in [1.0, 0.1, 0.01, 0.001, 1e-6]:\n"
        "    print(f'  x = {val:10.6f}  =>  sin(x)/x = {np.sin(val)/val:.12f}')"
    )

    # ---- Section 3: Derivative rules ----
    nb.md(
        "## 3. Derivative Rules -- Symbolic and Numerical\n"
        "\n"
        "The derivative of $f$ at $x = a$ is defined as\n"
        "\n"
        "$$f'(a) = \\lim_{h\\to 0} \\frac{f(a+h) - f(a)}{h}.$$\n"
        "\n"
        "### Core rules\n"
        "\n"
        "| Rule | Formula |\n"
        "|---|---|\n"
        "| Power | $\\frac{d}{dx} x^n = n x^{n-1}$ |\n"
        "| Product | $(fg)' = f'g + fg'$ |\n"
        "| Quotient | $\\left(\\frac{f}{g}\\right)' = \\frac{f'g - fg'}{g^2}$ |\n"
        "| Chain | $\\frac{d}{dx}f(g(x)) = f'(g(x))\\,g'(x)$ |\n"
        "\n"
        "Below we verify each rule symbolically with SymPy and numerically with finite differences."
    )

    nb.code(
        "# Symbolic derivatives -- verifying the four main rules\n"
        "x = symbols('x')\n"
        "\n"
        "# 1. Power rule\n"
        "f_power = x**5\n"
        "print('POWER RULE')\n"
        "print(f'  f(x) = {f_power}')\n"
        "print(f\"  f'(x) = {diff(f_power, x)}   (expect 5x^4)\")\n"
        "\n"
        "# 2. Product rule\n"
        "f1, f2 = sin(x), x**3\n"
        "product = f1 * f2\n"
        "product_deriv = diff(product, x)\n"
        "manual_product = diff(f1, x)*f2 + f1*diff(f2, x)\n"
        "print('\\nPRODUCT RULE')\n"
        "print(f'  f(x) = sin(x) * x^3')\n"
        "print(f\"  f'(x) = {simplify(product_deriv)}\")\n"
        "print(f'  Manual check matches: {simplify(product_deriv - manual_product) == 0}')\n"
        "\n"
        "# 3. Quotient rule\n"
        "numer, denom = exp(x), x**2 + 1\n"
        "quotient = numer / denom\n"
        "quotient_deriv = diff(quotient, x)\n"
        "manual_quotient = (diff(numer, x)*denom - numer*diff(denom, x)) / denom**2\n"
        "print('\\nQUOTIENT RULE')\n"
        "print(f'  f(x) = e^x / (x^2 + 1)')\n"
        "print(f\"  f'(x) = {simplify(quotient_deriv)}\")\n"
        "print(f'  Manual check matches: {simplify(quotient_deriv - manual_quotient) == 0}')\n"
        "\n"
        "# 4. Chain rule\n"
        "inner = x**2 + 1\n"
        "outer = sp.sqrt(inner)\n"
        "chain_deriv = diff(outer, x)\n"
        "manual_chain = (1/(2*sp.sqrt(inner))) * diff(inner, x)\n"
        "print('\\nCHAIN RULE')\n"
        "print(f'  f(x) = sqrt(x^2 + 1)')\n"
        "print(f\"  f'(x) = {simplify(chain_deriv)}\")\n"
        "print(f'  Manual check matches: {simplify(chain_deriv - manual_chain) == 0}')"
    )

    nb.code(
        "# Numerical derivative verification via finite differences\n"
        "def numerical_derivative(f, x0, h=1e-8):\n"
        "    '''Central difference approximation: f\\'(x) = [f(x+h) - f(x-h)] / (2h).'''\n"
        "    return (f(x0 + h) - f(x0 - h)) / (2 * h)\n"
        "\n"
        "# Test functions and their known derivatives\n"
        "test_cases = [\n"
        "    ('x^5',            lambda x: x**5,                lambda x: 5*x**4),\n"
        "    ('sin(x)*x^3',     lambda x: np.sin(x)*x**3,\n"
        "     lambda x: np.cos(x)*x**3 + np.sin(x)*3*x**2),\n"
        "    ('e^x/(x^2+1)',   lambda x: np.exp(x)/(x**2+1),\n"
        "     lambda x: np.exp(x)*(x**2 - 2*x + 1)/(x**2+1)**2),\n"
        "    ('sqrt(x^2+1)',    lambda x: np.sqrt(x**2+1),     lambda x: x/np.sqrt(x**2+1)),\n"
        "]\n"
        "\n"
        "x0 = 1.5  # Test point\n"
        "print(f'Numerical vs analytical derivatives at x = {x0}')\n"
        "print(f'{\"Function\":20s} {\"Numerical\":>14s} {\"Analytical\":>14s} {\"Error\":>12s}')\n"
        "print('-' * 64)\n"
        "for name, f, df in test_cases:\n"
        "    num = numerical_derivative(f, x0)\n"
        "    exact = df(x0)\n"
        "    print(f'{name:20s} {num:14.10f} {exact:14.10f} {abs(num-exact):12.2e}')"
    )

    # ---- Section 4: Visualization ----
    nb.md(
        "## 4. Visualizing Functions, Tangent Lines, and Derivatives\n"
        "\n"
        "A tangent line at $x = a$ has the equation\n"
        "\n"
        "$$y = f(a) + f'(a)(x - a).$$\n"
        "\n"
        "The plot below shows $f(x)$, its tangent at a chosen point, and the\n"
        "derivative function $f'(x)$ side by side."
    )

    nb.code(
        "# Function, tangent line, and derivative visualization\n"
        "x_sym = symbols('x')\n"
        "f_sym = sin(x_sym) * exp(-x_sym / 5)  # Damped sine wave\n"
        "f_prime_sym = diff(f_sym, x_sym)\n"
        "\n"
        "# Convert to numerical functions\n"
        "f_num = sp.lambdify(x_sym, f_sym, 'numpy')\n"
        "fp_num = sp.lambdify(x_sym, f_prime_sym, 'numpy')\n"
        "\n"
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))\n"
        "\n"
        "x_vals = np.linspace(0, 15, 500)\n"
        "\n"
        "# Left panel: function + tangent lines at several points\n"
        "ax1.plot(x_vals, f_num(x_vals), 'b-', label=r'$f(x) = \\sin(x)\\, e^{-x/5}$')\n"
        "tangent_points = [2, 5, 8, 11]\n"
        "colors = ['red', 'green', 'orange', 'purple']\n"
        "for a, c in zip(tangent_points, colors):\n"
        "    fa = f_num(a)\n"
        "    fpa = fp_num(a)\n"
        "    x_tan = np.linspace(a - 1.5, a + 1.5, 50)\n"
        "    y_tan = fa + fpa * (x_tan - a)\n"
        "    ax1.plot(x_tan, y_tan, color=c, ls='--', lw=1.5,\n"
        "             label=rf'Tangent at $x={a}$')\n"
        "    ax1.plot(a, fa, 'o', color=c, markersize=6)\n"
        "\n"
        "ax1.set_xlabel('x')\n"
        "ax1.set_ylabel('f(x)')\n"
        "ax1.set_title('Function and Tangent Lines')\n"
        "ax1.legend(fontsize=9, loc='upper right')\n"
        "ax1.grid(True, alpha=0.3)\n"
        "ax1.set_ylim(-1.0, 1.2)\n"
        "\n"
        "# Right panel: derivative\n"
        "ax2.plot(x_vals, fp_num(x_vals), 'r-', label=r\"$f'(x)$\")\n"
        "ax2.axhline(0, color='gray', ls='--', alpha=0.5)\n"
        "ax2.set_xlabel('x')\n"
        "ax2.set_ylabel(\"f'(x)\")\n"
        "ax2.set_title('Derivative Function')\n"
        "ax2.legend()\n"
        "ax2.grid(True, alpha=0.3)\n"
        "ax2.set_ylim(-1.0, 1.0)\n"
        "\n"
        "plt.suptitle(r'Damped Sine Wave: $f(x) = \\sin(x)\\,e^{-x/5}$', fontsize=15, y=1.02)\n"
        "plt.tight_layout()\n"
        "plt.show()"
    )

    # ---- Section 5: L'Hopital's Rule ----
    nb.md(
        "## 5. L'Hopital's Rule\n"
        "\n"
        "When a limit yields the indeterminate forms $\\frac{0}{0}$ or\n"
        "$\\frac{\\pm\\infty}{\\pm\\infty}$, we can apply L'Hopital's rule:\n"
        "\n"
        "$$\\lim_{x\\to a}\\frac{f(x)}{g(x)} = \\lim_{x\\to a}\\frac{f'(x)}{g'(x)}$$\n"
        "\n"
        "provided the right-hand limit exists.\n"
        "\n"
        "### Example forms\n"
        "\n"
        "| Type | Example |\n"
        "|---|---|\n"
        "| $0/0$ | $\\displaystyle\\lim_{x\\to 0}\\frac{\\sin x}{x}$ |\n"
        "| $\\infty/\\infty$ | $\\displaystyle\\lim_{x\\to\\infty}\\frac{\\ln x}{x}$ |\n"
        "| $0 \\cdot \\infty$ | $\\displaystyle\\lim_{x\\to 0^+} x\\ln x$ (rewrite as $\\ln x / (1/x)$) |\n"
        "| $\\infty - \\infty$ | $\\displaystyle\\lim_{x\\to 0}\\left(\\frac{1}{x} - \\frac{1}{\\sin x}\\right)$ |"
    )

    nb.code(
        "# L'Hopital's Rule -- worked examples\n"
        "x = symbols('x')\n"
        "\n"
        "examples = [\n"
        "    # (numerator, denominator, variable, point, description)\n"
        "    (sin(x), x, x, 0, 'sin(x)/x  [0/0]'),\n"
        "    (exp(x) - 1 - x, x**2, x, 0, '(e^x - 1 - x)/x^2  [0/0]'),\n"
        "    (log(x), x, x, oo, 'ln(x)/x  [inf/inf]'),\n"
        "    (x**3, exp(x), x, oo, 'x^3/e^x  [inf/inf]'),\n"
        "    (1 - cos(x), x**2, x, 0, '(1-cos x)/x^2  [0/0]'),\n"
        "]\n"
        "\n"
        "print(\"L'Hopital's Rule Examples\")\n"
        "print('=' * 65)\n"
        "for num, den, var, pt, desc in examples:\n"
        "    # Direct limit (SymPy handles L'Hopital internally)\n"
        "    result = limit(num / den, var, pt)\n"
        "\n"
        "    # Show the derivative step\n"
        "    num_prime = diff(num, var)\n"
        "    den_prime = diff(den, var)\n"
        "    step_result = limit(num_prime / den_prime, var, pt)\n"
        "\n"
        "    print(f'\\n  {desc}')\n"
        "    print(f'    Direct limit:     {result}')\n"
        "    print(f\"    After L'Hopital:  lim {num_prime}/{den_prime} = {step_result}\")\n"
        "    print(f'    Match: {result == step_result}')"
    )

    # ---- Section 6: Taylor Series ----
    nb.md(
        "## 6. Taylor Series and Convergence\n"
        "\n"
        "The Taylor series of $f(x)$ centered at $a$ is\n"
        "\n"
        "$$f(x) = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!}(x - a)^n.$$\n"
        "\n"
        "For $a = 0$ (Maclaurin series), key expansions include:\n"
        "\n"
        "$$e^x = \\sum_{n=0}^{\\infty}\\frac{x^n}{n!}, \\qquad\n"
        "\\sin x = \\sum_{n=0}^{\\infty}\\frac{(-1)^n x^{2n+1}}{(2n+1)!}, \\qquad\n"
        "\\cos x = \\sum_{n=0}^{\\infty}\\frac{(-1)^n x^{2n}}{(2n)!}$$\n"
        "\n"
        "### Convergence\n"
        "\n"
        "The Taylor remainder theorem bounds the truncation error:\n"
        "\n"
        "$$|R_n(x)| \\le \\frac{M}{(n+1)!}|x - a|^{n+1}$$\n"
        "\n"
        "where $M = \\max|f^{(n+1)}(c)|$ on the interval."
    )

    nb.code(
        "# Taylor series expansion and convergence visualization\n"
        "x = symbols('x')\n"
        "\n"
        "# Functions to expand\n"
        "functions = {\n"
        "    r'$e^x$': exp(x),\n"
        "    r'$\\sin(x)$': sin(x),\n"
        "    r'$\\cos(x)$': cos(x),\n"
        "    r'$\\ln(1+x)$': log(1 + x),\n"
        "}\n"
        "\n"
        "# Print symbolic Taylor expansions\n"
        "print('Taylor Series Expansions (about x = 0)')\n"
        "print('=' * 60)\n"
        "for name, f_sym in functions.items():\n"
        "    expansion = series(f_sym, x, 0, n=8)\n"
        "    print(f'\\n  {name}:')\n"
        "    print(f'    {expansion}')\n"
        "\n"
        "# Convergence plot: increasing orders of Taylor polynomial\n"
        "x_vals = np.linspace(-3, 3, 300)\n"
        "\n"
        "fig, axes = plt.subplots(2, 2, figsize=(13, 10))\n"
        "func_data = [\n"
        "    (r'$e^x$', exp(x), np.exp),\n"
        "    (r'$\\sin(x)$', sin(x), np.sin),\n"
        "    (r'$\\cos(x)$', cos(x), np.cos),\n"
        "    (r'$\\ln(1+x)$', log(1+x), lambda v: np.log(1+v)),\n"
        "]\n"
        "\n"
        "orders = [1, 3, 5, 7, 11]\n"
        "colors_t = plt.cm.viridis(np.linspace(0.2, 0.9, len(orders)))\n"
        "\n"
        "for ax, (name, f_sym, f_np) in zip(axes.flat, func_data):\n"
        "    y_exact = f_np(x_vals)\n"
        "    # Clip for ln(1+x) domain\n"
        "    if 'ln' in name:\n"
        "        mask = x_vals > -0.99\n"
        "        ax.plot(x_vals[mask], y_exact[mask], 'k-', lw=2.5, label='Exact')\n"
        "    else:\n"
        "        ax.plot(x_vals, y_exact, 'k-', lw=2.5, label='Exact')\n"
        "\n"
        "    for order, col in zip(orders, colors_t):\n"
        "        taylor_poly = sp.Poly(series(f_sym, x, 0, n=order+1).removeO(), x)\n"
        "        taylor_func = sp.lambdify(x, taylor_poly.as_expr(), 'numpy')\n"
        "        y_taylor = taylor_func(x_vals)\n"
        "\n"
        "        if 'ln' in name:\n"
        "            ax.plot(x_vals[mask], np.clip(y_taylor[mask], -5, 5),\n"
        "                    '--', color=col, lw=1.3, label=f'Order {order}')\n"
        "        else:\n"
        "            ax.plot(x_vals, np.clip(y_taylor, -10, 10),\n"
        "                    '--', color=col, lw=1.3, label=f'Order {order}')\n"
        "\n"
        "    ax.set_title(f'Taylor Approx: {name}', fontsize=13)\n"
        "    ax.set_xlabel('x')\n"
        "    ax.set_ylabel('y')\n"
        "    ax.legend(fontsize=8, loc='upper left')\n"
        "    ax.grid(True, alpha=0.3)\n"
        "    ax.set_ylim(-5, 5)\n"
        "\n"
        "plt.suptitle('Taylor Series Convergence', fontsize=16, y=1.01)\n"
        "plt.tight_layout()\n"
        "plt.show()"
    )

    # ---- Section 7: QM Connection ----
    nb.md(
        "## 7. Quantum Mechanics Connection\n"
        "\n"
        "### Derivatives and Time Evolution\n"
        "\n"
        "In quantum mechanics, the **time evolution** of a state is governed by the\n"
        "Schrodinger equation:\n"
        "\n"
        "$$i\\hbar \\frac{\\partial}{\\partial t}|\\Psi(t)\\rangle = \\hat{H}|\\Psi(t)\\rangle$$\n"
        "\n"
        "The derivative $\\frac{\\partial}{\\partial t}$ is precisely the concept we have\n"
        "been studying. The Hamiltonian $\\hat{H}$ generates infinitesimal time\n"
        "translations, and the solution involves the **matrix exponential** -- itself\n"
        "a Taylor series:\n"
        "\n"
        "$$|\\Psi(t)\\rangle = e^{-i\\hat{H}t/\\hbar}|\\Psi(0)\\rangle\n"
        "= \\sum_{n=0}^{\\infty}\\frac{1}{n!}\\left(\\frac{-i\\hat{H}t}{\\hbar}\\right)^n|\\Psi(0)\\rangle$$\n"
        "\n"
        "### Taylor Expansion in QM\n"
        "\n"
        "The **translation operator** in quantum mechanics uses a Taylor expansion:\n"
        "\n"
        "$$\\hat{T}(a) = e^{-ia\\hat{p}/\\hbar} = \\sum_{n=0}^{\\infty}\\frac{1}{n!}\n"
        "\\left(\\frac{-ia\\hat{p}}{\\hbar}\\right)^n$$\n"
        "\n"
        "This shifts a wavefunction: $\\hat{T}(a)\\psi(x) = \\psi(x - a)$."
    )

    nb.code(
        "# QM Connection: Time evolution via Taylor expansion of the propagator\n"
        "# Simulate a simple 2-level system (qubit) evolving under H = sigma_z\n"
        "\n"
        "import numpy as np\n"
        "\n"
        "# Pauli-Z matrix (energy eigenbasis)\n"
        "sigma_z = np.array([[1, 0], [0, -1]], dtype=complex)\n"
        "\n"
        "# Initial state: |+> = (|0> + |1>)/sqrt(2)\n"
        "psi0 = np.array([1, 1], dtype=complex) / np.sqrt(2)\n"
        "\n"
        "# Time evolution: exact vs Taylor approximation\n"
        "hbar = 1.0  # Natural units\n"
        "H = sigma_z\n"
        "\n"
        "t_values = np.linspace(0, 2*np.pi, 200)\n"
        "exact_prob0 = []       # |<0|psi(t)>|^2  (exact)\n"
        "taylor_prob0 = {}      # Taylor approximations at various orders\n"
        "\n"
        "# Exact evolution\n"
        "for t in t_values:\n"
        "    # U(t) = exp(-iHt/hbar) -- for diagonal H this is simple\n"
        "    U_exact = np.diag([np.exp(-1j*t), np.exp(1j*t)])\n"
        "    psi_t = U_exact @ psi0\n"
        "    exact_prob0.append(np.abs(psi_t[0])**2)\n"
        "\n"
        "# Taylor-approximated evolution\n"
        "for order in [1, 3, 5, 10]:\n"
        "    probs = []\n"
        "    for t in t_values:\n"
        "        # U_taylor = sum_{n=0}^{order} (-iHt)^n / n!\n"
        "        U_taylor = np.eye(2, dtype=complex)\n"
        "        term = np.eye(2, dtype=complex)\n"
        "        for n in range(1, order + 1):\n"
        "            term = term @ (-1j * H * t) / n\n"
        "            U_taylor += term\n"
        "        psi_t = U_taylor @ psi0\n"
        "        probs.append(np.abs(psi_t[0])**2)\n"
        "    taylor_prob0[order] = probs\n"
        "\n"
        "# Plot\n"
        "fig, ax = plt.subplots(figsize=(10, 5))\n"
        "ax.plot(t_values, exact_prob0, 'k-', lw=2.5, label='Exact $e^{-iHt}$')\n"
        "for order, probs in taylor_prob0.items():\n"
        "    ax.plot(t_values, probs, '--', lw=1.5, label=f'Taylor order {order}')\n"
        "\n"
        "ax.set_xlabel('Time $t$')\n"
        "ax.set_ylabel(r'$|\\langle 0|\\Psi(t)\\rangle|^2$')\n"
        "ax.set_title('Qubit Time Evolution: Exact vs Taylor Expansion of Propagator')\n"
        "ax.legend()\n"
        "ax.grid(True, alpha=0.3)\n"
        "ax.set_ylim(-0.1, 1.4)\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "print('Higher Taylor orders converge to the exact oscillation.')"
    )

    # ---- Section 8: Higher-order derivatives & curvature ----
    nb.md(
        "## 8. Higher-Order Derivatives and Curvature\n"
        "\n"
        "The **second derivative** $f''(x)$ measures the rate of change of the slope,\n"
        "giving us information about **concavity**:\n"
        "\n"
        "- $f''(x) > 0$: concave up (curve bends upward)\n"
        "- $f''(x) < 0$: concave down (curve bends downward)\n"
        "- $f''(x) = 0$: potential inflection point\n"
        "\n"
        "The **curvature** of a plane curve is\n"
        "\n"
        "$$\\kappa(x) = \\frac{|f''(x)|}{(1 + [f'(x)]^2)^{3/2}}$$\n"
        "\n"
        "which quantifies how sharply the curve bends at each point."
    )

    nb.code(
        "# Higher-order derivatives and curvature\n"
        "x_sym = symbols('x')\n"
        "f_sym = x_sym**3 - 3*x_sym**2 + 2  # Cubic polynomial\n"
        "\n"
        "f1 = diff(f_sym, x_sym)         # First derivative\n"
        "f2 = diff(f_sym, x_sym, 2)      # Second derivative\n"
        "f3 = diff(f_sym, x_sym, 3)      # Third derivative\n"
        "\n"
        "print('f(x)   =', f_sym)\n"
        "print(\"f'(x)  =\", f1)\n"
        "print(\"f''(x) =\", f2)\n"
        "print(\"f'''(x)=\", f3)\n"
        "\n"
        "# Convert to numerical\n"
        "f_num = sp.lambdify(x_sym, f_sym, 'numpy')\n"
        "f1_num = sp.lambdify(x_sym, f1, 'numpy')\n"
        "f2_num = sp.lambdify(x_sym, f2, 'numpy')\n"
        "\n"
        "x_vals = np.linspace(-1, 4, 400)\n"
        "\n"
        "fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(10, 10), sharex=True)\n"
        "\n"
        "# f(x)\n"
        "ax1.plot(x_vals, f_num(x_vals), 'b-', lw=2)\n"
        "ax1.axhline(0, color='gray', ls='--', alpha=0.4)\n"
        "ax1.set_ylabel('f(x)')\n"
        "ax1.set_title(r'$f(x) = x^3 - 3x^2 + 2$ and its derivatives')\n"
        "ax1.grid(True, alpha=0.3)\n"
        "\n"
        "# f'(x) -- mark critical points\n"
        "ax2.plot(x_vals, f1_num(x_vals), 'r-', lw=2)\n"
        "ax2.axhline(0, color='gray', ls='--', alpha=0.4)\n"
        "# Critical points: f'(x) = 3x^2 - 6x = 3x(x-2) = 0 => x=0, x=2\n"
        "for cp in [0, 2]:\n"
        "    ax2.plot(cp, 0, 'ko', markersize=8)\n"
        "    ax2.annotate(f'x={cp}', (cp, 0), textcoords='offset points',\n"
        "                 xytext=(10, 10), fontsize=11)\n"
        "ax2.set_ylabel(\"f'(x)\")\n"
        "ax2.grid(True, alpha=0.3)\n"
        "\n"
        "# f''(x) -- mark inflection point\n"
        "ax3.plot(x_vals, f2_num(x_vals), 'g-', lw=2)\n"
        "ax3.axhline(0, color='gray', ls='--', alpha=0.4)\n"
        "# Inflection: f''(x) = 6x - 6 = 0 => x=1\n"
        "ax3.plot(1, 0, 'ko', markersize=8)\n"
        "ax3.annotate('Inflection x=1', (1, 0), textcoords='offset points',\n"
        "             xytext=(10, 10), fontsize=11)\n"
        "# Shade concavity regions\n"
        "ax3.fill_between(x_vals, f2_num(x_vals), 0,\n"
        "                 where=f2_num(x_vals) > 0, alpha=0.15, color='blue',\n"
        "                 label='Concave up')\n"
        "ax3.fill_between(x_vals, f2_num(x_vals), 0,\n"
        "                 where=f2_num(x_vals) < 0, alpha=0.15, color='red',\n"
        "                 label='Concave down')\n"
        "ax3.set_xlabel('x')\n"
        "ax3.set_ylabel(\"f''(x)\")\n"
        "ax3.legend()\n"
        "ax3.grid(True, alpha=0.3)\n"
        "\n"
        "plt.tight_layout()\n"
        "plt.show()"
    )

    # ---- Summary ----
    nb.md(
        "## Summary\n"
        "\n"
        "### Key Formulas\n"
        "\n"
        "| Concept | Formula |\n"
        "|---|---|\n"
        "| Limit definition | $\\forall\\varepsilon>0,\\;\\exists\\delta>0:\\; 0<|x-a|<\\delta \\Rightarrow |f(x)-L|<\\varepsilon$ |\n"
        "| Derivative | $f'(a) = \\lim_{h\\to 0}\\frac{f(a+h)-f(a)}{h}$ |\n"
        "| Product rule | $(fg)' = f'g + fg'$ |\n"
        "| Chain rule | $(f\\circ g)' = f'(g)\\cdot g'$ |\n"
        "| L'Hopital | $\\lim\\frac{f}{g} = \\lim\\frac{f'}{g'}$ (for $0/0$ or $\\infty/\\infty$) |\n"
        "| Taylor series | $f(x) = \\sum_{n=0}^{\\infty}\\frac{f^{(n)}(a)}{n!}(x-a)^n$ |\n"
        "| Curvature | $\\kappa = \\frac{|f''|}{(1+f'^2)^{3/2}}$ |\n"
        "\n"
        "### Main Takeaways\n"
        "\n"
        "1. The epsilon-delta definition makes limits rigorous and is the foundation for all of calculus.\n"
        "2. Derivative rules (power, product, quotient, chain) can all be verified symbolically with SymPy and numerically with finite differences.\n"
        "3. L'Hopital's rule resolves indeterminate forms by differentiating numerator and denominator.\n"
        "4. Taylor series approximate functions as polynomials -- the same idea appears in quantum mechanics for the time-evolution operator.\n"
        "5. The Schrodinger equation is fundamentally a differential equation; everything in this month connects directly to quantum physics.\n"
        "\n"
        "---\n"
        "*Next month: Integration and Infinite Series (Days 29-56)*"
    )

    nb.save()
    print("  [1/3] Notebook 1 complete.\n")


# ============================================================================
# NOTEBOOK 2 - Integration & Series (Month 2, Days 29-56)
# ============================================================================
def build_notebook_2():
    nb = NotebookBuilder(
        "Integration & Infinite Series",
        "year_0/month_02_calculus_II/02_integration_and_series.ipynb",
        "29-56",
    )

    # ---- Imports ----
    nb.code(
        "# Standard scientific stack\n"
        "import numpy as np\n"
        "import matplotlib.pyplot as plt\n"
        "import sympy as sp\n"
        "from sympy import (symbols, integrate, sin, cos, exp, log, pi, oo,\n"
        "                   series, factorial, Rational, sqrt, simplify, latex,\n"
        "                   apart, Piecewise, Sum)\n"
        "from scipy import integrate as sci_integrate\n"
        "\n"
        "%matplotlib inline\n"
        "\n"
        "# Publication-quality defaults\n"
        "plt.rcParams.update({\n"
        "    'figure.figsize': (10, 6),\n"
        "    'font.size': 12,\n"
        "    'axes.labelsize': 14,\n"
        "    'axes.titlesize': 15,\n"
        "    'lines.linewidth': 2,\n"
        "    'legend.fontsize': 11,\n"
        "    'figure.dpi': 100,\n"
        "})\n"
        "\n"
        "sp.init_printing(use_unicode=True)\n"
        "print('Libraries loaded successfully.')"
    )

    # ---- Section 1: Riemann Sums ----
    nb.md(
        "## 1. Riemann Sums and the Definite Integral\n"
        "\n"
        "The definite integral is defined as the limit of Riemann sums:\n"
        "\n"
        "$$\\int_a^b f(x)\\,dx = \\lim_{n\\to\\infty}\\sum_{i=1}^{n} f(x_i^*)\\,\\Delta x$$\n"
        "\n"
        "where $\\Delta x = \\frac{b-a}{n}$ and $x_i^*$ is a sample point in the $i$-th subinterval.\n"
        "\n"
        "### Types of Riemann sums:\n"
        "- **Left endpoint:** $x_i^* = a + (i-1)\\Delta x$\n"
        "- **Right endpoint:** $x_i^* = a + i\\,\\Delta x$\n"
        "- **Midpoint:** $x_i^* = a + (i - \\tfrac{1}{2})\\Delta x$\n"
        "\n"
        "As $n \\to \\infty$, all three converge to the same value for continuous functions."
    )

    nb.code(
        "# Riemann sum visualization with increasing partitions\n"
        "def riemann_sum_plot(f, a, b, partitions_list, f_label=r'$f(x) = x^2$'):\n"
        "    '''Show Riemann sums converging to the integral.'''\n"
        "    fig, axes = plt.subplots(1, len(partitions_list),\n"
        "                              figsize=(5 * len(partitions_list), 5))\n"
        "    if len(partitions_list) == 1:\n"
        "        axes = [axes]\n"
        "\n"
        "    x_fine = np.linspace(a, b, 500)\n"
        "\n"
        "    # Exact integral for comparison (x^2 from 0 to 2 = 8/3)\n"
        "    exact = sci_integrate.quad(f, a, b)[0]\n"
        "\n"
        "    for ax, n in zip(axes, partitions_list):\n"
        "        dx = (b - a) / n\n"
        "        x_left = np.linspace(a, b - dx, n)  # Left endpoints\n"
        "        heights = f(x_left)\n"
        "\n"
        "        # Draw rectangles\n"
        "        for i in range(n):\n"
        "            rect = plt.Rectangle((x_left[i], 0), dx, heights[i],\n"
        "                                  edgecolor='steelblue', facecolor='lightblue',\n"
        "                                  alpha=0.7, linewidth=0.8)\n"
        "            ax.add_patch(rect)\n"
        "\n"
        "        # Riemann sum value\n"
        "        rs = np.sum(heights * dx)\n"
        "\n"
        "        ax.plot(x_fine, f(x_fine), 'r-', lw=2, label=f_label)\n"
        "        ax.set_xlim(a - 0.1, b + 0.1)\n"
        "        ax.set_ylim(0, f(b) * 1.15)\n"
        "        ax.set_xlabel('x')\n"
        "        ax.set_ylabel('f(x)')\n"
        "        ax.set_title(f'n = {n}\\nSum = {rs:.6f}')\n"
        "        ax.legend(loc='upper left', fontsize=9)\n"
        "        ax.grid(True, alpha=0.2)\n"
        "\n"
        "    fig.suptitle(\n"
        "        f'Left Riemann Sums -> Exact Integral = {exact:.6f}',\n"
        "        fontsize=15, y=1.03\n"
        "    )\n"
        "    plt.tight_layout()\n"
        "    plt.show()\n"
        "    print(f'Exact integral value: {exact:.10f}')\n"
        "\n"
        "riemann_sum_plot(lambda x: x**2, 0, 2, [4, 10, 50])"
    )

    nb.code(
        "# Convergence analysis: error vs number of partitions\n"
        "def left_riemann(f, a, b, n):\n"
        "    dx = (b - a) / n\n"
        "    x_left = np.linspace(a, b - dx, n)\n"
        "    return np.sum(f(x_left) * dx)\n"
        "\n"
        "def mid_riemann(f, a, b, n):\n"
        "    dx = (b - a) / n\n"
        "    x_mid = np.linspace(a + dx/2, b - dx/2, n)\n"
        "    return np.sum(f(x_mid) * dx)\n"
        "\n"
        "exact_val = 8 / 3  # integral of x^2 from 0 to 2\n"
        "ns = np.array([5, 10, 20, 50, 100, 200, 500, 1000])\n"
        "\n"
        "left_errors = [abs(left_riemann(lambda x: x**2, 0, 2, n) - exact_val) for n in ns]\n"
        "mid_errors = [abs(mid_riemann(lambda x: x**2, 0, 2, n) - exact_val) for n in ns]\n"
        "\n"
        "fig, ax = plt.subplots(figsize=(9, 5))\n"
        "ax.loglog(ns, left_errors, 'bo-', label='Left endpoint (error ~ 1/n)')\n"
        "ax.loglog(ns, mid_errors, 'rs-', label='Midpoint (error ~ 1/n^2)')\n"
        "ax.loglog(ns, 5/ns, 'b--', alpha=0.4, label=r'Reference $O(1/n)$')\n"
        "ax.loglog(ns, 5/ns**2, 'r--', alpha=0.4, label=r'Reference $O(1/n^2)$')\n"
        "ax.set_xlabel('Number of partitions (n)')\n"
        "ax.set_ylabel('Absolute error')\n"
        "ax.set_title('Riemann Sum Convergence Rates')\n"
        "ax.legend()\n"
        "ax.grid(True, alpha=0.3, which='both')\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "print('Midpoint rule converges quadratically -- much faster than left/right endpoint.')"
    )

    # ---- Section 2: Fundamental Theorem ----
    nb.md(
        "## 2. The Fundamental Theorem of Calculus\n"
        "\n"
        "The FTC connects differentiation and integration:\n"
        "\n"
        "**Part 1 (FTC-1):** If $F(x) = \\int_a^x f(t)\\,dt$, then $F'(x) = f(x)$.\n"
        "\n"
        "**Part 2 (FTC-2):** If $F$ is any antiderivative of $f$, then\n"
        "\n"
        "$$\\int_a^b f(x)\\,dx = F(b) - F(a).$$\n"
        "\n"
        "This is one of the most profound results in mathematics -- it links the\n"
        "local concept of rate of change to the global concept of accumulation."
    )

    nb.code(
        "# Fundamental Theorem of Calculus: symbolic + numerical verification\n"
        "x, t = symbols('x t', real=True)\n"
        "\n"
        "# Example: integral of sin(t) from 0 to x\n"
        "F_symbolic = integrate(sin(t), (t, 0, x))\n"
        "F_prime = sp.diff(F_symbolic, x)\n"
        "\n"
        "print('FTC Part 1 Verification')\n"
        "print('=' * 50)\n"
        "print(f'  F(x) = integral of sin(t) dt from 0 to x = {F_symbolic}')\n"
        "print(f\"  F'(x) = {F_prime}\")\n"
        "print(f'  f(x) = sin(x)')\n"
        "print(f\"  F'(x) == f(x)? {simplify(F_prime - sin(x)) == 0}\")\n"
        "\n"
        "# FTC Part 2: definite integrals\n"
        "print('\\nFTC Part 2 -- Definite Integrals')\n"
        "print('=' * 50)\n"
        "\n"
        "integrals = [\n"
        "    (x**2, 0, 3,     'x^2 from 0 to 3'),\n"
        "    (sin(x), 0, pi,  'sin(x) from 0 to pi'),\n"
        "    (exp(-x), 0, 1,  'e^(-x) from 0 to 1'),\n"
        "    (1/(1+x**2), 0, 1, '1/(1+x^2) from 0 to 1'),\n"
        "]\n"
        "\n"
        "for expr, a_val, b_val, desc in integrals:\n"
        "    symbolic_result = integrate(expr, (x, a_val, b_val))\n"
        "    numerical_result = float(symbolic_result.evalf())\n"
        "    # Verify with scipy\n"
        "    f_num = sp.lambdify(x, expr, 'numpy')\n"
        "    scipy_result = sci_integrate.quad(f_num, float(a_val), float(b_val))[0]\n"
        "\n"
        "    print(f'\\n  {desc}')\n"
        "    print(f'    Symbolic: {symbolic_result} = {numerical_result:.10f}')\n"
        "    print(f'    SciPy:    {scipy_result:.10f}')\n"
        "    print(f'    Match:    {abs(numerical_result - scipy_result) < 1e-10}')"
    )

    # ---- Section 3: Integration Techniques ----
    nb.md(
        "## 3. Integration Techniques with SymPy\n"
        "\n"
        "### 3.1 Substitution (u-substitution)\n"
        "\n"
        "$$\\int f(g(x))\\,g'(x)\\,dx = \\int f(u)\\,du \\quad \\text{where } u = g(x)$$\n"
        "\n"
        "### 3.2 Integration by parts\n"
        "\n"
        "$$\\int u\\,dv = uv - \\int v\\,du$$\n"
        "\n"
        "### 3.3 Partial fractions\n"
        "\n"
        "$$\\frac{P(x)}{Q(x)} = \\frac{A_1}{x - r_1} + \\frac{A_2}{x - r_2} + \\cdots$$\n"
        "\n"
        "SymPy's `integrate()` handles all these techniques automatically, but understanding\n"
        "the method is essential for quantum mechanics where analytical solutions\n"
        "are often needed."
    )

    nb.code(
        "# Integration techniques demonstrated with SymPy\n"
        "x = symbols('x')\n"
        "\n"
        "print('INTEGRATION TECHNIQUES')\n"
        "print('=' * 65)\n"
        "\n"
        "# u-Substitution examples\n"
        "print('\\n--- u-Substitution ---')\n"
        "sub_integrals = [\n"
        "    (cos(x) * exp(sin(x)),        'cos(x) * e^(sin(x))'),\n"
        "    (x * exp(x**2),                'x * e^(x^2)'),\n"
        "    (2*x / (x**2 + 1),            '2x / (x^2 + 1)'),\n"
        "]\n"
        "for expr, desc in sub_integrals:\n"
        "    result = integrate(expr, x)\n"
        "    print(f'  integral of {desc:30s} = {result}')\n"
        "\n"
        "# Integration by parts\n"
        "print('\\n--- Integration by Parts ---')\n"
        "parts_integrals = [\n"
        "    (x * exp(x),                   'x * e^x'),\n"
        "    (x * sin(x),                   'x * sin(x)'),\n"
        "    (x**2 * cos(x),                'x^2 * cos(x)'),\n"
        "    (log(x),                       'ln(x)'),\n"
        "]\n"
        "for expr, desc in parts_integrals:\n"
        "    result = integrate(expr, x)\n"
        "    print(f'  integral of {desc:30s} = {result}')\n"
        "\n"
        "# Partial fractions\n"
        "print('\\n--- Partial Fractions ---')\n"
        "pf_integrals = [\n"
        "    (1 / (x**2 - 1),               '1/(x^2 - 1)'),\n"
        "    ((3*x + 5) / (x**2 + 4*x + 3), '(3x+5)/(x^2+4x+3)'),\n"
        "    (1 / (x*(x+1)*(x+2)),          '1/(x(x+1)(x+2))'),\n"
        "]\n"
        "for expr, desc in pf_integrals:\n"
        "    decomposed = apart(expr, x)\n"
        "    result = integrate(expr, x)\n"
        "    print(f'  {desc:30s}')\n"
        "    print(f'    Partial fractions: {decomposed}')\n"
        "    print(f'    Integral:          {result}')"
    )

    # ---- Section 4: Improper Integrals ----
    nb.md(
        "## 4. Improper Integrals and Convergence\n"
        "\n"
        "An **improper integral** has an infinite limit or an integrand with a\n"
        "singularity:\n"
        "\n"
        "$$\\int_0^{\\infty} e^{-x}\\,dx = 1, \\qquad \\int_0^1 \\frac{1}{\\sqrt{x}}\\,dx = 2$$\n"
        "\n"
        "### Key convergence tests:\n"
        "- **Comparison test:** If $0 \\le f(x) \\le g(x)$ and $\\int g$ converges, then $\\int f$ converges.\n"
        "- **p-test:** $\\int_1^{\\infty} \\frac{1}{x^p}\\,dx$ converges iff $p > 1$.\n"
        "\n"
        "### The Gaussian integral\n"
        "\n"
        "$$\\int_{-\\infty}^{\\infty} e^{-x^2}\\,dx = \\sqrt{\\pi}$$\n"
        "\n"
        "This integral appears throughout quantum mechanics (Gaussian wavefunctions)."
    )

    nb.code(
        "# Improper integrals -- symbolic and numerical\n"
        "x = symbols('x')\n"
        "\n"
        "print('IMPROPER INTEGRALS')\n"
        "print('=' * 60)\n"
        "\n"
        "improper = [\n"
        "    (exp(-x),         (x, 0, oo),    'e^(-x) from 0 to inf'),\n"
        "    (1/x**2,          (x, 1, oo),    '1/x^2 from 1 to inf'),\n"
        "    (1/sqrt(x),       (x, 0, 1),     '1/sqrt(x) from 0 to 1'),\n"
        "    (exp(-x**2),      (x, -oo, oo),  'e^(-x^2) from -inf to inf (Gaussian)'),\n"
        "    (1/(1 + x**2),    (x, -oo, oo),  '1/(1+x^2) from -inf to inf'),\n"
        "    (x * exp(-x),     (x, 0, oo),    'x*e^(-x) from 0 to inf'),\n"
        "]\n"
        "\n"
        "for expr, bounds, desc in improper:\n"
        "    result = integrate(expr, bounds)\n"
        "    print(f'  {desc:45s} = {result}')\n"
        "\n"
        "# Visualize the Gaussian integral convergence\n"
        "print(f'\\nGaussian integral: sqrt(pi) = {float(sqrt(pi)):.10f}')\n"
        "\n"
        "# Numerical verification\n"
        "from scipy.integrate import quad\n"
        "val, err = quad(lambda x: np.exp(-x**2), -100, 100)\n"
        "print(f'SciPy numerical:             {val:.10f}')\n"
        "\n"
        "# Plot the Gaussian and its cumulative integral\n"
        "x_vals = np.linspace(-4, 4, 500)\n"
        "gaussian = np.exp(-x_vals**2)\n"
        "\n"
        "# Cumulative integral\n"
        "cumulative = np.array([quad(lambda t: np.exp(-t**2), -4, xi)[0] for xi in x_vals])\n"
        "\n"
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(13, 5))\n"
        "\n"
        "ax1.plot(x_vals, gaussian, 'b-', lw=2)\n"
        "ax1.fill_between(x_vals, gaussian, alpha=0.2, color='blue')\n"
        "ax1.set_xlabel('x')\n"
        "ax1.set_ylabel(r'$e^{-x^2}$')\n"
        "ax1.set_title(r'Gaussian: $e^{-x^2}$')\n"
        "ax1.annotate(rf'Area = $\\sqrt{{\\pi}} \\approx {np.sqrt(np.pi):.4f}$',\n"
        "             xy=(0, 0.5), fontsize=13, ha='center',\n"
        "             bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n"
        "ax1.grid(True, alpha=0.3)\n"
        "\n"
        "ax2.plot(x_vals, cumulative, 'r-', lw=2)\n"
        "ax2.axhline(np.sqrt(np.pi), color='gray', ls='--', alpha=0.5,\n"
        "            label=rf'$\\sqrt{{\\pi}}$')\n"
        "ax2.set_xlabel('x')\n"
        "ax2.set_ylabel('Cumulative integral')\n"
        "ax2.set_title(r'$\\int_{-4}^{x} e^{-t^2}\\,dt$')\n"
        "ax2.legend()\n"
        "ax2.grid(True, alpha=0.3)\n"
        "\n"
        "plt.tight_layout()\n"
        "plt.show()"
    )

    # ---- Section 5: Power Series ----
    nb.md(
        "## 5. Power Series, Taylor/Maclaurin with Error Bounds\n"
        "\n"
        "A **power series** centered at $a$ is\n"
        "\n"
        "$$\\sum_{n=0}^{\\infty} c_n (x - a)^n$$\n"
        "\n"
        "with **radius of convergence** $R$ determined by the ratio test:\n"
        "\n"
        "$$R = \\lim_{n\\to\\infty}\\left|\\frac{c_n}{c_{n+1}}\\right|$$\n"
        "\n"
        "### Taylor remainder (Lagrange form)\n"
        "\n"
        "For the $n$-th Taylor polynomial $T_n(x)$, the error satisfies:\n"
        "\n"
        "$$|f(x) - T_n(x)| \\le \\frac{M_{n+1}}{(n+1)!}|x - a|^{n+1}$$\n"
        "\n"
        "where $M_{n+1} = \\max_{c\\in[a,x]}|f^{(n+1)}(c)|$."
    )

    nb.code(
        "# Taylor polynomial error bounds for e^x\n"
        "x_sym = symbols('x')\n"
        "\n"
        "# For e^x centered at 0: |R_n(x)| <= e^|x| * |x|^(n+1) / (n+1)!\n"
        "# since all derivatives of e^x are e^x, and max on [0,x] is e^|x|\n"
        "\n"
        "x_test = 1.0  # Evaluate error at x = 1\n"
        "exact_val = np.exp(x_test)\n"
        "\n"
        "orders = list(range(1, 16))\n"
        "taylor_vals = []\n"
        "actual_errors = []\n"
        "bound_errors = []\n"
        "\n"
        "for n in orders:\n"
        "    # Taylor polynomial value\n"
        "    taylor_sum = sum(x_test**k / np.math.factorial(k) for k in range(n + 1))\n"
        "    taylor_vals.append(taylor_sum)\n"
        "\n"
        "    actual_err = abs(exact_val - taylor_sum)\n"
        "    actual_errors.append(actual_err)\n"
        "\n"
        "    # Lagrange error bound: e^1 * 1^(n+1) / (n+1)!\n"
        "    bound = np.exp(x_test) * x_test**(n+1) / np.math.factorial(n+1)\n"
        "    bound_errors.append(bound)\n"
        "\n"
        "fig, ax = plt.subplots(figsize=(10, 6))\n"
        "ax.semilogy(orders, actual_errors, 'bo-', label='Actual error')\n"
        "ax.semilogy(orders, bound_errors, 'r^--', label='Lagrange error bound')\n"
        "ax.set_xlabel('Taylor polynomial order n')\n"
        "ax.set_ylabel('Error (log scale)')\n"
        "ax.set_title(r'Taylor Series Error for $e^x$ at $x = 1$')\n"
        "ax.legend()\n"
        "ax.grid(True, alpha=0.3, which='both')\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "\n"
        "# Print table\n"
        "print(f'{\"Order\":>5s} {\"Taylor Value\":>18s} {\"Actual Error\":>14s} {\"Bound\":>14s}')\n"
        "print('-' * 55)\n"
        "for n, tv, ae, be in zip(orders, taylor_vals, actual_errors, bound_errors):\n"
        "    print(f'{n:5d} {tv:18.12f} {ae:14.2e} {be:14.2e}')"
    )

    # ---- Section 6: Fourier Series ----
    nb.md(
        "## 6. Fourier Series Preview: Square Wave Approximation\n"
        "\n"
        "A **Fourier series** represents a periodic function as a sum of sines and cosines:\n"
        "\n"
        "$$f(x) = \\frac{a_0}{2} + \\sum_{n=1}^{\\infty}\\left[a_n\\cos(nx) + b_n\\sin(nx)\\right]$$\n"
        "\n"
        "The **square wave** (period $2\\pi$) has Fourier series:\n"
        "\n"
        "$$f(x) = \\frac{4}{\\pi}\\sum_{k=0}^{\\infty}\\frac{\\sin((2k+1)x)}{2k+1}$$\n"
        "\n"
        "This is the foundation of **spectral methods** in quantum mechanics, where\n"
        "we expand wavefunctions in an orthonormal basis of eigenstates."
    )

    nb.code(
        "# Fourier series: square wave approximation\n"
        "def square_wave_fourier(x, N):\n"
        "    '''Approximate square wave using first N terms of Fourier series.'''\n"
        "    result = np.zeros_like(x)\n"
        "    for k in range(N):\n"
        "        n = 2 * k + 1  # Odd harmonics only\n"
        "        result += np.sin(n * x) / n\n"
        "    return (4 / np.pi) * result\n"
        "\n"
        "x_vals = np.linspace(-2 * np.pi, 2 * np.pi, 1000)\n"
        "\n"
        "# Exact square wave for reference\n"
        "square_exact = np.sign(np.sin(x_vals))\n"
        "\n"
        "fig, axes = plt.subplots(2, 2, figsize=(13, 9))\n"
        "terms_list = [1, 3, 10, 50]\n"
        "\n"
        "for ax, N in zip(axes.flat, terms_list):\n"
        "    ax.plot(x_vals, square_exact, 'k-', lw=1, alpha=0.4, label='Exact')\n"
        "    ax.plot(x_vals, square_wave_fourier(x_vals, N), 'b-', lw=1.5,\n"
        "            label=f'{N} term{\"s\" if N > 1 else \"\"}')\n"
        "    ax.set_xlabel('x')\n"
        "    ax.set_ylabel('f(x)')\n"
        "    ax.set_title(f'Fourier Approximation: {N} term{\"s\" if N > 1 else \"\"}')\n"
        "    ax.legend(loc='upper right', fontsize=9)\n"
        "    ax.set_ylim(-1.5, 1.5)\n"
        "    ax.grid(True, alpha=0.3)\n"
        "\n"
        "plt.suptitle('Fourier Series: Square Wave Approximation', fontsize=15, y=1.01)\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "print('Notice the Gibbs phenomenon: overshoots near discontinuities persist')\n"
        "print('even as the number of terms increases (converges to ~9% overshoot).')"
    )

    # ---- Section 7: QM Connection ----
    nb.md(
        "## 7. Quantum Mechanics Connection\n"
        "\n"
        "### Integrals in Quantum Mechanics\n"
        "\n"
        "Integration is ubiquitous in QM. Three fundamental applications:\n"
        "\n"
        "**1. Normalization:** A valid wavefunction must satisfy\n"
        "$$\\int_{-\\infty}^{\\infty} |\\Psi(x)|^2\\,dx = 1$$\n"
        "\n"
        "**2. Expectation values:** The average measured value of an observable $\\hat{A}$:\n"
        "$$\\langle\\hat{A}\\rangle = \\int_{-\\infty}^{\\infty} \\Psi^*(x)\\,\\hat{A}\\,\\Psi(x)\\,dx$$\n"
        "\n"
        "**3. Probability:** The probability of finding a particle in $[a, b]$:\n"
        "$$P(a \\le x \\le b) = \\int_a^b |\\Psi(x)|^2\\,dx$$\n"
        "\n"
        "### The Gaussian Wavepacket\n"
        "\n"
        "The most common wavefunction in QM is the Gaussian:\n"
        "\n"
        "$$\\Psi(x) = \\left(\\frac{1}{2\\pi\\sigma^2}\\right)^{1/4} e^{-x^2/(4\\sigma^2)}$$"
    )

    nb.code(
        "# QM Connection: Gaussian wavepacket -- normalization, probability, expectation\n"
        "def gaussian_wavepacket(x, sigma=1.0, x0=0.0, k0=0.0):\n"
        "    '''Gaussian wavepacket centered at x0 with momentum k0.'''\n"
        "    norm = (1 / (2 * np.pi * sigma**2))**0.25\n"
        "    return norm * np.exp(-(x - x0)**2 / (4 * sigma**2)) * np.exp(1j * k0 * x)\n"
        "\n"
        "x_vals = np.linspace(-10, 10, 2000)\n"
        "sigma = 1.0\n"
        "\n"
        "psi = gaussian_wavepacket(x_vals, sigma=sigma, x0=0, k0=2.0)\n"
        "prob_density = np.abs(psi)**2\n"
        "\n"
        "# Verify normalization via numerical integration\n"
        "dx = x_vals[1] - x_vals[0]\n"
        "norm = np.trapz(prob_density, x_vals)\n"
        "\n"
        "# Expectation value of x: <x> = integral of x * |psi|^2\n"
        "x_expectation = np.trapz(x_vals * prob_density, x_vals)\n"
        "\n"
        "# Expectation value of x^2\n"
        "x2_expectation = np.trapz(x_vals**2 * prob_density, x_vals)\n"
        "\n"
        "# Uncertainty (standard deviation)\n"
        "delta_x = np.sqrt(x2_expectation - x_expectation**2)\n"
        "\n"
        "# Probability of finding particle in [-sigma, sigma]\n"
        "mask = (x_vals >= -sigma) & (x_vals <= sigma)\n"
        "prob_in_sigma = np.trapz(prob_density[mask], x_vals[mask])\n"
        "\n"
        "print('Gaussian Wavepacket Analysis')\n"
        "print('=' * 50)\n"
        "print(f'  sigma = {sigma}')\n"
        "print(f'  Normalization:  integral |psi|^2 dx = {norm:.10f}  (should be 1)')\n"
        "print(f'  <x>           = {x_expectation:.10f}  (should be 0)')\n"
        "print(f'  <x^2>         = {x2_expectation:.10f}')\n"
        "print(f'  Delta x       = {delta_x:.10f}  (should be {sigma*np.sqrt(2)/2:.10f})')\n"
        "print(f'  P(-sigma < x < sigma) = {prob_in_sigma:.6f}  (~68.3%)')\n"
        "\n"
        "# Plot\n"
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(13, 5))\n"
        "\n"
        "ax1.plot(x_vals, np.real(psi), 'b-', alpha=0.7, label=r'Re($\\Psi$)')\n"
        "ax1.plot(x_vals, np.imag(psi), 'r-', alpha=0.7, label=r'Im($\\Psi$)')\n"
        "ax1.plot(x_vals, np.abs(psi), 'k--', lw=1.5, label=r'$|\\Psi|$')\n"
        "ax1.set_xlabel('x')\n"
        "ax1.set_ylabel(r'$\\Psi(x)$')\n"
        "ax1.set_title('Gaussian Wavepacket (k0 = 2)')\n"
        "ax1.legend()\n"
        "ax1.grid(True, alpha=0.3)\n"
        "\n"
        "ax2.plot(x_vals, prob_density, 'b-', lw=2)\n"
        "ax2.fill_between(x_vals[mask], prob_density[mask], alpha=0.3, color='green',\n"
        "                  label=rf'P($|x|<\\sigma$) = {prob_in_sigma:.4f}')\n"
        "ax2.axvline(x_expectation, color='red', ls='--',\n"
        "            label=rf'$\\langle x\\rangle$ = {x_expectation:.2f}')\n"
        "ax2.set_xlabel('x')\n"
        "ax2.set_ylabel(r'$|\\Psi(x)|^2$')\n"
        "ax2.set_title('Probability Density')\n"
        "ax2.legend()\n"
        "ax2.grid(True, alpha=0.3)\n"
        "\n"
        "plt.suptitle('Quantum Mechanics: Gaussian Wavepacket', fontsize=15, y=1.02)\n"
        "plt.tight_layout()\n"
        "plt.show()"
    )

    # ---- Summary ----
    nb.md(
        "## Summary\n"
        "\n"
        "### Key Formulas\n"
        "\n"
        "| Concept | Formula |\n"
        "|---|---|\n"
        "| Riemann sum | $\\sum_{i=1}^n f(x_i^*)\\Delta x \\to \\int_a^b f\\,dx$ |\n"
        "| FTC Part 1 | $\\frac{d}{dx}\\int_a^x f(t)\\,dt = f(x)$ |\n"
        "| FTC Part 2 | $\\int_a^b f(x)\\,dx = F(b) - F(a)$ |\n"
        "| By parts | $\\int u\\,dv = uv - \\int v\\,du$ |\n"
        "| Gaussian integral | $\\int_{-\\infty}^{\\infty}e^{-x^2}dx = \\sqrt{\\pi}$ |\n"
        "| Fourier series | $f(x) = \\frac{a_0}{2}+\\sum(a_n\\cos nx + b_n\\sin nx)$ |\n"
        "| QM normalization | $\\int|\\Psi|^2 dx = 1$ |\n"
        "| QM expectation | $\\langle\\hat{A}\\rangle = \\int\\Psi^*\\hat{A}\\Psi\\,dx$ |\n"
        "\n"
        "### Main Takeaways\n"
        "\n"
        "1. Riemann sums converge to the definite integral; midpoint rule converges faster ($O(1/n^2)$) than left/right ($O(1/n)$).\n"
        "2. The Fundamental Theorem of Calculus links derivatives (local rates) with integrals (global accumulation).\n"
        "3. Symbolic integration (SymPy) handles substitution, parts, and partial fractions; numerical integration (SciPy) provides verification.\n"
        "4. Improper integrals -- especially the Gaussian integral -- appear throughout quantum mechanics.\n"
        "5. Fourier series decompose functions into orthogonal components, just as quantum states decompose into energy eigenstates.\n"
        "6. Integration underpins the three pillars of QM: normalization, expectation values, and probability.\n"
        "\n"
        "---\n"
        "*Next month: Multivariable Calculus & ODEs (Days 57-84)*"
    )

    nb.save()
    print("  [2/3] Notebook 2 complete.\n")


# ============================================================================
# NOTEBOOK 3 - Multivariable Calculus & ODEs (Month 3, Days 57-84)
# ============================================================================
def build_notebook_3():
    nb = NotebookBuilder(
        "Multivariable Calculus & ODEs",
        "year_0/month_03_multivariable_ode/03_multivariable_and_odes.ipynb",
        "57-84",
    )

    # ---- Imports ----
    nb.code(
        "# Standard scientific stack\n"
        "import numpy as np\n"
        "import matplotlib.pyplot as plt\n"
        "from mpl_toolkits.mplot3d import Axes3D\n"
        "import sympy as sp\n"
        "from sympy import (symbols, diff, integrate, sin, cos, exp, sqrt, pi,\n"
        "                   Function, Eq, dsolve, classify_ode, simplify, Matrix,\n"
        "                   latex, Rational)\n"
        "from scipy.integrate import solve_ivp\n"
        "from scipy.integrate import quad\n"
        "\n"
        "%matplotlib inline\n"
        "\n"
        "# Publication-quality defaults\n"
        "plt.rcParams.update({\n"
        "    'figure.figsize': (10, 6),\n"
        "    'font.size': 12,\n"
        "    'axes.labelsize': 14,\n"
        "    'axes.titlesize': 15,\n"
        "    'lines.linewidth': 2,\n"
        "    'legend.fontsize': 11,\n"
        "    'figure.dpi': 100,\n"
        "})\n"
        "\n"
        "sp.init_printing(use_unicode=True)\n"
        "print('Libraries loaded successfully.')"
    )

    # ---- Section 1: 3D Surfaces ----
    nb.md(
        "## 1. Multivariable Functions and 3D Visualization\n"
        "\n"
        "A function of two variables $f(x, y)$ maps points in $\\mathbb{R}^2$ to\n"
        "$\\mathbb{R}$. Its graph is a **surface** in 3D space.\n"
        "\n"
        "### Partial derivatives\n"
        "\n"
        "$$\\frac{\\partial f}{\\partial x} = \\lim_{h\\to 0}\\frac{f(x+h,y)-f(x,y)}{h}, \\qquad\n"
        "\\frac{\\partial f}{\\partial y} = \\lim_{h\\to 0}\\frac{f(x,y+h)-f(x,y)}{h}$$\n"
        "\n"
        "### The gradient\n"
        "\n"
        "$$\\nabla f = \\left(\\frac{\\partial f}{\\partial x},\\, \\frac{\\partial f}{\\partial y}\\right)$$\n"
        "\n"
        "points in the direction of steepest ascent and has magnitude equal to the\n"
        "maximum rate of change."
    )

    nb.code(
        "# 3D surface plots for multivariable functions\n"
        "x_vals = np.linspace(-3, 3, 100)\n"
        "y_vals = np.linspace(-3, 3, 100)\n"
        "X, Y = np.meshgrid(x_vals, y_vals)\n"
        "\n"
        "# Four interesting surfaces\n"
        "surfaces = {\n"
        "    r'$f = x^2 + y^2$ (Paraboloid)':       X**2 + Y**2,\n"
        "    r'$f = \\sin(x)\\cos(y)$ (Saddle-like)':  np.sin(X) * np.cos(Y),\n"
        "    r'$f = e^{-(x^2+y^2)}$ (Gaussian)':     np.exp(-(X**2 + Y**2)),\n"
        "    r'$f = xy\\,e^{-(x^2+y^2)/2}$ (Monkey saddle)': X * Y * np.exp(-(X**2 + Y**2)/2),\n"
        "}\n"
        "\n"
        "fig = plt.figure(figsize=(14, 11))\n"
        "for i, (title, Z) in enumerate(surfaces.items(), 1):\n"
        "    ax = fig.add_subplot(2, 2, i, projection='3d')\n"
        "    surf = ax.plot_surface(X, Y, Z, cmap='viridis', alpha=0.85,\n"
        "                           edgecolor='none')\n"
        "    ax.set_xlabel('x')\n"
        "    ax.set_ylabel('y')\n"
        "    ax.set_zlabel('f(x,y)')\n"
        "    ax.set_title(title, fontsize=12, pad=10)\n"
        "    ax.view_init(elev=30, azim=135)\n"
        "\n"
        "plt.suptitle('Surfaces in 3D', fontsize=16, y=1.01)\n"
        "plt.tight_layout()\n"
        "plt.show()"
    )

    # ---- Section 2: Gradient ----
    nb.md(
        "## 2. Gradient Visualization with Quiver Plots\n"
        "\n"
        "The gradient field $\\nabla f$ can be visualized as arrows on the $xy$-plane,\n"
        "overlaid on a contour plot of $f$. The arrows point uphill, and their length\n"
        "encodes the steepness.\n"
        "\n"
        "For the **paraboloid** $f(x,y) = x^2 + y^2$:\n"
        "\n"
        "$$\\nabla f = (2x, \\, 2y)$$\n"
        "\n"
        "The gradient points radially outward from the origin -- everywhere perpendicular\n"
        "to the circular level curves."
    )

    nb.code(
        "# Gradient visualization with quiver plots on contour backgrounds\n"
        "fig, axes = plt.subplots(1, 3, figsize=(16, 5))\n"
        "\n"
        "# Function 1: Paraboloid\n"
        "x_grid = np.linspace(-3, 3, 20)\n"
        "y_grid = np.linspace(-3, 3, 20)\n"
        "Xq, Yq = np.meshgrid(x_grid, y_grid)\n"
        "\n"
        "# Fine grid for contours\n"
        "x_fine = np.linspace(-3, 3, 200)\n"
        "y_fine = np.linspace(-3, 3, 200)\n"
        "Xf, Yf = np.meshgrid(x_fine, y_fine)\n"
        "\n"
        "# (a) Paraboloid: f = x^2 + y^2\n"
        "Z1 = Xf**2 + Yf**2\n"
        "U1, V1 = 2*Xq, 2*Yq  # Gradient components\n"
        "\n"
        "axes[0].contour(Xf, Yf, Z1, levels=15, cmap='coolwarm', alpha=0.6)\n"
        "axes[0].quiver(Xq, Yq, U1, V1, color='black', alpha=0.7, scale=60)\n"
        "axes[0].set_title(r'$\\nabla(x^2 + y^2) = (2x, 2y)$')\n"
        "axes[0].set_xlabel('x')\n"
        "axes[0].set_ylabel('y')\n"
        "axes[0].set_aspect('equal')\n"
        "\n"
        "# (b) Saddle: f = x^2 - y^2\n"
        "Z2 = Xf**2 - Yf**2\n"
        "U2, V2 = 2*Xq, -2*Yq\n"
        "\n"
        "axes[1].contour(Xf, Yf, Z2, levels=15, cmap='coolwarm', alpha=0.6)\n"
        "axes[1].quiver(Xq, Yq, U2, V2, color='black', alpha=0.7, scale=60)\n"
        "axes[1].set_title(r'$\\nabla(x^2 - y^2) = (2x, -2y)$')\n"
        "axes[1].set_xlabel('x')\n"
        "axes[1].set_ylabel('y')\n"
        "axes[1].set_aspect('equal')\n"
        "\n"
        "# (c) Gaussian: f = exp(-(x^2+y^2))\n"
        "Z3 = np.exp(-(Xf**2 + Yf**2))\n"
        "U3 = -2*Xq * np.exp(-(Xq**2 + Yq**2))\n"
        "V3 = -2*Yq * np.exp(-(Xq**2 + Yq**2))\n"
        "\n"
        "axes[2].contour(Xf, Yf, Z3, levels=15, cmap='coolwarm', alpha=0.6)\n"
        "axes[2].quiver(Xq, Yq, U3, V3, color='black', alpha=0.7, scale=5)\n"
        "axes[2].set_title(r'$\\nabla e^{-(x^2+y^2)}$')\n"
        "axes[2].set_xlabel('x')\n"
        "axes[2].set_ylabel('y')\n"
        "axes[2].set_aspect('equal')\n"
        "\n"
        "plt.suptitle('Gradient Fields (arrows) over Contour Plots (level curves)',\n"
        "             fontsize=14, y=1.03)\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "print('Gradient arrows are perpendicular to contour lines -- they point uphill.')"
    )

    # ---- Section 3: Line Integrals & Green's Theorem ----
    nb.md(
        "## 3. Line Integrals and Green's Theorem\n"
        "\n"
        "### Line integral of a vector field\n"
        "\n"
        "$$\\oint_C \\mathbf{F}\\cdot d\\mathbf{r} = \\int_a^b \\mathbf{F}(\\mathbf{r}(t))\\cdot\\mathbf{r}'(t)\\,dt$$\n"
        "\n"
        "### Green's Theorem\n"
        "\n"
        "For a simply connected region $D$ bounded by a positively oriented curve $C$:\n"
        "\n"
        "$$\\oint_C (P\\,dx + Q\\,dy) = \\iint_D \\left(\\frac{\\partial Q}{\\partial x} - \\frac{\\partial P}{\\partial y}\\right) dA$$\n"
        "\n"
        "This relates a line integral around a closed curve to a double integral over the enclosed region.\n"
        "Green's theorem is a precursor to **Stokes' theorem**, which is fundamental in\n"
        "electromagnetism and gauge theories in quantum field theory."
    )

    nb.code(
        "# Green's Theorem verification\n"
        "# Vector field F = (-y, x) around the unit circle\n"
        "# Line integral: integral of (-y dx + x dy) around C\n"
        "# Green's: double integral of (dQ/dx - dP/dy) dA = (1 - (-1)) dA = 2 * Area\n"
        "\n"
        "x, y, t = symbols('x y t', real=True)\n"
        "\n"
        "# Parametrize the unit circle: r(t) = (cos t, sin t), t in [0, 2pi]\n"
        "x_t = cos(t)\n"
        "y_t = sin(t)\n"
        "dx_dt = diff(x_t, t)  # -sin(t)\n"
        "dy_dt = diff(y_t, t)  # cos(t)\n"
        "\n"
        "# P = -y, Q = x\n"
        "P = -y_t  # -sin(t)\n"
        "Q = x_t   # cos(t)\n"
        "\n"
        "# Line integral: integral of (P*dx/dt + Q*dy/dt) dt from 0 to 2pi\n"
        "integrand = P * dx_dt + Q * dy_dt\n"
        "line_integral = integrate(integrand, (t, 0, 2*pi))\n"
        "\n"
        "# Green's theorem: dQ/dx - dP/dy = 1 - (-1) = 2\n"
        "# Double integral over unit disk: 2 * pi * r^2 = 2*pi\n"
        "greens_result = 2 * pi  # 2 * area of unit circle\n"
        "\n"
        "print(\"Green's Theorem Verification\")\n"
        "print('=' * 50)\n"
        "print(f'  Vector field: F = (-y, x)')\n"
        "print(f'  Curve: unit circle (counterclockwise)')\n"
        "print(f'')\n"
        "print(f'  Line integral:     {line_integral}')\n"
        "print(f\"  Green's (2*Area):  {greens_result}\")\n"
        "print(f'  Match: {simplify(line_integral - greens_result) == 0}')\n"
        "\n"
        "# Visualization: the vector field and the unit circle\n"
        "theta = np.linspace(0, 2*np.pi, 100)\n"
        "circle_x = np.cos(theta)\n"
        "circle_y = np.sin(theta)\n"
        "\n"
        "# Vector field on a grid\n"
        "xg = np.linspace(-1.5, 1.5, 12)\n"
        "yg = np.linspace(-1.5, 1.5, 12)\n"
        "Xg, Yg = np.meshgrid(xg, yg)\n"
        "Ug = -Yg   # P = -y\n"
        "Vg = Xg    # Q = x\n"
        "\n"
        "fig, ax = plt.subplots(figsize=(7, 7))\n"
        "ax.quiver(Xg, Yg, Ug, Vg, color='steelblue', alpha=0.7, scale=20)\n"
        "ax.plot(circle_x, circle_y, 'r-', lw=2.5, label='Unit circle C')\n"
        "\n"
        "# Add direction arrow on circle\n"
        "arrow_idx = 10\n"
        "ax.annotate('', xy=(circle_x[arrow_idx+3], circle_y[arrow_idx+3]),\n"
        "            xytext=(circle_x[arrow_idx], circle_y[arrow_idx]),\n"
        "            arrowprops=dict(arrowstyle='->', color='red', lw=2))\n"
        "\n"
        "ax.set_xlabel('x')\n"
        "ax.set_ylabel('y')\n"
        "ax.set_title(r'$\\mathbf{F} = (-y, x)$ and unit circle $C$'\n"
        "             f'\\nLine integral = Green\\'s = {float(line_integral):.4f}')\n"
        "ax.set_aspect('equal')\n"
        "ax.legend()\n"
        "ax.grid(True, alpha=0.3)\n"
        "plt.tight_layout()\n"
        "plt.show()"
    )

    # ---- Section 4: ODE Solving ----
    nb.md(
        "## 4. Ordinary Differential Equations (ODEs)\n"
        "\n"
        "An ODE relates a function to its derivatives. The general first-order ODE:\n"
        "\n"
        "$$\\frac{dy}{dx} = f(x, y)$$\n"
        "\n"
        "### Classification:\n"
        "- **Separable:** $\\frac{dy}{dx} = g(x)h(y)$\n"
        "- **Linear first-order:** $\\frac{dy}{dx} + P(x)y = Q(x)$\n"
        "- **Exact:** $M(x,y)dx + N(x,y)dy = 0$ where $\\frac{\\partial M}{\\partial y} = \\frac{\\partial N}{\\partial x}$\n"
        "\n"
        "### Second-order linear ODEs with constant coefficients:\n"
        "\n"
        "$$ay'' + by' + cy = f(x)$$\n"
        "\n"
        "The characteristic equation $ar^2 + br + c = 0$ determines the solution type."
    )

    nb.code(
        "# Analytical ODE solving with SymPy's dsolve\n"
        "x = symbols('x')\n"
        "y = Function('y')\n"
        "\n"
        "print('ANALYTICAL ODE SOLUTIONS (SymPy dsolve)')\n"
        "print('=' * 65)\n"
        "\n"
        "odes = [\n"
        "    # (equation, description)\n"
        "    (Eq(y(x).diff(x), 2*x),\n"
        "     \"y' = 2x  (direct integration)\"),\n"
        "    (Eq(y(x).diff(x), -y(x)),\n"
        "     \"y' = -y  (exponential decay)\"),\n"
        "    (Eq(y(x).diff(x), y(x)*(1 - y(x))),\n"
        "     \"y' = y(1-y)  (logistic equation)\"),\n"
        "    (Eq(y(x).diff(x, 2) + y(x), 0),\n"
        "     \"y'' + y = 0  (simple harmonic oscillator)\"),\n"
        "    (Eq(y(x).diff(x, 2) + 2*y(x).diff(x) + y(x), 0),\n"
        "     \"y'' + 2y' + y = 0  (critically damped)\"),\n"
        "    (Eq(y(x).diff(x, 2) + y(x).diff(x) + 5*y(x), 0),\n"
        "     \"y'' + y' + 5y = 0  (underdamped)\"),\n"
        "]\n"
        "\n"
        "for eq, desc in odes:\n"
        "    sol = dsolve(eq, y(x))\n"
        "    ode_class = classify_ode(eq, y(x))\n"
        "    print(f'\\n  {desc}')\n"
        "    print(f'    Classification: {ode_class[0]}')\n"
        "    print(f'    Solution: {sol}')"
    )

    nb.code(
        "# Numerical ODE solving with scipy solve_ivp\n"
        "# Compare with analytical solutions\n"
        "\n"
        "# Example: damped harmonic oscillator y'' + 0.5*y' + 4*y = 0\n"
        "# Rewrite as system: y1 = y, y2 = y'\n"
        "# y1' = y2, y2' = -0.5*y2 - 4*y1\n"
        "\n"
        "def damped_oscillator(t, state, gamma=0.5, omega2=4.0):\n"
        "    '''Damped harmonic oscillator: y\\'\\'+ gamma*y\\' + omega^2*y = 0.'''\n"
        "    y, v = state\n"
        "    return [v, -gamma * v - omega2 * y]\n"
        "\n"
        "# Initial conditions: y(0) = 1, y'(0) = 0\n"
        "y0 = [1.0, 0.0]\n"
        "t_span = (0, 15)\n"
        "t_eval = np.linspace(*t_span, 500)\n"
        "\n"
        "# Solve for different damping levels\n"
        "damping_levels = {\n"
        "    'Underdamped (gamma=0.3)':  0.3,\n"
        "    'Critically damped (gamma=4.0)': 4.0,\n"
        "    'Overdamped (gamma=5.0)':  5.0,\n"
        "}\n"
        "\n"
        "fig, ax = plt.subplots(figsize=(11, 6))\n"
        "\n"
        "for label, gamma in damping_levels.items():\n"
        "    sol = solve_ivp(damped_oscillator, t_span, y0, t_eval=t_eval,\n"
        "                    args=(gamma, 4.0), method='RK45', rtol=1e-10)\n"
        "    ax.plot(sol.t, sol.y[0], lw=2, label=label)\n"
        "\n"
        "ax.axhline(0, color='gray', ls='--', alpha=0.4)\n"
        "ax.set_xlabel('Time t')\n"
        "ax.set_ylabel('y(t)')\n"
        "ax.set_title(r\"Damped Harmonic Oscillator: $y'' + \\gamma y' + 4y = 0$, $y(0)=1$\")\n"
        "ax.legend()\n"
        "ax.grid(True, alpha=0.3)\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "print('Underdamped: oscillations decay. Critical: fastest decay without overshoot.')\n"
        "print('Overdamped: slow return to equilibrium without oscillation.')"
    )

    # ---- Section 5: Phase Portraits ----
    nb.md(
        "## 5. Phase Portraits for 2D Systems\n"
        "\n"
        "A 2D autonomous system\n"
        "\n"
        "$$\\frac{dx}{dt} = f(x, y), \\qquad \\frac{dy}{dt} = g(x, y)$$\n"
        "\n"
        "can be visualized via a **phase portrait**: a vector field in the $(x, y)$\n"
        "plane with trajectories showing how the system evolves from different initial conditions.\n"
        "\n"
        "### Classification of equilibria (linear systems $\\dot{\\mathbf{x}} = A\\mathbf{x}$):\n"
        "\n"
        "| Eigenvalues | Type |\n"
        "|---|---|\n"
        "| Real, same sign | Node (stable if negative) |\n"
        "| Real, opposite sign | Saddle point |\n"
        "| Complex, nonzero real part | Spiral (stable if Re < 0) |\n"
        "| Pure imaginary | Center (periodic orbits) |"
    )

    nb.code(
        "# Phase portraits for three types of 2D linear systems\n"
        "def phase_portrait(A, ax, title, xlim=(-3, 3), ylim=(-3, 3), n_traj=12):\n"
        "    '''Draw phase portrait for dx/dt = Ax.'''\n"
        "    # Vector field\n"
        "    x_range = np.linspace(*xlim, 20)\n"
        "    y_range = np.linspace(*ylim, 20)\n"
        "    X, Y = np.meshgrid(x_range, y_range)\n"
        "    U = A[0, 0]*X + A[0, 1]*Y\n"
        "    V = A[1, 0]*X + A[1, 1]*Y\n"
        "    speed = np.sqrt(U**2 + V**2)\n"
        "    speed[speed == 0] = 1  # Avoid division by zero\n"
        "\n"
        "    ax.streamplot(X, Y, U, V, color=speed, cmap='coolwarm',\n"
        "                  density=1.5, linewidth=0.8, arrowsize=1.2)\n"
        "\n"
        "    # Add some trajectories from specific initial conditions\n"
        "    theta_vals = np.linspace(0, 2*np.pi, n_traj, endpoint=False)\n"
        "    for theta in theta_vals:\n"
        "        ic = [2*np.cos(theta), 2*np.sin(theta)]\n"
        "        sol = solve_ivp(lambda t, s: A @ s, [0, 10], ic,\n"
        "                        t_eval=np.linspace(0, 10, 500), method='RK45')\n"
        "        ax.plot(sol.y[0], sol.y[1], 'k-', alpha=0.3, lw=0.5)\n"
        "\n"
        "    # Eigenvalues\n"
        "    eigvals = np.linalg.eigvals(A)\n"
        "    eig_str = ', '.join([f'{e:.2f}' for e in eigvals])\n"
        "\n"
        "    ax.plot(0, 0, 'ko', markersize=6)\n"
        "    ax.set_xlim(*xlim)\n"
        "    ax.set_ylim(*ylim)\n"
        "    ax.set_xlabel('x')\n"
        "    ax.set_ylabel('y')\n"
        "    ax.set_title(f'{title}\\n$\\\\lambda$ = {eig_str}')\n"
        "    ax.set_aspect('equal')\n"
        "    ax.grid(True, alpha=0.2)\n"
        "\n"
        "fig, axes = plt.subplots(1, 3, figsize=(17, 5.5))\n"
        "\n"
        "# Stable node\n"
        "A1 = np.array([[-2, 0], [0, -1]])\n"
        "phase_portrait(A1, axes[0], 'Stable Node')\n"
        "\n"
        "# Saddle point\n"
        "A2 = np.array([[1, 0], [0, -2]])\n"
        "phase_portrait(A2, axes[1], 'Saddle Point')\n"
        "\n"
        "# Center (pure imaginary eigenvalues)\n"
        "A3 = np.array([[0, 1], [-4, 0]])\n"
        "phase_portrait(A3, axes[2], 'Center')\n"
        "\n"
        "plt.suptitle('Phase Portraits of 2D Linear Systems', fontsize=15, y=1.03)\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "print('Node: all trajectories converge. Saddle: unstable equilibrium.')\n"
        "print('Center: closed orbits (conservative system -- like quantum HO).')"
    )

    # ---- Section 6: Harmonic Oscillator ----
    nb.md(
        "## 6. The Harmonic Oscillator: Exact vs Numerical\n"
        "\n"
        "The **simple harmonic oscillator** (SHO) is described by\n"
        "\n"
        "$$\\ddot{x} + \\omega^2 x = 0$$\n"
        "\n"
        "with exact solution $x(t) = A\\cos(\\omega t + \\phi)$.\n"
        "\n"
        "This is the single most important ODE in physics:\n"
        "- Classical mechanics: mass on a spring, pendulum\n"
        "- Electromagnetism: LC circuits\n"
        "- **Quantum mechanics:** the quantum harmonic oscillator is one of the few\n"
        "  exactly solvable systems, with energy levels $E_n = \\hbar\\omega(n + \\frac{1}{2})$.\n"
        "\n"
        "We compare the **exact analytical solution** with a **numerical solution** from\n"
        "`scipy.integrate.solve_ivp` and analyze the numerical error."
    )

    nb.code(
        "# Harmonic oscillator: exact vs numerical solution\n"
        "omega = 2.0  # Angular frequency\n"
        "x0 = 1.0     # Initial displacement\n"
        "v0 = 0.0     # Initial velocity\n"
        "\n"
        "# Exact solution: x(t) = x0*cos(omega*t) + (v0/omega)*sin(omega*t)\n"
        "def exact_solution(t):\n"
        "    return x0 * np.cos(omega * t) + (v0 / omega) * np.sin(omega * t)\n"
        "\n"
        "def exact_velocity(t):\n"
        "    return -x0 * omega * np.sin(omega * t) + v0 * np.cos(omega * t)\n"
        "\n"
        "# Numerical solution via solve_ivp (RK45)\n"
        "def harmonic_rhs(t, state):\n"
        "    x, v = state\n"
        "    return [v, -omega**2 * x]\n"
        "\n"
        "t_span = (0, 20)\n"
        "t_eval = np.linspace(*t_span, 2000)\n"
        "\n"
        "sol = solve_ivp(harmonic_rhs, t_span, [x0, v0], t_eval=t_eval,\n"
        "                method='RK45', rtol=1e-12, atol=1e-14)\n"
        "\n"
        "# Compute errors\n"
        "x_exact = exact_solution(sol.t)\n"
        "v_exact = exact_velocity(sol.t)\n"
        "x_error = np.abs(sol.y[0] - x_exact)\n"
        "v_error = np.abs(sol.y[1] - v_exact)\n"
        "\n"
        "# Energy conservation check: E = 0.5*v^2 + 0.5*omega^2*x^2\n"
        "energy_exact = 0.5 * v_exact**2 + 0.5 * omega**2 * x_exact**2\n"
        "energy_num = 0.5 * sol.y[1]**2 + 0.5 * omega**2 * sol.y[0]**2\n"
        "\n"
        "fig, axes = plt.subplots(2, 2, figsize=(14, 9))\n"
        "\n"
        "# (a) Position\n"
        "axes[0, 0].plot(sol.t, x_exact, 'b-', lw=2, label='Exact')\n"
        "axes[0, 0].plot(sol.t, sol.y[0], 'r--', lw=1, label='RK45')\n"
        "axes[0, 0].set_xlabel('t')\n"
        "axes[0, 0].set_ylabel('x(t)')\n"
        "axes[0, 0].set_title('Position: Exact vs Numerical')\n"
        "axes[0, 0].legend()\n"
        "axes[0, 0].grid(True, alpha=0.3)\n"
        "\n"
        "# (b) Phase space\n"
        "axes[0, 1].plot(x_exact, v_exact, 'b-', lw=2, label='Exact (circle)')\n"
        "axes[0, 1].plot(sol.y[0], sol.y[1], 'r--', lw=1, label='RK45')\n"
        "axes[0, 1].set_xlabel('x')\n"
        "axes[0, 1].set_ylabel('v = dx/dt')\n"
        "axes[0, 1].set_title('Phase Space')\n"
        "axes[0, 1].set_aspect('equal')\n"
        "axes[0, 1].legend()\n"
        "axes[0, 1].grid(True, alpha=0.3)\n"
        "\n"
        "# (c) Error\n"
        "axes[1, 0].semilogy(sol.t, x_error, 'b-', alpha=0.7, label='Position error')\n"
        "axes[1, 0].semilogy(sol.t, v_error, 'r-', alpha=0.7, label='Velocity error')\n"
        "axes[1, 0].set_xlabel('t')\n"
        "axes[1, 0].set_ylabel('Absolute error')\n"
        "axes[1, 0].set_title('Numerical Error (RK45)')\n"
        "axes[1, 0].legend()\n"
        "axes[1, 0].grid(True, alpha=0.3, which='both')\n"
        "\n"
        "# (d) Energy conservation\n"
        "axes[1, 1].plot(sol.t, (energy_num - energy_num[0]) / energy_num[0], 'g-')\n"
        "axes[1, 1].set_xlabel('t')\n"
        "axes[1, 1].set_ylabel('Relative energy drift')\n"
        "axes[1, 1].set_title('Energy Conservation')\n"
        "axes[1, 1].grid(True, alpha=0.3)\n"
        "\n"
        "plt.suptitle(f'Simple Harmonic Oscillator ($\\\\omega = {omega}$)', fontsize=15, y=1.02)\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "\n"
        "print(f'Max position error: {np.max(x_error):.2e}')\n"
        "print(f'Max energy drift:   {np.max(np.abs(energy_num - energy_num[0]))/energy_num[0]:.2e}')"
    )

    # ---- Section 7: QM Connection ----
    nb.md(
        "## 7. Quantum Mechanics Connection\n"
        "\n"
        "### The Schrodinger Equation as a Differential Equation\n"
        "\n"
        "The **time-independent Schrodinger equation** (TISE) is a second-order ODE:\n"
        "\n"
        "$$-\\frac{\\hbar^2}{2m}\\frac{d^2\\psi}{dx^2} + V(x)\\psi(x) = E\\psi(x)$$\n"
        "\n"
        "This is an **eigenvalue problem**: find the wavefunctions $\\psi_n$ and\n"
        "energies $E_n$ for a given potential $V(x)$.\n"
        "\n"
        "### Classical to Quantum Harmonic Oscillator\n"
        "\n"
        "The classical HO potential $V(x) = \\frac{1}{2}m\\omega^2 x^2$ leads to the\n"
        "quantum energy levels:\n"
        "\n"
        "$$E_n = \\hbar\\omega\\left(n + \\frac{1}{2}\\right), \\qquad n = 0, 1, 2, \\ldots$$\n"
        "\n"
        "The wavefunctions are **Hermite functions**:\n"
        "\n"
        "$$\\psi_n(x) = \\frac{1}{\\sqrt{2^n n!}}\\left(\\frac{m\\omega}{\\pi\\hbar}\\right)^{1/4}\n"
        "e^{-m\\omega x^2/(2\\hbar)} H_n\\!\\left(\\sqrt{\\frac{m\\omega}{\\hbar}}\\,x\\right)$$\n"
        "\n"
        "where $H_n$ are the Hermite polynomials."
    )

    nb.code(
        "# Quantum Harmonic Oscillator wavefunctions and energy levels\n"
        "from scipy.special import hermite\n"
        "from math import factorial as fac\n"
        "\n"
        "def qho_wavefunction(x, n, m=1.0, omega=1.0, hbar=1.0):\n"
        "    '''Quantum harmonic oscillator wavefunction psi_n(x).'''\n"
        "    xi = np.sqrt(m * omega / hbar) * x\n"
        "    norm = (1.0 / np.sqrt(2**n * fac(n))) * (m * omega / (np.pi * hbar))**0.25\n"
        "    Hn = hermite(n)\n"
        "    return norm * np.exp(-xi**2 / 2) * Hn(xi)\n"
        "\n"
        "def qho_energy(n, omega=1.0, hbar=1.0):\n"
        "    '''Energy of the n-th level: E_n = hbar*omega*(n + 1/2).'''\n"
        "    return hbar * omega * (n + 0.5)\n"
        "\n"
        "# Plot first 5 wavefunctions and probability densities\n"
        "x_vals = np.linspace(-5, 5, 500)\n"
        "n_levels = 5\n"
        "\n"
        "fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 7))\n"
        "\n"
        "colors = plt.cm.tab10(np.linspace(0, 0.5, n_levels))\n"
        "\n"
        "for n in range(n_levels):\n"
        "    psi = qho_wavefunction(x_vals, n)\n"
        "    E_n = qho_energy(n)\n"
        "\n"
        "    # Offset by energy level for visualization\n"
        "    ax1.plot(x_vals, psi + E_n, color=colors[n], lw=1.5,\n"
        "             label=rf'$\\psi_{n}$, $E_{n}={E_n:.1f}\\,\\hbar\\omega$')\n"
        "    ax1.axhline(E_n, color=colors[n], ls='--', alpha=0.3)\n"
        "\n"
        "    ax2.plot(x_vals, np.abs(psi)**2 + E_n, color=colors[n], lw=1.5,\n"
        "             label=rf'$|\\psi_{n}|^2$')\n"
        "    ax2.axhline(E_n, color=colors[n], ls='--', alpha=0.3)\n"
        "\n"
        "# Add the potential\n"
        "V = 0.5 * x_vals**2\n"
        "ax1.plot(x_vals, V, 'k-', lw=2, alpha=0.3, label=r'$V(x) = \\frac{1}{2}\\omega^2 x^2$')\n"
        "ax2.plot(x_vals, V, 'k-', lw=2, alpha=0.3, label=r'$V(x)$')\n"
        "\n"
        "ax1.set_xlabel('x')\n"
        "ax1.set_ylabel(r'$\\psi_n(x) + E_n$')\n"
        "ax1.set_title('Wavefunctions (offset by energy)')\n"
        "ax1.legend(fontsize=8, loc='upper right')\n"
        "ax1.set_ylim(-0.5, 6)\n"
        "ax1.grid(True, alpha=0.2)\n"
        "\n"
        "ax2.set_xlabel('x')\n"
        "ax2.set_ylabel(r'$|\\psi_n(x)|^2 + E_n$')\n"
        "ax2.set_title('Probability Densities (offset by energy)')\n"
        "ax2.legend(fontsize=8, loc='upper right')\n"
        "ax2.set_ylim(-0.5, 6)\n"
        "ax2.grid(True, alpha=0.2)\n"
        "\n"
        "plt.suptitle('Quantum Harmonic Oscillator', fontsize=16, y=1.02)\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "\n"
        "# Verify orthonormality\n"
        "print('Orthonormality check: <psi_m | psi_n> (should be delta_mn)')\n"
        "print('-' * 50)\n"
        "for m in range(4):\n"
        "    for n in range(m, 4):\n"
        "        integrand = qho_wavefunction(x_vals, m) * qho_wavefunction(x_vals, n)\n"
        "        inner_product = np.trapz(integrand, x_vals)\n"
        "        expected = 1.0 if m == n else 0.0\n"
        "        print(f'  <{m}|{n}> = {inner_product:8.5f}  (expect {expected:.1f})')"
    )

    nb.code(
        "# Numerical solution of the Schrodinger equation for the QHO\n"
        "# Using the finite-difference matrix diagonalization approach\n"
        "\n"
        "# Discretize the TISE: -d^2 psi/dx^2 + x^2 psi = 2E psi  (natural units)\n"
        "# Using finite differences: d^2psi/dx^2 ~ (psi_{i+1} - 2*psi_i + psi_{i-1})/dx^2\n"
        "\n"
        "N = 500          # Grid points\n"
        "x_max = 8.0\n"
        "x_grid = np.linspace(-x_max, x_max, N)\n"
        "dx = x_grid[1] - x_grid[0]\n"
        "\n"
        "# Construct the Hamiltonian matrix (tridiagonal + potential)\n"
        "# H = -d^2/dx^2 + V(x), using hbar = m = omega = 1\n"
        "# Kinetic energy: T_{ij} for tridiagonal\n"
        "diag = 1.0 / dx**2 + 0.5 * x_grid**2  # Main diagonal: kinetic + potential\n"
        "off_diag = -0.5 / dx**2 * np.ones(N - 1)  # Off-diagonal: kinetic\n"
        "\n"
        "# Build sparse tridiagonal matrix\n"
        "H = np.diag(diag) + np.diag(off_diag, 1) + np.diag(off_diag, -1)\n"
        "\n"
        "# Solve eigenvalue problem\n"
        "eigenvalues, eigenvectors = np.linalg.eigh(H)\n"
        "\n"
        "# Compare first several eigenvalues with exact: E_n = n + 0.5\n"
        "n_compare = 8\n"
        "print('Numerical vs Exact Energy Levels (hbar = m = omega = 1)')\n"
        "print('=' * 55)\n"
        "print(f'{\"n\":>3s} {\"Numerical\":>14s} {\"Exact\":>14s} {\"Error\":>12s}')\n"
        "print('-' * 55)\n"
        "for n in range(n_compare):\n"
        "    E_exact = n + 0.5\n"
        "    E_num = eigenvalues[n]\n"
        "    error = abs(E_num - E_exact)\n"
        "    print(f'{n:3d} {E_num:14.8f} {E_exact:14.8f} {error:12.2e}')\n"
        "\n"
        "# Plot numerical vs analytical wavefunctions\n"
        "fig, axes = plt.subplots(2, 2, figsize=(13, 9))\n"
        "for idx, ax in enumerate(axes.flat):\n"
        "    n = idx\n"
        "    # Numerical wavefunction (normalize)\n"
        "    psi_num = eigenvectors[:, n]\n"
        "    psi_num = psi_num / np.sqrt(np.trapz(psi_num**2, x_grid))\n"
        "    # Fix sign ambiguity\n"
        "    if psi_num[N//2] < 0 and n % 2 == 0:\n"
        "        psi_num = -psi_num\n"
        "    if psi_num[N//2 + 10] < 0 and n % 2 == 1:\n"
        "        psi_num = -psi_num\n"
        "\n"
        "    # Analytical\n"
        "    psi_exact = qho_wavefunction(x_grid, n)\n"
        "\n"
        "    ax.plot(x_grid, psi_exact, 'b-', lw=2, label='Analytical')\n"
        "    ax.plot(x_grid, psi_num, 'r--', lw=1.5, label='Numerical')\n"
        "    ax.set_xlabel('x')\n"
        "    ax.set_ylabel(rf'$\\psi_{n}(x)$')\n"
        "    ax.set_title(rf'$n = {n}$, $E_{n} = {eigenvalues[n]:.4f}$ '\n"
        "                 rf'(exact: {n+0.5:.1f})')\n"
        "    ax.legend()\n"
        "    ax.grid(True, alpha=0.3)\n"
        "    ax.set_xlim(-5, 5)\n"
        "\n"
        "plt.suptitle('Quantum HO: Numerical (finite diff.) vs Analytical',\n"
        "             fontsize=15, y=1.02)\n"
        "plt.tight_layout()\n"
        "plt.show()\n"
        "print('The finite-difference method recovers the exact QHO solutions')\n"
        "print('with high accuracy -- a preview of computational quantum mechanics.')"
    )

    # ---- Summary ----
    nb.md(
        "## Summary\n"
        "\n"
        "### Key Formulas\n"
        "\n"
        "| Concept | Formula |\n"
        "|---|---|\n"
        "| Partial derivative | $\\frac{\\partial f}{\\partial x} = \\lim_{h\\to 0}\\frac{f(x+h,y)-f(x,y)}{h}$ |\n"
        "| Gradient | $\\nabla f = (\\partial_x f,\\, \\partial_y f)$ |\n"
        "| Green's theorem | $\\oint_C(Pdx+Qdy) = \\iint_D(Q_x - P_y)\\,dA$ |\n"
        "| SHO solution | $x(t) = A\\cos(\\omega t + \\phi)$ |\n"
        "| Phase portrait | $\\dot{\\mathbf{x}} = A\\mathbf{x}$, classified by eigenvalues of $A$ |\n"
        "| TISE | $-\\frac{\\hbar^2}{2m}\\psi'' + V\\psi = E\\psi$ |\n"
        "| QHO energies | $E_n = \\hbar\\omega(n + \\frac{1}{2})$ |\n"
        "\n"
        "### Main Takeaways\n"
        "\n"
        "1. Multivariable calculus extends derivatives and integrals to higher dimensions -- essential for 3D quantum systems.\n"
        "2. The gradient is the key to optimization and appears in quantum mechanics as the momentum operator (up to constants).\n"
        "3. Green's theorem connects line integrals to area integrals; it generalizes to Stokes' theorem used in gauge theory.\n"
        "4. ODEs are solved analytically (SymPy `dsolve`) and numerically (`scipy.integrate.solve_ivp`); both approaches are used in QM.\n"
        "5. Phase portraits reveal the qualitative behavior of dynamical systems -- centers correspond to quantum bound states.\n"
        "6. The harmonic oscillator bridges classical and quantum physics: the classical ODE becomes the quantum eigenvalue problem.\n"
        "7. Numerical methods (finite differences) can solve the Schrodinger equation, recovering exact results for exactly solvable potentials.\n"
        "\n"
        "---\n"
        "*Next: Linear Algebra I (Month 4) -- the language of quantum mechanics.*"
    )

    nb.save()
    print("  [3/3] Notebook 3 complete.\n")


# ============================================================================
# MAIN - Generate all three notebooks
# ============================================================================
if __name__ == "__main__":
    print("=" * 65)
    print("SIIEA Quantum Engineering -- Notebook Generator: Months 1-3")
    print("Year 0: Mathematical Foundations / Calculus & Diff. Equations")
    print("=" * 65)
    print()

    build_notebook_1()
    build_notebook_2()
    build_notebook_3()

    print("=" * 65)
    print("All 3 notebooks generated successfully.")
    print("=" * 65)

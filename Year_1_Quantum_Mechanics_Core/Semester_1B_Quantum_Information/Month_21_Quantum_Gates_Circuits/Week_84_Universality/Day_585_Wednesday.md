# Day 585: Clifford+T

## Overview
**Day 585** | Week 84, Day 4 | Year 1, Month 21 | Universality Through Non-Clifford Gates

Today we explore how adding the T gate to Clifford operations achieves universal quantum computation, and introduce the crucial concept of magic states for fault-tolerant implementation.

---

## Learning Objectives

1. Prove that Clifford+T is universal
2. Understand T gate synthesis algorithms
3. Introduce magic states and state distillation
4. Calculate T-count for common operations
5. Explain the resource theory of magic
6. Connect Clifford+T to fault-tolerant quantum computing

---

## Core Content

### The Clifford+T Gate Set

**Definition:** The **Clifford+T** gate set is:
$$\{H, S, CNOT, T\}$$

where $T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix}$

**Key Theorem:** Clifford+T is universal for quantum computation.

### Why T Makes the Difference

Recall from Day 584: Clifford gates are classically simulable.

**T gate properties:**
- $T = R_z(\pi/4)$ (up to global phase)
- $T^2 = S$ (Clifford)
- $T^4 = Z$ (Clifford)
- $T^8 = I$

**Crucial:** $TXT^\dagger$ is NOT a Pauli!
$$TXT^\dagger = e^{i\pi/4}\frac{1}{\sqrt{2}}(X + Y)$$

This "non-Clifford" transformation enables universality.

### Proof of Universality

**Strategy:** Show {H, T} generates a dense subgroup of SU(2).

**Step 1:** Consider the group generated by $H$ and $T$.

The key rotation is:
$$\pi/8\text{-gate}: T = e^{i\pi/8}R_z(\pi/4)$$

**Step 2:** Form compound gates:
$$HTH = e^{i\pi/4}R_x(\pi/4)$$

$$W = (HTH) \cdot T \cdot (HTH)$$

**Step 3:** Show $W$ involves an irrational rotation angle (incommensurate with $\pi$).

**Step 4:** By equidistribution, powers of $W$ densely cover a rotation circle.

**Step 5:** Combining with $H$ (axis change), we get density in SU(2).

**Conclusion:** {H, T} is dense in SU(2), so Clifford+T is universal.

### T-Gate Synthesis

**Problem:** Approximate $R_z(\theta)$ using Clifford+T.

**Ross-Selinger Algorithm:**
$$\text{T-count} = 3\log_2(1/\epsilon) + O(1)$$

This is **optimal** up to constants!

**Example:** To approximate $R_z(\pi/7)$ to precision $10^{-10}$:
$$\text{T-count} \approx 3 \times \log_2(10^{10}) \approx 3 \times 33 = 99 \text{ T gates}$$

### Magic States

**Definition:** A **magic state** is a non-stabilizer state that enables non-Clifford gates via gate teleportation.

**T-state:**
$$|T\rangle = T|+\rangle = \frac{1}{\sqrt{2}}(|0\rangle + e^{i\pi/4}|1\rangle)$$

**Magic state injection:** Given $|T\rangle$, implement T gate using only Clifford operations!

```
|ψ⟩ ──────●──────────[S^c]────── T|ψ⟩
          │
|T⟩ ─────⊕────[M]════c═══════════
```

If measurement gives 1, apply $S$ correction.

### Why Magic States Matter

**Fault tolerance challenge:**
- Clifford gates can be implemented transversally (easily fault-tolerant)
- T gate cannot be transversal for most codes

**Solution:**
1. Prepare noisy $|T\rangle$ states
2. Distill to high-fidelity $|T\rangle$
3. Use magic state injection

### Magic State Distillation

**Problem:** Create high-fidelity $|T\rangle$ from noisy copies.

**15-to-1 Protocol:**
- Input: 15 noisy $|T\rangle$ states with error $\epsilon$
- Output: 1 distilled $|T\rangle$ with error $35\epsilon^3$
- Overhead: Factor of 15 per level

**Distillation factory:** Multi-level distillation achieves arbitrary precision.

### Resource Theory of Magic

**Magic** (or **non-stabilizerness**) quantifies deviation from Clifford/stabilizer regime.

**Properties:**
- Stabilizer states have zero magic
- T states have finite magic
- Magic is a resource for universal QC

**Magic measures:**
- Stabilizer rank
- Robustness of magic
- Mana (logarithmic measure)

### T-Count of Common Operations

| Operation | Minimum T-count |
|-----------|-----------------|
| T gate | 1 |
| T† gate | 1 |
| General $R_z(\theta)$ | ~$3\log(1/\epsilon)$ |
| Toffoli | 7 |
| Controlled-S | 3 |
| Controlled-T | 7 |
| Fredkin (CSWAP) | 7 |

### Clifford+T Compilation Pipeline

```
Arbitrary U
    ↓
Solovay-Kitaev or optimal synthesis
    ↓
Clifford+T circuit
    ↓
Clifford synthesis (exact)
    ↓
T-gate decomposition
    ↓
Fault-tolerant implementation
    (magic state injection)
```

### T-Depth Optimization

**T-depth** = number of layers containing T gates.

**Why minimize?** T gates require magic states; parallelizing T's reduces runtime.

**Techniques:**
- Ancilla-based T parallelization
- T-par algorithm
- Phase polynomial optimization

### Classical Hardness of Clifford+T

**Theorem:** Simulating Clifford+T circuits is classically hard (under standard assumptions).

More precisely:
- **BQP-complete:** As hard as general quantum computation
- **Post-selection:** Gives #P-hardness
- **Approximate counting:** T gates make simulation exponentially hard

---

## Worked Examples

### Example 1: Magic State Injection

Show how to implement T using $|T\rangle$ and Clifford gates.

**Solution:**

**Circuit:**
```
|ψ⟩ = α|0⟩ + β|1⟩ ───●────────[S^m]──── T|ψ⟩
                     │
|T⟩ ────────────────⊕───[M]═══m═══
```

**Analysis:**

After CNOT:
$$|\psi'\rangle = \alpha|0\rangle|T_0\rangle + \beta|1\rangle|T_1\rangle$$

where $|T\rangle = \frac{1}{\sqrt{2}}(|0\rangle + e^{i\pi/4}|1\rangle)$, so $|T_0\rangle = |0\rangle$, $|T_1\rangle = |1\rangle$ after CNOT.

Wait, let me redo this carefully.

$|T\rangle = \frac{1}{\sqrt{2}}(|0\rangle + e^{i\pi/4}|1\rangle)$

Initial state: $(\alpha|0\rangle + \beta|1\rangle) \otimes \frac{1}{\sqrt{2}}(|0\rangle + e^{i\pi/4}|1\rangle)$

After CNOT (first qubit control):
$$= \frac{\alpha}{\sqrt{2}}|0\rangle(|0\rangle + e^{i\pi/4}|1\rangle) + \frac{\beta}{\sqrt{2}}|1\rangle(|1\rangle + e^{i\pi/4}|0\rangle)$$

$$= \frac{1}{\sqrt{2}}[\alpha|00\rangle + \alpha e^{i\pi/4}|01\rangle + \beta e^{i\pi/4}|10\rangle + \beta|11\rangle]$$

Measure second qubit:
- Outcome 0: $\alpha|0\rangle + \beta e^{i\pi/4}|1\rangle = T|\psi\rangle$  ✓
- Outcome 1: $\alpha e^{i\pi/4}|0\rangle + \beta|1\rangle = e^{i\pi/4} S^\dagger T|\psi\rangle$

For outcome 1, apply $S$ to correct: $S \cdot (\alpha e^{i\pi/4}|0\rangle + \beta|1\rangle) = \alpha e^{i\pi/4}|0\rangle + i\beta|1\rangle$

Hmm, this needs the right correction. The standard protocol uses:

**Corrected circuit:**
- If $m = 0$: output is $T|\psi\rangle$ (no correction)
- If $m = 1$: apply $SX$ correction

This implements T gate using only Clifford gates + magic state!

### Example 2: Toffoli T-Count

Verify that Toffoli requires 7 T gates.

**Solution:**

The minimal T-count decomposition of Toffoli (CCX) is:

```
a: ──────●──────●──────────●────────────●─────────────
         │      │          │            │
b: ──●───│──────│───●──────│───●────────│───●─────────
     │   │      │   │      │   │        │   │
c: ──T†──⊕──T───⊕───T†─────⊕───T──H─T───⊕───T†──H─────
```

Count: 7 T gates (4 T†, 3 T; or variations with same total).

This has been proven optimal for Toffoli without ancillas.

### Example 3: Distillation Calculation

Calculate output error for 15-to-1 distillation with input error $\epsilon = 0.01$.

**Solution:**

Output error: $35\epsilon^3 = 35 \times (0.01)^3 = 35 \times 10^{-6} = 3.5 \times 10^{-5}$

Error reduction: $0.01 \to 3.5 \times 10^{-5}$ (factor of ~300)

For target $\epsilon_{out} = 10^{-10}$:
- Level 1: $0.01 \to 3.5 \times 10^{-5}$
- Level 2: $3.5 \times 10^{-5} \to 35 \times (3.5 \times 10^{-5})^3 \approx 1.5 \times 10^{-12}$

Two levels of distillation suffice!

---

## Practice Problems

### Problem 1: T-Count
What is the minimum T-count to implement $T^\dagger$?

### Problem 2: Magic State Verification
Show that $|T\rangle = T|+\rangle$ is not a stabilizer state.

### Problem 3: Compilation
Express $R_z(\pi/8) = T^{1/2}$ approximately using Clifford+T.

### Problem 4: Distillation Overhead
How many raw magic states are needed to produce one state with error $< 10^{-15}$ using 15-to-1 distillation, starting from error $\epsilon = 0.001$?

---

## Computational Lab

```python
"""Day 585: Clifford+T and Magic States"""
import numpy as np
from scipy.linalg import expm

# Gates
I = np.eye(2, dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)
H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
S = np.array([[1, 0], [0, 1j]], dtype=complex)
T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)

CNOT = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
], dtype=complex)

def tensor(A, B):
    return np.kron(A, B)

def Rz(theta):
    return np.array([
        [np.exp(-1j * theta / 2), 0],
        [0, np.exp(1j * theta / 2)]
    ], dtype=complex)

# ===== Example 1: T gate properties =====
print("=" * 60)
print("Example 1: T Gate Properties")
print("=" * 60)

print("\nT gate powers:")
print(f"  T^2 = S: {np.allclose(T @ T, S)}")
print(f"  T^4 = Z: {np.allclose(np.linalg.matrix_power(T, 4), Z)}")
print(f"  T^8 = I: {np.allclose(np.linalg.matrix_power(T, 8), I)}")

print("\nT X T^dag (showing non-Clifford):")
TXT = T @ X @ np.conj(T.T)
print(np.round(TXT, 4))
print("This is NOT a Pauli matrix!")

# ===== Example 2: Magic State =====
print("\n" + "=" * 60)
print("Example 2: Magic State |T⟩")
print("=" * 60)

# |+⟩ state
plus = np.array([1, 1], dtype=complex) / np.sqrt(2)

# |T⟩ = T|+⟩
T_state = T @ plus
print(f"\n|T⟩ = T|+⟩ = {T_state}")

# Verify it's not a stabilizer state
# Stabilizer states for 1 qubit: |0⟩, |1⟩, |+⟩, |-⟩, |+i⟩, |-i⟩
stabilizer_states = [
    np.array([1, 0], dtype=complex),  # |0⟩
    np.array([0, 1], dtype=complex),  # |1⟩
    np.array([1, 1], dtype=complex) / np.sqrt(2),  # |+⟩
    np.array([1, -1], dtype=complex) / np.sqrt(2),  # |-⟩
    np.array([1, 1j], dtype=complex) / np.sqrt(2),  # |+i⟩
    np.array([1, -1j], dtype=complex) / np.sqrt(2),  # |-i⟩
]

print("\nChecking if |T⟩ is a stabilizer state:")
for i, state in enumerate(stabilizer_states):
    # Check if equal up to global phase
    for phase in [1, -1, 1j, -1j]:
        if np.allclose(T_state, phase * state):
            print(f"  Match with stabilizer state {i}!")
            break
    else:
        continue
    break
else:
    print("  |T⟩ is NOT a stabilizer state!")

# ===== Example 3: Magic State Injection =====
print("\n" + "=" * 60)
print("Example 3: Magic State Injection")
print("=" * 60)

def magic_state_injection(psi):
    """
    Implement T gate using magic state injection.
    Returns T|ψ⟩ using only Clifford gates.
    """
    # Initial state: |ψ⟩ ⊗ |T⟩
    state = tensor(psi, T_state)

    # CNOT (first qubit control)
    state = CNOT @ state

    # Measure second qubit
    # Probability of outcome 0
    p0 = np.abs(state[0])**2 + np.abs(state[2])**2

    # For simulation, let's compute both outcomes
    # Outcome 0: project onto |x0⟩
    proj_0 = tensor(I, np.array([[1, 0], [0, 0]]))
    state_0 = proj_0 @ state
    state_0 = state_0 / np.linalg.norm(state_0) if np.linalg.norm(state_0) > 0 else state_0

    # Outcome 1: project onto |x1⟩
    proj_1 = tensor(I, np.array([[0, 0], [0, 1]]))
    state_1 = proj_1 @ state
    state_1 = state_1 / np.linalg.norm(state_1) if np.linalg.norm(state_1) > 0 else state_1

    # Extract first qubit
    out_0 = np.array([state_0[0], state_0[2]])
    out_1 = np.array([state_1[1], state_1[3]])

    # Apply correction for outcome 1
    out_1_corrected = S @ X @ out_1

    return out_0, out_1_corrected, p0

# Test
psi_test = np.array([0.6, 0.8], dtype=complex)
psi_test = psi_test / np.linalg.norm(psi_test)

expected = T @ psi_test
out_0, out_1, p0 = magic_state_injection(psi_test)

print(f"\nInput: |ψ⟩ = {psi_test}")
print(f"Expected T|ψ⟩ = {expected}")
print(f"\nOutcome 0 (prob {p0:.3f}): {out_0}")
print(f"Outcome 1 (prob {1-p0:.3f}): {out_1}")

# Verify they match (up to global phase)
print(f"\nMatch (outcome 0): {np.allclose(np.abs(out_0), np.abs(expected))}")

# ===== Example 4: T-count for Rz synthesis =====
print("\n" + "=" * 60)
print("Example 4: T-Count for Rotation Synthesis")
print("=" * 60)

def ross_selinger_t_count(epsilon):
    """Optimal T-count for Rz rotation synthesis"""
    return int(np.ceil(3 * np.log2(1/epsilon) + 4))

print("\nRoss-Selinger T-count: ~3 log₂(1/ε)")
print(f"\n{'Precision ε':<15} {'T-count':<12}")
print("-" * 30)

for exp in [2, 4, 6, 8, 10, 12]:
    epsilon = 10**(-exp)
    t_count = ross_selinger_t_count(epsilon)
    print(f"10^{-exp:<12} {t_count:<12}")

# ===== Example 5: Distillation Calculation =====
print("\n" + "=" * 60)
print("Example 5: Magic State Distillation")
print("=" * 60)

def distill_15_to_1(epsilon_in, levels=1):
    """15-to-1 distillation protocol"""
    epsilon = epsilon_in
    total_states = 1
    for _ in range(levels):
        epsilon = 35 * epsilon**3
        total_states *= 15
    return epsilon, total_states

print("\n15-to-1 distillation protocol:")
print("  Output error: 35ε³")
print("  States used: 15 per level")

print(f"\n{'Input ε':<12} {'Levels':<8} {'Output ε':<15} {'States':<12}")
print("-" * 50)

for eps_in, target in [(0.01, 1e-10), (0.001, 1e-15)]:
    for levels in range(1, 5):
        eps_out, states = distill_15_to_1(eps_in, levels)
        if eps_out < target:
            print(f"{eps_in:<12} {levels:<8} {eps_out:<15.2e} {states:<12}")
            break
        print(f"{eps_in:<12} {levels:<8} {eps_out:<15.2e} {states:<12}")

# ===== Example 6: Toffoli Decomposition =====
print("\n" + "=" * 60)
print("Example 6: Toffoli T-Count")
print("=" * 60)

print("""
Optimal Toffoli decomposition uses 7 T gates:

a: ──────●──────●──────────●────────────●─────────────
         │      │          │            │
b: ──●───│──────│───●──────│───●────────│───●─────────
     │   │      │   │      │   │        │   │
c: ──T†──⊕──T───⊕───T†─────⊕───T──H─T───⊕───T†──H─────

T-count: 7 (proven optimal without ancillas)
""")

# Verify T-count of some gates
print("T-counts of common operations:")
print("  T gate:        1")
print("  S gate:        0 (Clifford)")
print("  Toffoli:       7")
print("  Fredkin:       7")
print("  Controlled-S:  3")

# ===== Summary =====
print("\n" + "=" * 60)
print("Clifford+T Summary")
print("=" * 60)
print("""
CLIFFORD+T = UNIVERSAL:
- Clifford alone: efficiently simulable (Gottesman-Knill)
- Adding T: enables universal quantum computation
- Proof: {H, T} dense in SU(2)

MAGIC STATES:
- |T⟩ = T|+⟩ = (|0⟩ + e^{iπ/4}|1⟩)/√2
- Non-stabilizer (contains "magic")
- Enable T via Clifford + measurement

MAGIC STATE DISTILLATION:
- 15-to-1 protocol: ε → 35ε³
- Achieves arbitrarily high fidelity
- Main overhead in fault-tolerant QC

T-COUNT:
- Critical resource metric
- Toffoli: 7 T gates (optimal)
- Rz(θ): ~3 log₂(1/ε) T gates (optimal)

FAULT-TOLERANT QC:
- Cliffords: transversal (easy)
- T gates: magic state injection
- T-count dominates resource cost
""")
```

---

## Summary

### Clifford+T Universality

| Aspect | Description |
|--------|-------------|
| Gate set | {H, S, CNOT, T} |
| Why universal | {H, T} dense in SU(2) |
| T gate | $R_z(\pi/4)$, non-Clifford |
| Magic state | $\|T\rangle = T\|+\rangle$ |

### Key Formulas

| Concept | Formula |
|---------|---------|
| T gate | $T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix}$ |
| Magic state | $\|T\rangle = \frac{1}{\sqrt{2}}(\|0\rangle + e^{i\pi/4}\|1\rangle)$ |
| T-count for $R_z$ | $\approx 3\log_2(1/\epsilon)$ |
| Distillation | $\epsilon_{out} = 35\epsilon_{in}^3$ |

### Key Takeaways

1. **Clifford+T is universal** but Clifford alone is not
2. **T gate** is the non-Clifford ingredient enabling universality
3. **Magic states** allow T implementation via Clifford operations
4. **Magic state distillation** is the main overhead in fault-tolerant QC
5. **T-count** is the critical resource metric
6. **Toffoli requires 7 T gates** (optimal without ancillas)

---

## Daily Checklist

- [ ] I understand why Clifford+T is universal
- [ ] I can explain magic states and their role
- [ ] I know how magic state injection works
- [ ] I can estimate T-count for rotations
- [ ] I understand the 15-to-1 distillation protocol
- [ ] I ran the computational lab and verified magic state properties

---

*Next: Day 586 — Native Gate Sets*

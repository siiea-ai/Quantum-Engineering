# Day 582: Universal Gate Sets

## Overview
**Day 582** | Week 84, Day 1 | Year 1, Month 21 | Foundations of Universality

Today we establish the concept of universal quantum computation—which sets of gates can implement any quantum algorithm—and prove that {H, T, CNOT} is universal.

---

## Learning Objectives

1. Define what it means for a gate set to be universal
2. Understand density arguments for universality
3. Prove {H, T, CNOT} generates a dense subgroup of SU(2)
4. Recognize equivalent universal gate sets
5. Distinguish exact vs approximate universality
6. Connect universality to computational power

---

## Core Content

### What is Universality?

**Definition:** A gate set $\mathcal{G}$ is **universal** for quantum computation if any unitary operation can be approximated to arbitrary precision using gates from $\mathcal{G}$.

$$\boxed{\forall U \in SU(2^n), \forall \epsilon > 0, \exists \text{ circuit } C \text{ from } \mathcal{G}: ||U - C|| < \epsilon}$$

**Two types:**
1. **Exactly universal:** Can implement any $U$ exactly (requires continuous parameters)
2. **Approximately universal:** Can approximate any $U$ (finite discrete gate set)

### Why Universality Matters

- **Theoretical:** Proves quantum computers can perform any quantum computation
- **Practical:** Defines what hardware must implement
- **Fault tolerance:** Some universal sets are easier to error-correct

### The Standard Universal Set: {H, T, CNOT}

**Claim:** The gate set {H, T, CNOT} is universal for quantum computation.

**Components:**
$$H = \frac{1}{\sqrt{2}}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}, \quad T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix}$$

$$CNOT = \begin{pmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0 \end{pmatrix}$$

### Proof Strategy

To prove universality, we show:
1. Single-qubit gates: {H, T} generates a dense subgroup of SU(2)
2. Two-qubit entanglement: CNOT provides entangling power
3. Together: Can approximate any n-qubit unitary

### Step 1: Single-Qubit Universality

**Theorem:** {H, T} generates a dense subgroup of SU(2).

**Proof sketch:**

The group generated by H and T includes:
$$H, T, T^2 = S, T^4 = Z, T^8 = I$$

Key rotation:
$$HTH = R_x(\pi/2) \cdot \text{phase}$$

More importantly, consider:
$$W = HTH \cdot T \cdot HTH = \text{rotation by irrational angle}$$

**Key insight:** The angle $\theta$ such that $W = R_n(\theta)$ is **irrational** (incommensurate with $\pi$).

By the **equidistribution theorem**: Powers of an irrational rotation densely fill the circle.

Therefore, $\{W^k : k \in \mathbb{Z}\}$ is dense in rotations about axis $n$.

Combined with $H$ (which changes rotation axis), we get density in all of SU(2).

### Step 2: Two-Qubit Universality

**Theorem:** Any two-qubit unitary can be decomposed using CNOT and single-qubit gates.

**KAK Decomposition:**
Any $U \in SU(4)$ can be written as:
$$U = (A_1 \otimes A_2) \cdot \exp\left(i\sum_{j=1}^{3} \theta_j \sigma_j \otimes \sigma_j\right) \cdot (B_1 \otimes B_2)$$

where $A_i, B_i \in SU(2)$ and $\sigma_j$ are Pauli matrices.

The middle term (entangling part) can be implemented with at most **3 CNOTs**.

### Step 3: n-Qubit Universality

**Theorem:** Any n-qubit unitary can be decomposed into two-qubit gates.

**Proof:** Use the **Cosine-Sine decomposition** recursively:
$$U = \begin{pmatrix} C_1 & 0 \\ 0 & C_2 \end{pmatrix} \begin{pmatrix} \cos\Theta & -\sin\Theta \\ \sin\Theta & \cos\Theta \end{pmatrix} \begin{pmatrix} D_1 & 0 \\ 0 & D_2 \end{pmatrix}$$

This recursively breaks down any unitary into two-level unitaries, which can be implemented with controlled gates.

### Alternative Universal Sets

**Theorem:** The following are also universal:

| Gate Set | Notes |
|----------|-------|
| {H, T, CNOT} | Standard, fault-tolerant friendly |
| {H, S, CNOT, T} | Clifford + T |
| {Rx, Ry, CNOT} | Continuous, hardware-friendly |
| {H, Toffoli} | Uses 3-qubit gate |
| {CNOT, single-qubit} | Any dense single-qubit set |
| {√SWAP, single-qubit} | Alternative entangling gate |

### Exact vs Approximate Universality

**Exactly universal sets** include continuous rotations:
- {$R_x(\theta)$, $R_y(\theta)$, CNOT} for all $\theta$

**Approximately universal sets** are finite:
- {H, T, CNOT} — requires approximation for arbitrary rotations

**Trade-off:**
- Exact: Perfect gates, but continuous parameters hard to fault-tolerantly implement
- Approximate: Finite gates, amenable to error correction, but requires more gates

### The Irrational Angle Criterion

**Lemma:** A rotation $R(\theta)$ generates a dense set if and only if $\theta/\pi$ is irrational.

For the T gate: $T = R_z(\pi/4)$, so $\theta = \pi/4$, ratio = 1/4 (rational).

But combinations like $HTH \cdot T \cdot HTH$ produce irrational angles!

### Non-Universal Sets

**Important:** Not every gate set is universal.

**Clifford gates** {H, S, CNOT} are **NOT universal**:
- Can only produce a finite set of states (stabilizer states)
- Efficiently simulable classically (Gottesman-Knill theorem)

Adding T to Clifford gates makes them universal (next topics).

---

## Worked Examples

### Example 1: Generating Rotations

Show how to create $R_z(\pi/8)$ from {H, T}.

**Solution:**

Note that $T = R_z(\pi/4)$ up to global phase.

For $R_z(\pi/8) = T^{1/2}$, we cannot get it exactly with integer powers of T.

However, using Solovay-Kitaev (Day 583), we can approximate:
$$R_z(\pi/8) \approx T \cdot H \cdot T \cdot H \cdot T^{-1} \cdot H \cdot T^{-1} \cdot H \cdots$$

with error $\epsilon$ using $O(\log^c(1/\epsilon))$ gates.

### Example 2: CNOT from Other Gates

Express CNOT using CZ and Hadamard gates.

**Solution:**

The identity:
$$CNOT = (I \otimes H) \cdot CZ \cdot (I \otimes H)$$

**Verification:**
```
   ──●──    =    ───────●───────
     │               ┌───┐│┌───┐
   ──⊕──    =    ───┤ H ├●┤ H ├──
                     └───┘ └───┘
```

CZ applies Z to target when control is |1⟩.
H converts Z to X (since HZH = X).
Therefore: H·Z·H = X, giving CNOT behavior.

### Example 3: Verifying Density

Show that $T^8 = I$ but {H,T} is still universal.

**Solution:**

$T^8 = I$ means T alone only generates 8 distinct rotations about Z.

But combining H and T:
- $T$: rotation about Z by $\pi/4$
- $HTH$: rotation about X (since $HZH = X$)
- Products create rotations about general axes

The key is that certain products like $(HTH)T(HTH)$ involve irrational angles, breaking the periodicity.

---

## Practice Problems

### Problem 1: Gate Set Equivalence
Prove that {H, T, CNOT} can implement the S gate.

### Problem 2: Non-Universality
Why is {X, CNOT} not a universal gate set?

### Problem 3: Counting
How many distinct single-qubit gates can be formed using at most 3 gates from {H, T}?

### Problem 4: Alternative Set
Show that {H, T, CZ} is universal.

---

## Computational Lab

```python
"""Day 582: Universal Gate Sets"""
import numpy as np
from scipy.linalg import expm

# Standard gates
I = np.eye(2, dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)
H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
S = np.array([[1, 0], [0, 1j]], dtype=complex)
T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)

def tensor(A, B):
    return np.kron(A, B)

def Rz(theta):
    """Rotation about Z axis"""
    return np.array([
        [np.exp(-1j * theta / 2), 0],
        [0, np.exp(1j * theta / 2)]
    ], dtype=complex)

def Rx(theta):
    """Rotation about X axis"""
    return expm(-1j * theta / 2 * X)

def Ry(theta):
    """Rotation about Y axis"""
    return expm(-1j * theta / 2 * Y)

def gate_distance(U, V):
    """Operator norm distance (up to global phase)"""
    # Minimize over global phase
    phases = np.linspace(0, 2*np.pi, 100)
    min_dist = float('inf')
    for phi in phases:
        dist = np.linalg.norm(U - np.exp(1j * phi) * V, ord=2)
        min_dist = min(min_dist, dist)
    return min_dist

# ===== Example 1: Basic gate relations =====
print("=" * 60)
print("Example 1: Gate Relations in {H, T}")
print("=" * 60)

print("\nT gate powers:")
print(f"  T^1 = T = Rz(pi/4)")
print(f"  T^2 = S = Rz(pi/2): {np.allclose(T @ T, S)}")
print(f"  T^4 = Z = Rz(pi):   {np.allclose(np.linalg.matrix_power(T, 4), Z)}")
print(f"  T^8 = I:            {np.allclose(np.linalg.matrix_power(T, 8), I)}")

print("\nHadamard conjugation:")
print(f"  H T H = Rx(pi/4) (up to phase)")
HTH = H @ T @ H
print(f"  HTH diagonal: {np.diag(HTH)}")

# ===== Example 2: Generating dense set =====
print("\n" + "=" * 60)
print("Example 2: Density of Generated Group")
print("=" * 60)

def random_HT_word(length):
    """Generate random product of H and T"""
    result = I.copy()
    for _ in range(length):
        if np.random.rand() < 0.5:
            result = H @ result
        else:
            result = T @ result
    return result

# Generate many random words and check coverage
print("\nGenerating random words from {H, T}...")
angles = []
for _ in range(1000):
    U = random_HT_word(20)
    # Extract rotation angle (trace = 2 cos(theta/2) for SU(2))
    trace = np.trace(U)
    angle = 2 * np.arccos(np.clip(np.abs(trace) / 2, -1, 1))
    angles.append(angle)

print(f"  Min angle: {min(angles):.4f}")
print(f"  Max angle: {max(angles):.4f}")
print(f"  Number of distinct angles (binned): {len(set(np.round(angles, 2)))}")
print("  (Dense coverage of [0, pi] expected)")

# ===== Example 3: CNOT from CZ =====
print("\n" + "=" * 60)
print("Example 3: CNOT from CZ + Hadamard")
print("=" * 60)

CNOT = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
], dtype=complex)

CZ = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 1, 0],
    [0, 0, 0, -1]
], dtype=complex)

# CNOT = (I tensor H) CZ (I tensor H)
CNOT_from_CZ = tensor(I, H) @ CZ @ tensor(I, H)

print(f"CNOT = (I tensor H) CZ (I tensor H): {np.allclose(CNOT, CNOT_from_CZ)}")

# ===== Example 4: S from T =====
print("\n" + "=" * 60)
print("Example 4: Deriving Gates")
print("=" * 60)

print("S gate from T:")
print(f"  S = T^2: {np.allclose(S, T @ T)}")

print("\nZ gate from T:")
print(f"  Z = T^4: {np.allclose(Z, np.linalg.matrix_power(T, 4))}")

print("\nX from H and Z:")
print(f"  X = HZH: {np.allclose(X, H @ Z @ H)}")

print("\nY from X, Z:")
print(f"  Y = iXZ: {np.allclose(Y, 1j * X @ Z)}")

# ===== Example 5: Non-universality of Clifford =====
print("\n" + "=" * 60)
print("Example 5: Clifford Gates (Non-Universal)")
print("=" * 60)

print("\nClifford gates are generated by {H, S, CNOT}")
print("They can only create stabilizer states!")

# Generate some Clifford circuits
def random_clifford_word(length):
    """Random product of H and S"""
    result = I.copy()
    for _ in range(length):
        if np.random.rand() < 0.5:
            result = H @ result
        else:
            result = S @ result
    return result

# Check: do we ever get T?
print("\nCan Clifford gates approximate T?")
min_dist = float('inf')
for _ in range(10000):
    U = random_clifford_word(10)
    dist = gate_distance(U, T)
    min_dist = min(min_dist, dist)

print(f"  Minimum distance to T after 10000 trials: {min_dist:.4f}")
print("  (Large distance indicates T is NOT in Clifford group)")

# ===== Example 6: Approximating arbitrary rotation =====
print("\n" + "=" * 60)
print("Example 6: Approximating Rz(pi/7) with {H, T}")
print("=" * 60)

target = Rz(np.pi / 7)

# Brute force search over short words
best_dist = float('inf')
best_word = ""

def enumerate_words(max_length):
    """Generate all words up to given length"""
    if max_length == 0:
        yield "", I
        return

    for word, U in enumerate_words(max_length - 1):
        yield word, U
        yield word + "H", H @ U
        yield word + "T", T @ U

print(f"Target: Rz(pi/7)")
for max_len in [5, 8, 10]:
    for word, U in enumerate_words(max_len):
        dist = gate_distance(U, target)
        if dist < best_dist:
            best_dist = dist
            best_word = word

    print(f"  Length <= {max_len}: best distance = {best_dist:.6f}, word = {best_word[:20]}...")

# ===== Summary =====
print("\n" + "=" * 60)
print("Universal Gate Sets Summary")
print("=" * 60)
print("""
Key Results:

1. {H, T, CNOT} is UNIVERSAL
   - H, T generate dense subgroup of SU(2)
   - CNOT provides entangling power
   - Together: any n-qubit unitary

2. Proof relies on:
   - Irrational rotation angles from H-T products
   - Density in SU(2) via equidistribution
   - KAK decomposition for 2-qubit gates

3. Alternative universal sets:
   - {Rx, Ry, CNOT} - continuous
   - {H, Toffoli} - discrete
   - Any dense single-qubit + entangling gate

4. NON-universal:
   - Clifford gates {H, S, CNOT}
   - Efficiently classically simulable!
   - Need T (or similar) for universality
""")
```

---

## Summary

### Universal Gate Sets

| Gate Set | Type | Notes |
|----------|------|-------|
| {H, T, CNOT} | Approximate | Standard, FT-friendly |
| {Rx, Ry, CNOT} | Exact | Continuous parameters |
| {H, Toffoli} | Approximate | 3-qubit entangling gate |
| {H, S, CNOT} | NOT universal | Clifford only |

### Key Formulas

| Concept | Formula |
|---------|---------|
| Universality condition | $\forall U, \epsilon > 0: \exists C, \|\|U - C\|\| < \epsilon$ |
| T gate | $T = R_z(\pi/4)$, $T^8 = I$ |
| S from T | $S = T^2$ |
| CNOT from CZ | $CNOT = (I \otimes H) CZ (I \otimes H)$ |

### Key Takeaways

1. **Universality** means approximating any unitary to arbitrary precision
2. **{H, T, CNOT}** is the standard universal set for fault-tolerant QC
3. **Density** in SU(2) comes from irrational rotation angles
4. **CNOT** provides the entangling power needed for multi-qubit universality
5. **Clifford gates alone** are NOT universal (efficiently simulable)
6. **Adding T** to Clifford gates yields universality

---

## Daily Checklist

- [ ] I can define what makes a gate set universal
- [ ] I understand the proof sketch for {H, T, CNOT} universality
- [ ] I can identify equivalent universal gate sets
- [ ] I understand why Clifford gates are not universal
- [ ] I can convert between CNOT and CZ using Hadamard
- [ ] I ran the computational lab and explored gate density

---

*Next: Day 583 — Solovay-Kitaev Theorem*

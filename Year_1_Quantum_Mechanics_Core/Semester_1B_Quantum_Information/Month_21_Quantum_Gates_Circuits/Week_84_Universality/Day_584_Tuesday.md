# Day 584: Clifford Gates

## Overview
**Day 584** | Week 84, Day 3 | Year 1, Month 21 | The Clifford Group and Stabilizer Formalism

Today we study the Clifford group—a special class of quantum gates that map Pauli operators to Pauli operators. These gates are efficiently simulable classically but form the foundation of fault-tolerant quantum computing.

---

## Learning Objectives

1. Define the Clifford group mathematically
2. Identify Clifford generators: H, S, CNOT
3. Understand the Gottesman-Knill theorem (classical simulability)
4. Introduce the stabilizer formalism
5. Explain why Clifford gates are NOT universal
6. Connect Clifford gates to quantum error correction

---

## Core Content

### The Pauli Group

**Definition:** The **Pauli group** on $n$ qubits is:
$$\mathcal{P}_n = \{\pm 1, \pm i\} \times \{I, X, Y, Z\}^{\otimes n}$$

For $n = 1$:
$$\mathcal{P}_1 = \{\pm I, \pm iI, \pm X, \pm iX, \pm Y, \pm iY, \pm Z, \pm iZ\}$$

**Properties:**
- $|\mathcal{P}_n| = 4 \cdot 4^n$
- Pauli matrices square to $I$
- Paulis either commute or anticommute

### The Clifford Group

**Definition:** The **Clifford group** $\mathcal{C}_n$ is the normalizer of the Pauli group:
$$\boxed{\mathcal{C}_n = \{U : UPU^\dagger \in \mathcal{P}_n \text{ for all } P \in \mathcal{P}_n\}}$$

In other words: Clifford gates map Pauli operators to Pauli operators (up to phase).

### Clifford Generators

**Theorem:** The Clifford group is generated by:

$$\{H, S, CNOT\}$$

**Action on Paulis:**

| Gate | X → | Y → | Z → |
|------|-----|-----|-----|
| H | Z | -Y | X |
| S | Y | -X | Z |

For CNOT (control on 1, target on 2):
$$X_1 \to X_1 X_2, \quad Z_1 \to Z_1$$
$$X_2 \to X_2, \quad Z_2 \to Z_1 Z_2$$

### Why Clifford Gates Are Special

**1. Finite group of transformations:**
On $n$ qubits, $|\mathcal{C}_n|$ is finite (though large):
$$|\mathcal{C}_n| = 2^{n^2+2n} \prod_{j=1}^{n}(4^j - 1)$$

**2. Pauli tracking:**
Instead of tracking the full state, track how Paulis transform:
- $n$-qubit Clifford: specified by $2n \times 2n$ binary matrix
- Efficient classical description!

**3. Stabilizer states:**
Clifford gates map computational basis states to "stabilizer states."

### The Gottesman-Knill Theorem

**Theorem (Gottesman-Knill):** A quantum circuit consisting of:
1. Preparation of $|0\rangle^{\otimes n}$
2. Clifford gates
3. Measurement in computational basis
4. Classical feedforward

can be **efficiently simulated classically** in polynomial time.

$$\boxed{\text{Clifford circuits} \subseteq \text{BPP (classical)}}$$

### Why This Matters

**Clifford gates are NOT universal!**

The Gottesman-Knill theorem shows Clifford circuits can't provide quantum speedup. We need **non-Clifford gates** (like T) for universal QC.

### Stabilizer Formalism

**Definition:** A **stabilizer state** is a state $|\psi\rangle$ such that:
$$S|\psi\rangle = |\psi\rangle \text{ for all } S \in \mathcal{S}$$

where $\mathcal{S}$ is an abelian subgroup of $\mathcal{P}_n$ (the **stabilizer group**).

**Example:** $|0\rangle$ is stabilized by $\{I, Z\}$.

**Example:** $|\Phi^+\rangle$ is stabilized by $\{I \otimes I, X \otimes X, Z \otimes Z, -Y \otimes Y\}$.

### Key Properties of Stabilizer States

1. **Unique state:** An $n$-qubit stabilizer group with $2^n$ elements determines a unique state
2. **Compact representation:** Only $n$ independent generators needed
3. **Clifford evolution:** $U|\psi\rangle$ has stabilizer $USU^\dagger$
4. **Measurement:** Pauli measurement on stabilizer states efficiently computable

### Stabilizer Tableau

**Efficient representation:** Store the $n$ generators as a tableau:

For $n$ qubits, each generator is a Pauli string $\pm P_1 \otimes P_2 \otimes \cdots \otimes P_n$.

**Tableau:** $(2n + 1) \times 2n$ binary matrix + phase bits.

### Common Stabilizer States

| State | Stabilizer Generators |
|-------|----------------------|
| $\|0\rangle$ | $Z$ |
| $\|1\rangle$ | $-Z$ |
| $\|+\rangle$ | $X$ |
| $\|-\rangle$ | $-X$ |
| $\|\Phi^+\rangle$ | $XX$, $ZZ$ |
| $\|GHZ_n\rangle$ | $X^{\otimes n}$, $Z_1Z_2$, $Z_2Z_3$, ..., $Z_{n-1}Z_n$ |

### Clifford Group Size

**For $n$ qubits:**
$$|\mathcal{C}_n| = 2^{n^2+2n} \prod_{j=1}^{n}(4^j - 1)$$

| $n$ | $\|\mathcal{C}_n\|$ |
|-----|---------------------|
| 1 | 24 |
| 2 | 11,520 |
| 3 | 92,897,280 |

### Single-Qubit Clifford Group

**$\mathcal{C}_1$** has 24 elements (isomorphic to $S_4$, symmetric group on 4 elements).

**Generators:** H, S

**All single-qubit Cliffords:** Products of H and S of length ≤ 4.

### Why Clifford Gates Matter for QEC

1. **Syndrome extraction:** Use Clifford circuits
2. **Logical Cliffords:** Often transversal (easy to fault-tolerantly implement)
3. **Stabilizer codes:** Defined using stabilizer formalism
4. **Magic state injection:** Use Clifford + T for universality

---

## Worked Examples

### Example 1: Verifying Clifford Action

Show that $H$ is Clifford by computing $HXH^\dagger$ and $HZH^\dagger$.

**Solution:**

$$HXH^\dagger = HXH = \frac{1}{2}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}\begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}$$

$$= \frac{1}{2}\begin{pmatrix} 1 & 1 \\ 1 & -1 \end{pmatrix}\begin{pmatrix} 1 & -1 \\ 1 & 1 \end{pmatrix} = \frac{1}{2}\begin{pmatrix} 2 & 0 \\ 0 & -2 \end{pmatrix} = Z$$

$$HZH^\dagger = HZH = X$$ (similar calculation)

Since $X$ and $Z$ map to $Z$ and $X$ (both Paulis), $H$ is Clifford.

### Example 2: Stabilizer of Bell State

Find the stabilizer group of $|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle + |11\rangle)$.

**Solution:**

Check which Paulis stabilize $|\Phi^+\rangle$:

**$X \otimes X$:**
$$(X \otimes X)|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|11\rangle + |00\rangle) = |\Phi^+\rangle \checkmark$$

**$Z \otimes Z$:**
$$(Z \otimes Z)|\Phi^+\rangle = \frac{1}{\sqrt{2}}(|00\rangle + (-1)(-1)|11\rangle) = |\Phi^+\rangle \checkmark$$

**$Y \otimes Y$:**
$$(Y \otimes Y)|\Phi^+\rangle = (iXZ \otimes iXZ)|\Phi^+\rangle = -(XZ \otimes XZ)|\Phi^+\rangle$$
$$= -(X \otimes X)(Z \otimes Z)|\Phi^+\rangle = -|\Phi^+\rangle$$

So $-Y \otimes Y$ stabilizes $|\Phi^+\rangle$.

**Stabilizer group:** $\langle XX, ZZ \rangle = \{I \otimes I, XX, ZZ, -YY\}$

### Example 3: T is NOT Clifford

Show that $T$ is not in the Clifford group.

**Solution:**

Check $TXT^\dagger$:

$$T = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix}$$

$$TXT^\dagger = \begin{pmatrix} 1 & 0 \\ 0 & e^{i\pi/4} \end{pmatrix}\begin{pmatrix} 0 & 1 \\ 1 & 0 \end{pmatrix}\begin{pmatrix} 1 & 0 \\ 0 & e^{-i\pi/4} \end{pmatrix}$$

$$= \begin{pmatrix} 0 & e^{-i\pi/4} \\ e^{i\pi/4} & 0 \end{pmatrix}$$

This is NOT a Pauli matrix (not $\pm X$, $\pm iX$, etc.)

Therefore, **T is not Clifford**.

---

## Practice Problems

### Problem 1: Clifford Verification
Verify that $S = \begin{pmatrix} 1 & 0 \\ 0 & i \end{pmatrix}$ is Clifford by computing $SXS^\dagger$ and $SZS^\dagger$.

### Problem 2: Stabilizer Evolution
The state $|+\rangle$ has stabilizer $X$. What is the stabilizer of $S|+\rangle$?

### Problem 3: CNOT Action
Verify that CNOT maps $X_1 \to X_1 X_2$ and $Z_2 \to Z_1 Z_2$.

### Problem 4: Counting
How many stabilizer states exist on 2 qubits? (Hint: count cosets)

---

## Computational Lab

```python
"""Day 584: Clifford Gates and Stabilizer Formalism"""
import numpy as np
from itertools import product

# Pauli matrices
I = np.eye(2, dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)

# Clifford generators
H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
S = np.array([[1, 0], [0, 1j]], dtype=complex)

CNOT = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
], dtype=complex)

PAULIS_1Q = {'I': I, 'X': X, 'Y': Y, 'Z': Z}

def tensor(A, B):
    return np.kron(A, B)

def is_pauli(M, tol=1e-10):
    """Check if M is (proportional to) a Pauli matrix"""
    for phase in [1, -1, 1j, -1j]:
        for name, P in PAULIS_1Q.items():
            if np.allclose(M, phase * P, atol=tol):
                return True, phase, name
    return False, None, None

def conjugate(U, P):
    """Compute U P U^dagger"""
    return U @ P @ np.conj(U.T)

# ===== Example 1: Verify Clifford generators =====
print("=" * 60)
print("Example 1: Clifford Action on Paulis")
print("=" * 60)

print("\nHadamard gate H:")
for name, P in PAULIS_1Q.items():
    result = conjugate(H, P)
    is_p, phase, pname = is_pauli(result)
    phase_str = {1: '+', -1: '-', 1j: '+i', -1j: '-i'}.get(phase, '?')
    print(f"  H {name} H^dag = {phase_str}{pname}")

print("\nS gate:")
for name, P in PAULIS_1Q.items():
    result = conjugate(S, P)
    is_p, phase, pname = is_pauli(result)
    phase_str = {1: '+', -1: '-', 1j: '+i', -1j: '-i'}.get(phase, '?')
    print(f"  S {name} S^dag = {phase_str}{pname}")

# ===== Example 2: T is NOT Clifford =====
print("\n" + "=" * 60)
print("Example 2: T Gate is NOT Clifford")
print("=" * 60)

T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)

print("\nT gate action:")
for name, P in PAULIS_1Q.items():
    result = conjugate(T, P)
    is_p, phase, pname = is_pauli(result)
    if is_p:
        print(f"  T {name} T^dag = Pauli ({pname})")
    else:
        print(f"  T {name} T^dag = NOT a Pauli!")
        print(f"    Result:\n{np.round(result, 4)}")

# ===== Example 3: Stabilizer States =====
print("\n" + "=" * 60)
print("Example 3: Stabilizer States")
print("=" * 60)

def stabilizes(op, state, tol=1e-10):
    """Check if op stabilizes state (eigenvalue +1)"""
    result = op @ state
    return np.allclose(result, state, atol=tol)

# |+⟩ state
plus = np.array([1, 1], dtype=complex) / np.sqrt(2)
print("\n|+⟩ stabilizers:")
for name, P in PAULIS_1Q.items():
    for phase in [1, -1]:
        if stabilizes(phase * P, plus):
            print(f"  {'+' if phase > 0 else '-'}{name}")

# Bell state |Φ+⟩
phi_plus = np.array([1, 0, 0, 1], dtype=complex) / np.sqrt(2)
print("\n|Φ+⟩ stabilizers:")
paulis_2q = {}
for n1, P1 in PAULIS_1Q.items():
    for n2, P2 in PAULIS_1Q.items():
        paulis_2q[n1 + n2] = tensor(P1, P2)

for name, P in paulis_2q.items():
    for phase in [1, -1]:
        if stabilizes(phase * P, phi_plus):
            if name != 'II':  # Skip identity
                print(f"  {'+' if phase > 0 else '-'}{name}")

# ===== Example 4: CNOT Action on Paulis =====
print("\n" + "=" * 60)
print("Example 4: CNOT Action on Paulis")
print("=" * 60)

print("\nCNOT action (control q1, target q2):")
# Track X1, Z1, X2, Z2
for name, P in [('X1', tensor(X, I)), ('Z1', tensor(Z, I)),
                ('X2', tensor(I, X)), ('Z2', tensor(I, Z))]:
    result = conjugate(CNOT, P)

    # Find what Pauli this is
    for n1 in 'IXYZ':
        for n2 in 'IXYZ':
            P2 = tensor(PAULIS_1Q[n1], PAULIS_1Q[n2])
            for phase in [1, -1, 1j, -1j]:
                if np.allclose(result, phase * P2):
                    phase_str = {1: '', -1: '-', 1j: 'i', -1j: '-i'}[phase]
                    print(f"  {name} -> {phase_str}{n1}{n2}")
                    break

# ===== Example 5: Enumerate Single-Qubit Cliffords =====
print("\n" + "=" * 60)
print("Example 5: Single-Qubit Clifford Group")
print("=" * 60)

def matrix_hash(M, precision=4):
    """Create hashable representation of matrix"""
    # Normalize by first non-zero element to handle global phase
    for i in range(M.size):
        if np.abs(M.flat[i]) > 1e-10:
            M = M / (M.flat[i] / np.abs(M.flat[i]))
            break
    return tuple(np.round(M.flatten(), precision).tolist())

# Generate all products of H and S up to length 6
clifford_1q = set()
current = {matrix_hash(I): I}
clifford_1q.add(matrix_hash(I))

for length in range(1, 7):
    new_current = {}
    for h, U in current.items():
        for G in [H, S]:
            V = G @ U
            hV = matrix_hash(V)
            if hV not in clifford_1q:
                clifford_1q.add(hV)
                new_current[hV] = V
    current = new_current
    print(f"Length <= {length}: {len(clifford_1q)} elements")

print(f"\nTotal single-qubit Cliffords: {len(clifford_1q)}")
print("(Should be 24)")

# ===== Example 6: Gottesman-Knill Implications =====
print("\n" + "=" * 60)
print("Example 6: Gottesman-Knill Theorem")
print("=" * 60)

print("""
GOTTESMAN-KNILL THEOREM:
Clifford circuits on stabilizer states are efficiently simulable.

Simulation procedure:
1. Start with n-qubit stabilizer tableau (n generators)
2. Apply Clifford gates: update tableau in O(n) time per gate
3. Measure: update tableau in O(n²) time

Total: O(n² × circuit_size) time

CONSEQUENCE:
- Clifford circuits cannot provide quantum speedup
- Need non-Clifford gates (T, Toffoli, etc.) for universality
""")

# Demonstrate stabilizer evolution
print("Example: Evolve |00⟩ through H₁, CNOT")
print("\n|00⟩ stabilizers: Z₁, Z₂")

# After H on qubit 1: stabilizers become X₁, Z₂
print("After H₁: stabilizers become X₁ (from Z₁), Z₂")

# After CNOT(1,2): X₁ -> X₁X₂, Z₂ -> Z₁Z₂
print("After CNOT: stabilizers become X₁X₂, Z₁Z₂")

# This is |Φ+⟩!
print("\nFinal stabilizers: {X₁X₂, Z₁Z₂} → This is |Φ+⟩!")

# ===== Summary =====
print("\n" + "=" * 60)
print("Clifford Gates Summary")
print("=" * 60)
print("""
CLIFFORD GROUP:
- Definition: C = {U : UPU^† ∈ Pauli for all P ∈ Pauli}
- Generators: {H, S, CNOT}
- Size: |C_n| = 2^(n²+2n) ∏(4^j - 1)

KEY PROPERTIES:
1. Map Paulis to Paulis
2. Map stabilizer states to stabilizer states
3. Efficiently classically simulable (Gottesman-Knill)
4. NOT universal for quantum computation

STABILIZER FORMALISM:
- State specified by abelian group of stabilizing Paulis
- n-qubit state: n independent generators
- Clifford evolution: conjugate generators

WHY IMPORTANT:
- Foundation of quantum error correction
- Logical Cliffords often transversal
- Clifford + T = universal
""")
```

---

## Summary

### Clifford Group

| Property | Description |
|----------|-------------|
| Definition | $\mathcal{C}_n = \{U : UPU^\dagger \in \mathcal{P}_n\}$ |
| Generators | {H, S, CNOT} |
| Size | $2^{n^2+2n} \prod_{j=1}^{n}(4^j - 1)$ |
| Single-qubit | 24 elements |

### Key Formulas

| Gate | X → | Z → |
|------|-----|-----|
| H | Z | X |
| S | Y | Z |
| CNOT | $X_1 \to X_1X_2$ | $Z_2 \to Z_1Z_2$ |

### Key Takeaways

1. **Clifford gates** normalize the Pauli group
2. **Stabilizer states** are efficiently described by Pauli generators
3. **Gottesman-Knill theorem:** Clifford circuits are classically simulable
4. **Clifford gates are NOT universal** — need T gate (or similar)
5. **Stabilizer formalism** is crucial for quantum error correction
6. **Efficient tracking:** Paulis instead of full state vectors

---

## Daily Checklist

- [ ] I can define the Clifford group
- [ ] I know the Clifford generators {H, S, CNOT}
- [ ] I understand why T is not Clifford
- [ ] I can find stabilizers of simple states
- [ ] I understand the Gottesman-Knill theorem
- [ ] I ran the computational lab and explored Clifford action

---

*Next: Day 585 — Clifford+T*

# Day 564: Rotation Gates (Rx, Ry, Rz)

## Schedule Overview

| Session | Time | Focus |
|---------|------|-------|
| Morning | 3 hours | Theory: Rotation gate derivation, exponential form |
| Afternoon | 2.5 hours | Problem solving: Rotation calculations and identities |
| Evening | 1.5 hours | Computational lab: Continuous rotations simulation |

## Learning Objectives

By the end of today, you will be able to:

1. **Derive rotation gates** from the exponential map $R_j(\theta) = e^{-i\theta\sigma_j/2}$
2. **Write explicit matrix forms** of Rx(θ), Ry(θ), Rz(θ)
3. **Connect discrete gates** (X, Y, Z, S, T) to specific rotation angles
4. **Apply the Rodrigues formula** for matrix exponentials of Pauli matrices
5. **Compose rotations** using multiplication and understand ordering
6. **Implement continuous gate parameterization** for variational algorithms

---

## Core Content

### 1. From Generators to Rotations

In quantum mechanics, unitary transformations are generated by Hermitian operators through exponentiation:

$$U = e^{-iHt/\hbar}$$

For single-qubit rotations, the Pauli matrices serve as **generators**:

$$\boxed{R_j(\theta) = e^{-i\theta\sigma_j/2}}$$

where j ∈ {x, y, z} and θ is the rotation angle.

**Physical interpretation:** $R_j(\theta)$ rotates the qubit state by angle θ about the j-axis of the Bloch sphere.

### 2. The Rodrigues Formula

For any matrix A satisfying $A^2 = I$, we have:

$$e^{i\phi A} = \cos\phi \cdot I + i\sin\phi \cdot A$$

Since $\sigma_j^2 = I$ for all Pauli matrices, we can write:

$$\boxed{R_j(\theta) = e^{-i\theta\sigma_j/2} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}\sigma_j}$$

This is the **Rodrigues formula** for qubit rotations.

**Derivation:**
$$e^{-i\theta\sigma_j/2} = \sum_{n=0}^{\infty} \frac{1}{n!}\left(-i\frac{\theta}{2}\sigma_j\right)^n$$

Separating even and odd terms, using $\sigma_j^{2k} = I$ and $\sigma_j^{2k+1} = \sigma_j$:
$$= \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k)!}\left(\frac{\theta}{2}\right)^{2k}I + \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)!}\left(\frac{\theta}{2}\right)^{2k+1}(-i\sigma_j)$$
$$= \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}\sigma_j$$

### 3. Explicit Matrix Forms

#### Rx(θ): Rotation about X-axis

$$\boxed{R_x(\theta) = \begin{pmatrix} \cos\frac{\theta}{2} & -i\sin\frac{\theta}{2} \\ -i\sin\frac{\theta}{2} & \cos\frac{\theta}{2} \end{pmatrix}}$$

**Action on basis states:**
$$R_x(\theta)|0\rangle = \cos\frac{\theta}{2}|0\rangle - i\sin\frac{\theta}{2}|1\rangle$$
$$R_x(\theta)|1\rangle = -i\sin\frac{\theta}{2}|0\rangle + \cos\frac{\theta}{2}|1\rangle$$

**Special cases:**
- $R_x(0) = I$
- $R_x(\pi) = -iX$
- $R_x(2\pi) = -I$ (returns with global phase!)

#### Ry(θ): Rotation about Y-axis

$$\boxed{R_y(\theta) = \begin{pmatrix} \cos\frac{\theta}{2} & -\sin\frac{\theta}{2} \\ \sin\frac{\theta}{2} & \cos\frac{\theta}{2} \end{pmatrix}}$$

**Action on basis states:**
$$R_y(\theta)|0\rangle = \cos\frac{\theta}{2}|0\rangle + \sin\frac{\theta}{2}|1\rangle$$
$$R_y(\theta)|1\rangle = -\sin\frac{\theta}{2}|0\rangle + \cos\frac{\theta}{2}|1\rangle$$

**Note:** Ry(θ) has **real** matrix elements! This makes it special for creating amplitude superpositions.

**Special cases:**
- $R_y(\pi/2)|0\rangle = \frac{1}{\sqrt{2}}(|0\rangle + |1\rangle) = |+\rangle$
- $R_y(\pi) = -iY$

#### Rz(θ): Rotation about Z-axis

$$\boxed{R_z(\theta) = \begin{pmatrix} e^{-i\theta/2} & 0 \\ 0 & e^{i\theta/2} \end{pmatrix}}$$

**Action on basis states:**
$$R_z(\theta)|0\rangle = e^{-i\theta/2}|0\rangle$$
$$R_z(\theta)|1\rangle = e^{i\theta/2}|1\rangle$$

**Relation to phase gate:**
$$P(\phi) = e^{i\phi/2}R_z(\phi)$$

**Special cases:**
- $R_z(\pi) = -iZ$
- $R_z(\pi/2) = e^{-i\pi/4}S$
- $R_z(\pi/4) = e^{-i\pi/8}T$

### 4. Connection to Discrete Gates

The Pauli gates are π rotations (up to global phase):

| Gate | As Rotation | Global Phase |
|------|-------------|--------------|
| X | $R_x(\pi)$ | $X = iR_x(\pi)$ |
| Y | $R_y(\pi)$ | $Y = iR_y(\pi)$ |
| Z | $R_z(\pi)$ | $Z = iR_z(\pi)$ |
| S | $R_z(\pi/2)$ | $S = e^{i\pi/4}R_z(\pi/2)$ |
| T | $R_z(\pi/4)$ | $T = e^{i\pi/8}R_z(\pi/4)$ |
| H | $R_y(\pi/2)R_z(\pi)$ | up to phase |

### 5. Properties of Rotation Gates

**Unitarity:**
$$R_j(\theta)^\dagger R_j(\theta) = I$$
$$R_j(\theta)^{-1} = R_j(-\theta)$$

**Composition along same axis:**
$$\boxed{R_j(\theta_1)R_j(\theta_2) = R_j(\theta_1 + \theta_2)}$$

Rotations about the same axis commute and combine additively!

**Non-commutativity for different axes:**
$$R_x(\theta)R_y(\phi) \neq R_y(\phi)R_x(\theta) \text{ in general}$$

**Periodicity:**
$$R_j(4\pi) = I \text{ (identity)}$$
$$R_j(2\pi) = -I \text{ (minus identity)}$$

The factor of 2 reflects the **spin-1/2 nature** of qubits!

### 6. The 4π Periodicity (Spinor Nature)

A single rotation by 2π gives $R_j(2\pi) = -I$, not I!

This means:
- A 360° rotation picks up a **global phase of -1**
- Only a 720° (4π) rotation returns exactly to the original state

This is the famous **spinor behavior** of spin-1/2 particles, experimentally verified in neutron interferometry.

### 7. Rotation about Arbitrary Axis

For a unit vector $\hat{n} = (n_x, n_y, n_z)$, define:

$$\hat{n} \cdot \vec{\sigma} = n_x X + n_y Y + n_z Z$$

The rotation by angle θ about axis $\hat{n}$ is:

$$\boxed{R_{\hat{n}}(\theta) = e^{-i\theta(\hat{n}\cdot\vec{\sigma})/2} = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}(\hat{n}\cdot\vec{\sigma})}$$

**Explicit matrix:**
$$R_{\hat{n}}(\theta) = \begin{pmatrix} \cos\frac{\theta}{2} - in_z\sin\frac{\theta}{2} & (-in_x - n_y)\sin\frac{\theta}{2} \\ (-in_x + n_y)\sin\frac{\theta}{2} & \cos\frac{\theta}{2} + in_z\sin\frac{\theta}{2} \end{pmatrix}$$

### 8. Rotation Composition (Non-commutative)

When composing rotations about different axes, order matters!

For small angles (first-order approximation):
$$R_x(\epsilon)R_y(\epsilon) \approx I - i\frac{\epsilon}{2}(X + Y) - \frac{\epsilon^2}{4}XY$$
$$R_y(\epsilon)R_x(\epsilon) \approx I - i\frac{\epsilon}{2}(X + Y) - \frac{\epsilon^2}{4}YX$$

The difference is:
$$R_x(\epsilon)R_y(\epsilon) - R_y(\epsilon)R_x(\epsilon) \approx -\frac{\epsilon^2}{4}[X, Y] = -\frac{i\epsilon^2}{2}Z$$

This relates to the **Lie algebra structure** of SU(2).

### 9. Applications in Variational Quantum Algorithms

In variational quantum eigensolvers (VQE) and quantum machine learning:

**Parameterized circuits** use rotation gates with trainable angles:
$$U(\vec{\theta}) = \prod_i R_{j_i}(\theta_i)$$

**Gradient computation:** The parameter-shift rule:
$$\frac{\partial}{\partial\theta}\langle\psi|R_j(\theta)^\dagger O R_j(\theta)|\psi\rangle = \frac{1}{2}\left[\langle O\rangle_{\theta+\pi/2} - \langle O\rangle_{\theta-\pi/2}\right]$$

### 10. Native Gates on Real Hardware

Physical quantum computers have **native gates** determined by their control mechanisms:

| Platform | Native Rotations |
|----------|------------------|
| Superconducting (IBM, Google) | Rz(θ), √X, CNOT |
| Trapped ions | R(θ,φ), MS gate |
| Photonics | Beam splitters, phase shifts |
| Neutral atoms | Rabi rotations |

All other gates must be decomposed into these native operations!

---

## Quantum Computing Connection

Rotation gates bridge discrete and continuous quantum computing:

1. **Gate synthesis:** Any U ∈ SU(2) can be approximated by discrete gates (Solovay-Kitaev theorem)
2. **Variational algorithms:** Continuous parameters enable optimization
3. **Analog quantum simulation:** Direct implementation of time evolution
4. **Error analysis:** Small rotation errors compound in circuits

---

## Worked Examples

### Example 1: Verify Rodrigues Formula for Rx

**Problem:** Show that $e^{-i\theta X/2} = \cos(\theta/2)I - i\sin(\theta/2)X$.

**Solution:**

Starting from the Taylor series:
$$e^{-i\theta X/2} = \sum_{n=0}^{\infty} \frac{(-i\theta/2)^n}{n!}X^n$$

Since $X^2 = I$:
- Even powers: $X^{2k} = I$
- Odd powers: $X^{2k+1} = X$

$$= \sum_{k=0}^{\infty} \frac{(-i\theta/2)^{2k}}{(2k)!}I + \sum_{k=0}^{\infty} \frac{(-i\theta/2)^{2k+1}}{(2k+1)!}X$$

$$= \sum_{k=0}^{\infty} \frac{(-1)^k(\theta/2)^{2k}}{(2k)!}I - i\sum_{k=0}^{\infty} \frac{(-1)^k(\theta/2)^{2k+1}}{(2k+1)!}X$$

$$= \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}X \checkmark$$

### Example 2: Ry Creates Superposition

**Problem:** Find the angle θ such that $R_y(\theta)|0\rangle = \frac{1}{\sqrt{3}}|0\rangle + \sqrt{\frac{2}{3}}|1\rangle$.

**Solution:**

From the Ry formula:
$$R_y(\theta)|0\rangle = \cos\frac{\theta}{2}|0\rangle + \sin\frac{\theta}{2}|1\rangle$$

Matching coefficients:
$$\cos\frac{\theta}{2} = \frac{1}{\sqrt{3}}, \quad \sin\frac{\theta}{2} = \sqrt{\frac{2}{3}}$$

Verify: $\cos^2(\theta/2) + \sin^2(\theta/2) = \frac{1}{3} + \frac{2}{3} = 1$ ✓

Therefore:
$$\frac{\theta}{2} = \arctan\left(\sqrt{2}\right) \approx 0.9553 \text{ rad}$$
$$\theta = 2\arctan(\sqrt{2}) \approx 1.911 \text{ rad} \approx 109.5°$$

### Example 3: Composition of Rotations

**Problem:** Simplify $R_z(\pi)R_y(\pi/2)R_z(\pi)$.

**Solution:**

Using the conjugation property: $R_z(\pi) = -iZ$ (up to phase), and $ZYZ = -Y$:

$$R_z(\pi)R_y(\pi/2)R_z(\pi) = (-iZ)\left(\cos\frac{\pi}{4}I - i\sin\frac{\pi}{4}Y\right)(-iZ)$$

Since Z commutes with I and ZYZ = -Y:
$$= (-i)(-i)Z \cdot \left(\cos\frac{\pi}{4}I - i\sin\frac{\pi}{4}Y\right) \cdot Z$$
$$= -1 \cdot \left(\cos\frac{\pi}{4}I + i\sin\frac{\pi}{4}Y\right)$$
$$= -R_y(-\pi/2)$$

This is rotation by -π/2 about Y (up to global phase).

---

## Practice Problems

### Direct Application

1. Compute $R_x(\pi/2)|+\rangle$ explicitly.

2. Verify that $R_z(\pi/2) = e^{-i\pi/4}S$ by computing both sides.

3. Show that $R_y(\pi)|0\rangle = |1\rangle$ (up to global phase).

### Intermediate

4. **Commutator:** Compute $[R_x(\theta), R_z(\phi)]$ for small θ, φ to first order.

5. Prove that $R_{\hat{n}}(\theta)R_{\hat{n}}(\phi) = R_{\hat{n}}(\theta + \phi)$ using the Rodrigues formula.

6. The **Hadamard** gate can be written as $H = e^{i\pi/2}R_y(\pi/2)R_z(\pi)$. Verify this identity.

### Challenging

7. **Euler decomposition preview:** Show that any rotation $R_{\hat{n}}(\theta)$ can be written as $R_z(\alpha)R_y(\beta)R_z(\gamma)$ for some angles α, β, γ. Find these angles in terms of θ and $\hat{n}$.

8. **Parameter-shift rule:** For $f(\theta) = \langle 0|R_y(\theta)^\dagger Z R_y(\theta)|0\rangle$, compute $\frac{df}{d\theta}$ both analytically and using the parameter-shift rule.

9. **Spin-1/2 behavior:** A spin-1/2 particle undergoes rotation. Show mathematically why a 2π rotation gives a -1 phase factor, while a 4π rotation returns to exactly the original state.

---

## Computational Lab: Rotation Gates Simulation

```python
"""
Day 564: Rotation Gates Simulation
Exploring Rx, Ry, Rz gates and their properties
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Pauli matrices
I = np.eye(2, dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)

# Rotation gates
def Rx(theta):
    """Rotation about X-axis."""
    return np.cos(theta/2) * I - 1j * np.sin(theta/2) * X

def Ry(theta):
    """Rotation about Y-axis."""
    return np.cos(theta/2) * I - 1j * np.sin(theta/2) * Y

def Rz(theta):
    """Rotation about Z-axis."""
    return np.cos(theta/2) * I - 1j * np.sin(theta/2) * Z

def Rn(theta, n):
    """Rotation about arbitrary axis n = (nx, ny, nz)."""
    n = np.array(n) / np.linalg.norm(n)  # Normalize
    n_dot_sigma = n[0]*X + n[1]*Y + n[2]*Z
    return np.cos(theta/2) * I - 1j * np.sin(theta/2) * n_dot_sigma

# Basis states
ket_0 = np.array([[1], [0]], dtype=complex)
ket_1 = np.array([[0], [1]], dtype=complex)

print("=" * 60)
print("ROTATION GATES: FUNDAMENTAL PROPERTIES")
print("=" * 60)

# 1. Verify Rodrigues formula
print("\n1. Verify Rodrigues Formula:")
theta_test = np.pi / 3  # 60 degrees

# Direct exponentiation
def matrix_exp_pauli(theta, sigma):
    """Compute e^(-i*theta*sigma/2) using eigendecomposition."""
    eigenvalues, eigenvectors = np.linalg.eig(sigma)
    D = np.diag(np.exp(-1j * theta/2 * eigenvalues))
    return eigenvectors @ D @ np.linalg.inv(eigenvectors)

Rx_direct = matrix_exp_pauli(theta_test, X)
Rx_rodrigues = Rx(theta_test)
print(f"   Rx({theta_test:.3f}) via eigendecomposition matches Rodrigues: {np.allclose(Rx_direct, Rx_rodrigues)}")

# 2. Explicit matrix forms
print("\n2. Explicit Matrix Forms (θ = π/3):")
print(f"   Rx(π/3) = \n{Rx(np.pi/3)}")
print(f"\n   Ry(π/3) = \n{Ry(np.pi/3)}")
print(f"\n   Rz(π/3) = \n{Rz(np.pi/3)}")

# 3. Connection to Pauli gates
print("\n3. Connection to Pauli Gates (π rotations):")
print(f"   iRx(π) = X: {np.allclose(1j * Rx(np.pi), X)}")
print(f"   iRy(π) = Y: {np.allclose(1j * Ry(np.pi), Y)}")
print(f"   iRz(π) = Z: {np.allclose(1j * Rz(np.pi), Z)}")

# 4. Connection to phase gates
S = np.array([[1, 0], [0, 1j]], dtype=complex)
T = np.array([[1, 0], [0, np.exp(1j*np.pi/4)]], dtype=complex)

print("\n4. Connection to Phase Gates:")
print(f"   e^(iπ/4)·Rz(π/2) = S: {np.allclose(np.exp(1j*np.pi/4) * Rz(np.pi/2), S)}")
print(f"   e^(iπ/8)·Rz(π/4) = T: {np.allclose(np.exp(1j*np.pi/8) * Rz(np.pi/4), T)}")

# 5. Composition along same axis
print("\n5. Composition Along Same Axis:")
theta1, theta2 = np.pi/4, np.pi/6
print(f"   Rx({theta1:.3f})·Rx({theta2:.3f}) = Rx({theta1+theta2:.3f}): {np.allclose(Rx(theta1) @ Rx(theta2), Rx(theta1+theta2))}")
print(f"   Ry({theta1:.3f})·Ry({theta2:.3f}) = Ry({theta1+theta2:.3f}): {np.allclose(Ry(theta1) @ Ry(theta2), Ry(theta1+theta2))}")
print(f"   Rz({theta1:.3f})·Rz({theta2:.3f}) = Rz({theta1+theta2:.3f}): {np.allclose(Rz(theta1) @ Rz(theta2), Rz(theta1+theta2))}")

# 6. Non-commutativity
print("\n6. Non-Commutativity (Different Axes):")
print(f"   Rx(π/4)·Ry(π/4) = Ry(π/4)·Rx(π/4): {np.allclose(Rx(np.pi/4) @ Ry(np.pi/4), Ry(np.pi/4) @ Rx(np.pi/4))}")
print(f"   The commutator is non-zero!")
commutator = Rx(np.pi/4) @ Ry(np.pi/4) - Ry(np.pi/4) @ Rx(np.pi/4)
print(f"   ||[Rx, Ry]|| = {np.linalg.norm(commutator):.4f}")

# 7. 2π and 4π periodicity
print("\n7. Spinor Periodicity:")
print(f"   Rx(2π) = -I: {np.allclose(Rx(2*np.pi), -I)}")
print(f"   Rx(4π) = +I: {np.allclose(Rx(4*np.pi), I)}")
print(f"   This is spin-1/2 (spinor) behavior!")

# 8. Unitarity
print("\n8. Unitarity Verification:")
print(f"   Rx(θ)†·Rx(θ) = I: {np.allclose(Rx(theta_test).conj().T @ Rx(theta_test), I)}")
print(f"   Rx(θ)^(-1) = Rx(-θ): {np.allclose(np.linalg.inv(Rx(theta_test)), Rx(-theta_test))}")

# Visualization
print("\n" + "=" * 60)
print("BLOCH SPHERE VISUALIZATION")
print("=" * 60)

def state_to_bloch(psi):
    """Convert pure state to Bloch coordinates."""
    psi = psi.flatten()
    rho = np.outer(psi, psi.conj())
    x = np.real(np.trace(X @ rho))
    y = np.real(np.trace(Y @ rho))
    z = np.real(np.trace(Z @ rho))
    return np.array([x, y, z])

fig = plt.figure(figsize=(15, 5))

# Draw Bloch sphere wireframe helper
def draw_bloch_sphere(ax):
    u = np.linspace(0, 2 * np.pi, 30)
    v = np.linspace(0, np.pi, 20)
    xs = np.outer(np.cos(u), np.sin(v))
    ys = np.outer(np.sin(u), np.sin(v))
    zs = np.outer(np.ones(np.size(u)), np.cos(v))
    ax.plot_wireframe(xs, ys, zs, alpha=0.1, color='gray')

    # Axes
    ax.quiver(0, 0, 0, 1.3, 0, 0, color='r', alpha=0.3, arrow_length_ratio=0.1)
    ax.quiver(0, 0, 0, 0, 1.3, 0, color='g', alpha=0.3, arrow_length_ratio=0.1)
    ax.quiver(0, 0, 0, 0, 0, 1.3, color='b', alpha=0.3, arrow_length_ratio=0.1)
    ax.text(1.4, 0, 0, 'X', fontsize=10)
    ax.text(0, 1.4, 0, 'Y', fontsize=10)
    ax.text(0, 0, 1.4, 'Z', fontsize=10)

# Plot 1: Rx rotations
ax1 = fig.add_subplot(131, projection='3d')
draw_bloch_sphere(ax1)

# Start from |0⟩ and apply Rx with increasing angles
initial = ket_0
angles = np.linspace(0, 2*np.pi, 50)
trajectory_x = []
for theta in angles:
    state = Rx(theta) @ initial
    bloch = state_to_bloch(state)
    trajectory_x.append(bloch)
trajectory_x = np.array(trajectory_x)

ax1.plot(trajectory_x[:, 0], trajectory_x[:, 1], trajectory_x[:, 2], 'b-', linewidth=2, label='Rx trajectory')
ax1.scatter([0], [0], [1], c='green', s=100, marker='*', label='Start |0⟩')
ax1.set_title('Rx(θ) from |0⟩\n(rotation about X-axis)')
ax1.legend()

# Plot 2: Ry rotations
ax2 = fig.add_subplot(132, projection='3d')
draw_bloch_sphere(ax2)

trajectory_y = []
for theta in angles:
    state = Ry(theta) @ initial
    bloch = state_to_bloch(state)
    trajectory_y.append(bloch)
trajectory_y = np.array(trajectory_y)

ax2.plot(trajectory_y[:, 0], trajectory_y[:, 1], trajectory_y[:, 2], 'r-', linewidth=2, label='Ry trajectory')
ax2.scatter([0], [0], [1], c='green', s=100, marker='*', label='Start |0⟩')
ax2.set_title('Ry(θ) from |0⟩\n(rotation about Y-axis)')
ax2.legend()

# Plot 3: Rz rotations (from |+⟩)
ax3 = fig.add_subplot(133, projection='3d')
draw_bloch_sphere(ax3)

ket_plus = (ket_0 + ket_1) / np.sqrt(2)
trajectory_z = []
for theta in angles:
    state = Rz(theta) @ ket_plus
    bloch = state_to_bloch(state)
    trajectory_z.append(bloch)
trajectory_z = np.array(trajectory_z)

ax3.plot(trajectory_z[:, 0], trajectory_z[:, 1], trajectory_z[:, 2], 'purple', linewidth=2, label='Rz trajectory')
ax3.scatter([1], [0], [0], c='green', s=100, marker='*', label='Start |+⟩')
ax3.set_title('Rz(θ) from |+⟩\n(rotation about Z-axis)')
ax3.legend()

plt.tight_layout()
plt.savefig('rotation_gates_trajectories.png', dpi=150, bbox_inches='tight')
plt.show()
print("Saved: rotation_gates_trajectories.png")

# Rotation about arbitrary axis
print("\n" + "=" * 60)
print("ROTATION ABOUT ARBITRARY AXIS")
print("=" * 60)

fig2 = plt.figure(figsize=(10, 8))
ax = fig2.add_subplot(111, projection='3d')
draw_bloch_sphere(ax)

# Rotation axis: diagonal between X and Z (like Hadamard)
n_hadamard = np.array([1, 0, 1]) / np.sqrt(2)
ax.quiver(0, 0, 0, n_hadamard[0]*1.5, n_hadamard[1]*1.5, n_hadamard[2]*1.5,
          color='purple', linewidth=3, arrow_length_ratio=0.1, label='Rotation axis n̂')

# Trajectory from various starting points
colors = plt.cm.viridis(np.linspace(0, 1, 5))
starting_states = [ket_0, ket_1, ket_plus, (ket_0 + 1j*ket_1)/np.sqrt(2)]
names = ['|0⟩', '|1⟩', '|+⟩', '|+y⟩']

for state, name, color in zip(starting_states, names, colors):
    trajectory = []
    for theta in np.linspace(0, 2*np.pi, 50):
        rotated = Rn(theta, n_hadamard) @ state
        trajectory.append(state_to_bloch(rotated))
    trajectory = np.array(trajectory)
    ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2],
            color=color, linewidth=2, label=f'From {name}')
    ax.scatter(*trajectory[0], c=[color], s=80, marker='o')

ax.set_title('Rotation about axis n̂ = (1,0,1)/√2\n(This is the Hadamard rotation axis)')
ax.legend(loc='upper left')

plt.tight_layout()
plt.savefig('arbitrary_axis_rotation.png', dpi=150, bbox_inches='tight')
plt.show()
print("Saved: arbitrary_axis_rotation.png")

# Parameter-shift rule demonstration
print("\n" + "=" * 60)
print("PARAMETER-SHIFT RULE")
print("=" * 60)

def expectation_Ry(theta):
    """Compute <0|Ry(θ)†·Z·Ry(θ)|0>."""
    state = Ry(theta) @ ket_0
    return np.real((state.conj().T @ Z @ state)[0, 0])

# Analytical derivative
def analytical_derivative(theta):
    """d/dθ <Z> = -sin(θ)."""
    return -np.sin(theta)

# Parameter-shift rule
def parameter_shift_derivative(theta, shift=np.pi/2):
    """(f(θ+π/2) - f(θ-π/2)) / 2."""
    return (expectation_Ry(theta + shift) - expectation_Ry(theta - shift)) / 2

theta_values = np.linspace(0, 2*np.pi, 100)
f_values = [expectation_Ry(t) for t in theta_values]
analytical = [analytical_derivative(t) for t in theta_values]
param_shift = [parameter_shift_derivative(t) for t in theta_values]

fig3, axes = plt.subplots(1, 2, figsize=(12, 4))

axes[0].plot(theta_values/np.pi, f_values, 'b-', linewidth=2, label='⟨Z⟩ = cos(θ)')
axes[0].set_xlabel('θ (units of π)')
axes[0].set_ylabel('⟨Z⟩')
axes[0].set_title('Expectation value ⟨0|Ry(θ)†ZRy(θ)|0⟩')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

axes[1].plot(theta_values/np.pi, analytical, 'b-', linewidth=2, label='Analytical: -sin(θ)')
axes[1].plot(theta_values/np.pi, param_shift, 'r--', linewidth=2, label='Parameter-shift')
axes[1].set_xlabel('θ (units of π)')
axes[1].set_ylabel('d⟨Z⟩/dθ')
axes[1].set_title('Gradient Computation')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
plt.savefig('parameter_shift_rule.png', dpi=150, bbox_inches='tight')
plt.show()
print("Saved: parameter_shift_rule.png")

print("\nParameter-shift rule verified!")
print("This enables gradient computation on quantum hardware.")

# Composition and non-commutativity
print("\n" + "=" * 60)
print("COMPOSITION AND NON-COMMUTATIVITY")
print("=" * 60)

fig4 = plt.figure(figsize=(10, 8))
ax = fig4.add_subplot(111, projection='3d')
draw_bloch_sphere(ax)

# Compare Rx(π/2)·Ry(π/2) vs Ry(π/2)·Rx(π/2) on |0⟩
initial = ket_0

# Path 1: Rx then Ry
state_after_Rx = Rx(np.pi/2) @ initial
state_after_RxRy = Ry(np.pi/2) @ state_after_Rx

# Path 2: Ry then Rx
state_after_Ry = Ry(np.pi/2) @ initial
state_after_RyRx = Rx(np.pi/2) @ state_after_Ry

# Plot trajectories
b0 = state_to_bloch(initial)
b_Rx = state_to_bloch(state_after_Rx)
b_RxRy = state_to_bloch(state_after_RxRy)
b_Ry = state_to_bloch(state_after_Ry)
b_RyRx = state_to_bloch(state_after_RyRx)

# Path 1: Blue
ax.scatter(*b0, c='green', s=150, marker='*', label='Start |0⟩', zorder=5)
ax.plot([b0[0], b_Rx[0]], [b0[1], b_Rx[1]], [b0[2], b_Rx[2]], 'b-', linewidth=3, label='Rx(π/2) first')
ax.scatter(*b_Rx, c='blue', s=100, marker='o')
ax.plot([b_Rx[0], b_RxRy[0]], [b_Rx[1], b_RxRy[1]], [b_Rx[2], b_RxRy[2]], 'b--', linewidth=3)
ax.scatter(*b_RxRy, c='blue', s=150, marker='s', label=f'End: Ry·Rx', zorder=5)

# Path 2: Red
ax.plot([b0[0], b_Ry[0]], [b0[1], b_Ry[1]], [b0[2], b_Ry[2]], 'r-', linewidth=3, label='Ry(π/2) first')
ax.scatter(*b_Ry, c='red', s=100, marker='o')
ax.plot([b_Ry[0], b_RyRx[0]], [b_Ry[1], b_RyRx[1]], [b_Ry[2], b_RyRx[2]], 'r--', linewidth=3)
ax.scatter(*b_RyRx, c='red', s=150, marker='^', label=f'End: Rx·Ry', zorder=5)

ax.set_title('Non-Commutativity: Rx(π/2)·Ry(π/2) vs Ry(π/2)·Rx(π/2)\nDifferent paths → Different endpoints!')
ax.legend()

plt.tight_layout()
plt.savefig('rotation_noncommutativity.png', dpi=150, bbox_inches='tight')
plt.show()
print("Saved: rotation_noncommutativity.png")

print(f"\nFinal states differ:")
print(f"   Ry·Rx|0⟩ Bloch: ({b_RxRy[0]:.3f}, {b_RxRy[1]:.3f}, {b_RxRy[2]:.3f})")
print(f"   Rx·Ry|0⟩ Bloch: ({b_RyRx[0]:.3f}, {b_RyRx[1]:.3f}, {b_RyRx[2]:.3f})")
print(f"   Distance: {np.linalg.norm(b_RxRy - b_RyRx):.3f}")
```

---

## Summary

### Key Formulas

| Concept | Formula |
|---------|---------|
| Rodrigues formula | $R_j(\theta) = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}\sigma_j$ |
| Rx gate | $R_x(\theta) = \begin{pmatrix} \cos\frac{\theta}{2} & -i\sin\frac{\theta}{2} \\ -i\sin\frac{\theta}{2} & \cos\frac{\theta}{2} \end{pmatrix}$ |
| Ry gate | $R_y(\theta) = \begin{pmatrix} \cos\frac{\theta}{2} & -\sin\frac{\theta}{2} \\ \sin\frac{\theta}{2} & \cos\frac{\theta}{2} \end{pmatrix}$ |
| Rz gate | $R_z(\theta) = \begin{pmatrix} e^{-i\theta/2} & 0 \\ 0 & e^{i\theta/2} \end{pmatrix}$ |
| Composition | $R_j(\theta_1)R_j(\theta_2) = R_j(\theta_1 + \theta_2)$ |
| Periodicity | $R_j(2\pi) = -I$, $R_j(4\pi) = I$ |
| Arbitrary axis | $R_{\hat{n}}(\theta) = \cos\frac{\theta}{2}I - i\sin\frac{\theta}{2}(\hat{n}\cdot\vec{\sigma})$ |

### Main Takeaways

1. **Exponential form:** Rotation gates arise from exponentiating Pauli generators
2. **Rodrigues formula:** Simple closed form for all rotation matrices
3. **Axis-specific properties:** Ry is real; Rz is diagonal; Rx mixes with phases
4. **Spinor behavior:** 2π rotation gives -I, not I (spin-1/2 signature)
5. **Non-commutativity:** Different axis rotations don't commute - order matters
6. **Variational computing:** Continuous rotations enable gradient-based optimization

---

## Daily Checklist

- [ ] I can derive rotation gates from the exponential map
- [ ] I can write Rx, Ry, Rz matrices using the Rodrigues formula
- [ ] I understand the connection to Pauli and phase gates
- [ ] I can explain 2π vs 4π periodicity (spinor nature)
- [ ] I understand why different-axis rotations don't commute
- [ ] I completed the Bloch sphere trajectory visualization
- [ ] I solved at least 3 practice problems

---

## Preview of Day 565

Tomorrow we bring everything together with the **Bloch sphere representation**. We'll prove that ANY single-qubit unitary can be written as $U = e^{i\alpha}R_{\hat{n}}(\theta)$ for some global phase α, rotation axis $\hat{n}$, and angle θ. This axis-angle parameterization provides complete geometric insight into single-qubit operations.
